<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[开始使用GitHub Pages]]></title>
      <url>2016%2F10%2F28%2FFirstPost%2F</url>
      <content type="text"><![CDATA[&#x5F00;&#x59CB;&#x4F7F;&#x7528;GitHub Pages&#xFF0C;&#x5E76;&#x4F7F;&#x7528;Hexo&#x3002; 2016.10.28 22:17]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[近期学到的]]></title>
      <url>2016%2F10%2F22%2F%E8%BF%91%E6%9C%9F%E5%AD%A6%E5%88%B0%E7%9A%84%2F</url>
      <content type="text"><![CDATA[Markdown&#x3000;&#x3000;&#x7F16;&#x8F91;&#x5668;&#x4F7F;&#x7528;Remarkable &#x3000;&#x3000;&#x8BED;&#x6CD5;&#xFF0C;&#x53C2;&#x8003;Remarkable&#x5E2E;&#x52A9;&#x91CC;&#x7684;Tutorial MathjaxMathjax&#x8BED;&#x6CD5;&#x7B80;&#x4ECB; Sphinx&#x4F7F;&#x7528;docstring&#x751F;&#x6210;APIdoc &#x3000;&#x3000;1$sphinx-apidoc -o /home/me/outdir -F /home/me/code &#x3000;&#x3000;&#x3000;1$cd /home/me/outdir 1$gedit conf.py 12345import osimport syssys.path.insert(0, os.path.abspath(&apos;../..&apos;))........ reStructuredTextreStructuredText&#x8BED;&#x6CD5;&#x7B80;&#x4ECB;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重定向]]></title>
      <url>2016%2F09%2F12%2F%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
      <content type="text"><![CDATA[Linux &#x7EC8;&#x7AEF;:12345cat testin.txt|./test./test&gt;testout.txtcat testin.txt|./test&gt;testout.txt Windows cmd:&#x3000;&#x3000;&#x3000;&#x3000;12345&#x3000;&#x3000;test.exe&lt;testin.txt&#x3000;&#x3000;test.exe&gt;testout.txt&#x3000;&#x3000;test.exe&lt;testin.txt&gt;testout.txt C&#x4EE3;&#x7801;&#xFF1A;123456789freopen(&quot;testin.txt&quot;,&quot;r&quot;,stdin);fclose(stdin); freopen(&quot;testout.txt&quot;,&quot;w&quot;,stdout);fclose(stdout);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CCF考试]]></title>
      <url>2016%2F09%2F11%2FCCF%E8%AE%B0%E5%BD%95%2F</url>
      <content type="text"><![CDATA[&#x7B2C;&#x516B;&#x6B21;CCF&#x8003;&#x8BD5;&#x8BB0;&#x5F55; &#x4EE3;&#x7801;&#x8FD8;&#x4E0D;&#x77E5;&#x9053;&#x5BF9;&#x4E0D;&#x5BF9;&#xFF0C;&#x8FC7;&#x4E24;&#x5929;&#x51FA;&#x6210;&#x7EE9;&#x3002; &#x6210;&#x7EE9;&#x51FA;&#x6765;&#x4E86;&#xFF0C;310&#x5206;&#x3002; 100+100+100+10+0&#xFF1B; &#x8003;&#x8BD5;13:27&#x5F00;&#x59CB;&#xFF0C;17:30&#x7ED3;&#x675F;&#xFF0C;&#x63D0;&#x4EA4;&#x7B2C;4&#x9898;&#x540E;&#x4E0D;&#x518D;&#x7B54;&#x9898;&#xFF0C;&#x53EA;&#x662F;&#x68C0;&#x67E5;&#x524D;&#x56DB;&#x9898;&#x7684;&#x4EE3;&#x7801; &#x7B2C;&#x4E00;&#x6B21;&#x63D0;&#x4EA4;&#xFF1A;1 13:342 14:00&#x5DE6;&#x53F3;3 15:324 16:565 &#x6700;&#x540E;&#x4E00;&#x6B21;&#x63D0;&#x4EA4;&#xFF1A;1 13:342 16:063 15:324 16:565 &#x4EE3;&#x7801;&#x884C;&#x6570;&#xFF08;&#x4E0D;&#x7B97;&#x7A7A;&#x884C;&#xFF0C;&#x7B97;&#x65E0;&#x7528;&#x7684;include&#xFF0C;&#x7B97;&#x6CE8;&#x91CA;&#x6389;&#x7684;&#x90E8;&#x5206;&#xFF09;1 232 503 1014 715&#x5171; 245 &#x884C; &#x6E90;&#x4EE3;&#x7801;&#xFF1A;11234567891011121314151617181920212223#include &lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;string&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char** argv) { int n; cin&gt;&gt;n; int * a=new int[n]; for(int i=0;i&lt;n;i++){ cin&gt;&gt;a[i]; } int m=-99999; for(int i=1;i&lt;n;i++){ int t=a[i]-a[i-1]; t=t&gt;0?t:0-t; m=m&lt;t?t:m; } cout&lt;&lt;m; return 0;} 21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;string&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char** argv) { int * a=new int[20]; for(int i=0;i&lt;20;i++){ a[i]=5; } int n,t; cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ cin&gt;&gt;t; int flag=0; for(int i=0;i&lt;20;i++){ if(a[i]&gt;=t){ for(int j=0;j&lt;t;j++){ cout&lt;&lt;i*5+5-a[i]+j+1&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; a[i]-=t; flag=1; break; } } if(flag==0){ for(int i=0;i&lt;20;i++){ if(a[i]-t&gt;0){ for(int j=0;j&lt;t;j++){ cout&lt;&lt;i*5+5-a[i]+j+1&lt;&lt;&quot; &quot;; } a[i]-=t; break; }else{ for(int j=0;j&lt;a[i];j++){ cout&lt;&lt;i*5+5-a[i]+j+1&lt;&lt;&quot; &quot;; } t-=a[i]; a[i]=0; } } cout&lt;&lt;endl; } } delete []a; return 0;} 3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;string&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;struct suicong{ int hth; int att; suicong(int h,int a){ hth=h; att=a; }};struct ying{ int hth; int att; ying(){ hth=30; att=0; }};int main(int argc, char** argv) { vector&lt;suicong&gt;* war=new vector&lt;suicong&gt;[2]; //vector&lt;suicong&gt; war0; //vector&lt;suicong&gt; war1; //suicong* ying0=new suicong(30,0,1); //suicong* ying1=new suicong(30,0,1); ying ying[2]; //war[0].push_back(*ying0); //war[1].push_back(*ying1); int n; cin&gt;&gt;n; int t=0; //int y[2]; for(int i=0;i&lt;n;i++){ string str; cin&gt;&gt;str; if(str==&quot;summon&quot;){ int p,h,a; cin&gt;&gt;p&gt;&gt;a&gt;&gt;h; suicong* temp=new suicong(h,a); war[t].insert(war[t].begin()+p-1,*temp); } if(str==&quot;attack&quot;){ int d,a; cin&gt;&gt;a&gt;&gt;d; if(d==0){ ying[1-t].hth-=war[t].at(a-1).att; war[t].at(a-1).hth-=ying[1-t].att; if(war[t].at(a-1).hth&lt;=0){ war[t].erase(war[t].begin()+a-1); } } else{ //cout&lt;&lt;t&lt;&lt;&quot; &quot;&lt;&lt;war[t].size()&lt;&lt;&quot; &quot;&lt;&lt;war[1-t].size(); war[1-t].at(d-1).hth-=war[t].at(a-1).att; war[t].at(a-1).hth-=war[1-t].at(d-1).att; if(war[t].at(a-1).hth&lt;=0){ war[t].erase(war[t].begin()+a-1); } if(war[1-t].at(d-1).hth&lt;=0){ war[1-t].erase(war[1-t].begin()+d-1); } } } if(str==&quot;end&quot;){ t=1-t; } /*cout&lt;&lt;0&lt;&lt;&quot; &quot;&lt;&lt;ying[0].hth&lt;&lt;&quot; &quot;&lt;&lt;war[0].size()&lt;&lt;&quot; &quot;; for(int i=0;i&lt;war[0].size();i++){ cout&lt;&lt;war[0].at(i).hth&lt;&lt;&quot; &quot;; }cout&lt;&lt;endl; cout&lt;&lt;1&lt;&lt;&quot; &quot;&lt;&lt;ying[1].hth&lt;&lt;&quot; &quot;&lt;&lt;war[1].size()&lt;&lt;&quot; &quot;; for(int i=0;i&lt;war[1].size();i++){ cout&lt;&lt;war[1].at(i).hth&lt;&lt;&quot; &quot;; }cout&lt;&lt;endl;*/ } if(ying[0].hth&lt;=0){ cout&lt;&lt;-1&lt;&lt;endl; }else if(ying[1].hth&lt;=0){ cout&lt;&lt;1&lt;&lt;endl; }else{ cout&lt;&lt;0&lt;&lt;endl; } cout&lt;&lt;ying[0].hth&lt;&lt;endl; cout&lt;&lt;war[0].size()&lt;&lt;&quot; &quot;; for(int i=0;i&lt;war[0].size();i++){ cout&lt;&lt;war[0].at(i).hth&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; cout&lt;&lt;ying[1].hth&lt;&lt;endl; cout&lt;&lt;war[1].size()&lt;&lt;&quot; &quot;; for(int i=0;i&lt;war[1].size();i++){ cout&lt;&lt;war[1].at(i).hth&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; return 0;} 4 &#x6B64;&#x4EE3;&#x7801;&#x662F;&#x9519;&#x8BEF;&#x7684;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;string&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;struct road{ int to; int len; road(int t,int l){ to=t;len=l; }};struct city{ //int num; int pre=0; int tlen=999999999; vector&lt;road&gt; v; void addroad(int t,int len){ road* r=new road(t,len); v.push_back(*r); }};int get(city* cs,int i,int j){ for(int k=0;k&lt;cs[i].v.size();k++){ if(cs[i].v.at(k).to==j)return cs[i].v.at(k).len; } return 0;}int main(int argc, char** argv) { int n,m; cin&gt;&gt;n&gt;&gt;m; city* cs=new city[n+1]; for(int i=0;i&lt;m;i++){ int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cs[a].addroad(b,c); cs[b].addroad(a,c); } cs[1].tlen=0; queue&lt;int&gt; q; q.push(1); while(!q.empty()){ int t=q.front(); q.pop(); for(int i=0;i&lt;cs[t].v.size();i++){ if(cs[cs[t].v.at(i).to].tlen&gt;cs[t].tlen+cs[t].v.at(i).len){ cs[cs[t].v.at(i).to].tlen=cs[t].tlen+cs[t].v.at(i).len; cs[cs[t].v.at(i).to].pre=t; q.push(cs[t].v.at(i).to); } if(cs[cs[t].v.at(i).to].tlen==cs[t].tlen+cs[t].v.at(i).len){ if(get(cs,cs[cs[t].v.at(i).to].pre,cs[t].v.at(i).to)&gt;cs[t].v.at(i).len){ cs[cs[t].v.at(i).to].tlen=cs[t].tlen+cs[t].v.at(i).len; cs[cs[t].v.at(i).to].pre=t; q.push(cs[t].v.at(i).to); } } } }/* for(int i=0;i&lt;n+1;i++){ cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;cs[i].pre&lt;&lt;&quot; &quot;&lt;&lt;get(cs,i,cs[i].pre)&lt;&lt;endl; }*/ int ll=0; for(int i=0;i&lt;n+1;i++){ ll+=get(cs,i,cs[i].pre); } cout&lt;&lt;ll; return 0;} 2016.9.11 &#x665A;8:40]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单的词法分析和语法分析（C++实现，CodeBlocks+GCC编译）]]></title>
      <url>2016%2F07%2F13%2F%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[&#x8BF4;&#x660E;&#xFF1A;&#x3000;&#x3000;&#x5206;&#x6790;&#x7684;&#x8BED;&#x8A00;&#x662F;SNL&#x8BED;&#x8A00;&#xFF0C;&#x8BE6;&#x89C1;&#x300A;&#x7F16;&#x8BD1;&#x7A0B;&#x5E8F;&#x7684;&#x8BBE;&#x8BA1;&#x4E0E;&#x5B9E;&#x73B0;&#x300B;&#xFF08; &#x5218;&#x78CA;&#x3001;&#x91D1;&#x82F1;&#x3001;&#x5F20;&#x6676;&#x3001;&#x5F20;&#x8377;&#x82B1;&#x3001;&#x5355;&#x90F8;&#x7F16;&#x8457;&#xFF09; &#x3000;&#x3000;&#x8BCD;&#x6CD5;&#x5206;&#x6790;&#x5C31;&#x662F;&#x5B9E;&#x73B0;&#x4E86;&#x8BCD;&#x6CD5;&#x5206;&#x6790;&#x7684;&#x81EA;&#x52A8;&#x673A; &#x3000;&#x3000;&#x8BED;&#x6CD5;&#x5206;&#x6790;&#x4F7F;&#x7528;&#x9012;&#x5F52;&#x4E0B;&#x964D;&#x6CD5; &#x8FD0;&#x884C;&#x7ED3;&#x679C;&#xFF1A;&#x3000;&#x3000;&#x8BCD;&#x6CD5;&#x5206;&#x6790; &#x5F97;&#x5230;TokenList &#x3000;&#x3000;&#x8BED;&#x6CD5;&#x5206;&#x6790; &#x8F93;&#x51FA;&#x8BED;&#x6CD5;&#x6811; &#x3000;&#x3000; &#x8FD0;&#x884C;&#x8F93;&#x51FA;&#xFF1A; &#x4EE3;&#x7801;&#xFF1A;main.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;vector&gt;#include&lt;string.h&gt;using namespace std;#define NUMOFRESERVED 22#define NUMOFSYMBOLS 20#define RES 0#define ID 1#define NUM 2#define SYM 3#define STR 4#define PLUS 100#define SUB 101#define MUL 102#define DIV 103#define LT 104#define LBRACK 105#define RBRACK 106#define LSQUBRACK 107#define RSQUBRACK 108#define POINT 109#define SEMI 110#define LBRACE 111#define RBRACE 112#define EOFF 113#define BLANK 114#define QUO 115#define EQU 116#define INDEX 117#define ASSI 118#define COM 119#define uint unsignedtypedef struct Token { int id; int ptr; int linenum;} Token;typedef struct Node { char *desc; vector&lt;Node*&gt; children; Node(const char* str) { desc=new char[30]; strcpy(desc,str); }} Node;vector&lt;Token&gt;* tokens;int Token_n=0;const char* reserved_words[NUMOFRESERVED]= {&quot;begin&quot;,&quot;end&quot;,&quot;program&quot;,&quot;var&quot;, &quot;type&quot;,&quot;procedure&quot;,&quot;while&quot;,&quot;endwh&quot;, &quot;integer&quot;,&quot;char&quot;,&quot;array&quot;,&quot;of&quot;, &quot;intc&quot;,&quot;record&quot;,&quot;if&quot;,&quot;then&quot;, &quot;else&quot;,&quot;fi&quot;,&quot;do&quot;,&quot;write&quot;, &quot;read&quot;,&quot;return&quot; };static const char* symbol_table[NUMOFSYMBOLS]= {&quot;+&quot;,&quot;-&quot;,&quot;*&quot;,&quot;/&quot;,&quot;&lt;&quot;, &quot;(&quot;,&quot;)&quot;,&quot;[&quot;,&quot;]&quot;,&quot;.&quot;, &quot;;&quot;,&quot;{&quot;,&quot;}&quot;,&quot;EOF&quot;,&quot;BLANK&quot;, &quot;\&apos;&quot;,&quot;=&quot;,&quot;..&quot;,&quot;:=&quot;,&quot;,&quot; };void syntaxError(const char* message);Node* MatchRES(const char* expected);Node* MatchSYM(const int expected);Node* MatchID();Node* MatchNUM();bool isRES(const char* res);bool isSYM(const int res);bool isID();bool isNUM();bool isLineEnd();Node* Program();Node* ProgramHead();Node* DeclarePart();Node* TypeDec();Node* TypeDeclaration();Node* TypeDecList();Node* TypeDecMore();Node* TypeId();Node* TypeName();Node* BaseType();Node* StructureType();Node* ArrayType();Node* RecType();Node* FieldDecList();Node* FieldDecMore();Node* IdList();Node* IdMore();Node* VarDec();Node* VarDeclaration();Node* VarDecList();Node* VarDecMore();Node* VarIdList();Node* VarIdMore();Node* ProcDec();Node* ProcDeclaration();Node* ParamList();Node* ParamDecList();Node* ParamMore();Node* Param();Node* FormList();Node* FidMore();Node* ProcDecPart();Node* ProcBody();Node* ProgramBody();Node* StmList();Node* StmMore();Node* Stm();Node* AssCall();Node* AssignmentRest();Node* ConditionalStm();Node* LoopStm();Node* InputStm();Node* OutputStm();Node* ReturnStm();Node* CallStmRest();Node* ActParamList();Node* ActParamMore();Node* Exp();Node* Term();Node* OtherFactor();Node* OtherTerm();Node* Factor();Node* Variable();Node* VariMore();Node* FieldVar();Node* FieldVarMore();Node* Parse();Node* CmpOp();Node* AddOp();Node* MultOp();void show_tree(Node* root,int depth,vector&lt;int&gt;* v,bool islast);int add(vector&lt;Node* &gt;&amp; children,Node* node) { if(node!=NULL) { children.push_back(node); } return 0;}#define COMMENT_ERROR -1000#define STR_ERROR -1001#define SYM_ERROR -1002#define NOT_REC_SYMBOL -1003vector&lt;char*&gt; ID_table;vector&lt;uint&gt; NUM_table;vector&lt;char*&gt; STR_table;int ID_n=0,NUM_n=0,STR_n=0;int num_of_lines=1;FILE * file;/***************************************************************************************//***************** &#x8BCD;&#x6CD5;&#x5206;&#x6790; *****************//***************************************************************************************/void handle_error(int error_num,const char* str) { printf(&quot;&#x884C;&#x53F7;:%d \t&quot;,num_of_lines); switch(error_num) { case COMMENT_ERROR: printf(&quot;&#x6CE8;&#x91CA;&#x672A;&#x7ED3;&#x675F; \t&quot;); break; case SYM_ERROR: printf(&quot;&#x51FA;&#x73B0;&#x672A;&#x5B9A;&#x4E49;&#x7684;&#x7B26;&#x53F7;&#xFF0C;&#x60A8;&#x60F3;&#x8F93;&#x5165;&#x7684;&#x662F;\&quot;:=\&quot;&#x5417;? \t&quot;); break; case STR_ERROR: printf(&quot;&#x5B57;&#x7B26;&#x4E32;&#x672A;&#x7ED3;&#x675F; \t&quot;); break; case NOT_REC_SYMBOL: printf(&quot;&#x51FA;&#x73B0;&#x672A;&#x5B9A;&#x4E49;&#x7684;&#x7B26;&#x53F7; \t&quot;); break; } printf(&quot;%s\n&quot;,str); exit(-1);}char getNextChar() { char c; c=fgetc(file); return c;}void ungetNextChar() { fseek(file,-1,SEEK_CUR);}int reservedLookup(char* str) { for(int i=0; i&lt;NUMOFRESERVED; i++) { if(strcmp(str,reserved_words[i])==0)return i; } return -1;}int str_to_num(char* str) { int len=strlen(str); int n=0; for(int i=0; i&lt;len; i++) { n=n*10+str[i]-&apos;0&apos;; } return n;}int addIDTable(char* str) { ID_table.push_back(str); return ID_n++;}int addNUMTable(int num) { NUM_table.push_back(num); return NUM_n++;}int addSTRTable(char* str ) { STR_table.push_back(str); return STR_n++;}Token scan() { static const char symbols[12]= {&apos;+&apos;,&apos;-&apos;,&apos;*&apos;,&apos;/&apos;,&apos;&lt;&apos;,&apos;(&apos;,&apos;)&apos;,&apos;[&apos;,&apos;]&apos;,&apos;;&apos;,&apos;=&apos;,&apos;,&apos;}; static const int symbols_n[12]= {PLUS,SUB,MUL,DIV,LT,LBRACK,RBRACK,LSQUBRACK,RSQUBRACK,SEMI,EQU,COM}; Token t; t.linenum=num_of_lines; char* str=new char[256]; strcpy(str,&quot;&quot;);//&#x5B57;&#x7B26;&#x4E32;&#x8981;&#x521D;&#x59CB;&#x5316;&#xFF0C;&#x4E0D;&#x7136;&#x6709;&#x4E71;&#x7801; char c[2]= {&apos;a&apos;,&apos;\0&apos;}; c[0]=getNextChar();LS0: if(c[0]&gt;=&apos;a&apos;&amp;&amp;c[0]&lt;=&apos;z&apos;)goto LS1; if(c[0]&gt;=&apos;A&apos;&amp;&amp;c[0]&lt;=&apos;Z&apos;)goto LS1; if(c[0]&gt;=&apos;0&apos;&amp;&amp;c[0]&lt;=&apos;9&apos;)goto LS2; int indexofsym; for(indexofsym=0; indexofsym&lt;12; indexofsym++) { if(c[0]==symbols[indexofsym]) { goto LS3; } } if(c[0]==&apos;.&apos;)goto LS4; if(c[0]==&apos;{&apos;)goto LS5; if(c[0]==&apos;:&apos;)goto LS6; if(c[0]==&apos;\&apos;&apos;)goto LS7; if(c[0]==&apos;\n&apos;)goto LS8; if(c[0]==EOF)goto LS9; if(c[0]==&apos;\t&apos;||c[0]==&apos; &apos;)goto LS10; goto OTHER;LS1: strcat(str,c); c[0]=getNextChar(); if(c[0]&gt;=&apos;a&apos;&amp;&amp;c[0]&lt;=&apos;z&apos;)goto LS1; else if(c[0]&gt;=&apos;A&apos;&amp;&amp;c[0]&lt;=&apos;Z&apos;)goto LS1; else if(c[0]&gt;=&apos;0&apos;&amp;&amp;c[0]&lt;=&apos;9&apos;)goto LS1; ungetNextChar(); int nres; if(nres=reservedLookup(str),nres!=-1) { t.id=RES; t.ptr=nres; return t; } else { t.id=ID; t.ptr=addIDTable(str); return t; }LS2: strcat(str,c); c[0]=getNextChar(); if(c[0]&gt;=&apos;0&apos;&amp;&amp;c[0]&lt;=&apos;9&apos;)goto LS2; ungetNextChar(); t.id=NUM; t.ptr=addNUMTable(str_to_num(str)); return t;LS3: t.ptr=symbols_n[indexofsym]; t.id=SYM; return t;LS4: strcat(str,c); c[0]=getNextChar(); if(c[0]==&apos;.&apos;) { t.id=SYM; t.ptr=INDEX; return t; } else { t.id=SYM; t.ptr=POINT; ungetNextChar(); return t; }LS5: while(c[0]=getNextChar(),c[0]!=EOF&amp;&amp;c[0]!=&apos;}&apos;) { if(c[0]==&apos;\n&apos;||c[0]==&apos;\r&apos;)num_of_lines++; } if(c[0]==&apos;}&apos;) { c[0]=getNextChar(); goto LS0; } else { handle_error(COMMENT_ERROR,&quot;&quot;); }LS6: strcat(str,c); c[0]=getNextChar(); if(c[0]==&apos;=&apos;) { t.id=SYM; t.ptr=ASSI; return t; } else { handle_error(SYM_ERROR,&quot;&#x7B26;&#x53F7;&#x4E3A; \&apos;:\&apos;&quot;); }LS7: while(c[0]=getNextChar(),c[0]!=EOF&amp;&amp;c[0]!=&apos;\&apos;&apos;) { strcat(str,c); } if(c[0]==&apos;\&apos;&apos;) { t.id=STR; t.ptr=addSTRTable(str); return t; } else { handle_error(STR_ERROR,&quot;&quot;); }LS8: t.id=-1; num_of_lines++; return t;LS9: t.id=SYM; t.ptr=EOFF; return t;LS10: t.id=-1; return t;OTHER: handle_error(NOT_REC_SYMBOL,c); t.id=-1; return t;}void show_token(Token t) { if(t.id==STR) { printf(&quot;&lt;%d %s %s&gt; \n&quot;,t.linenum,&quot;STR&quot;,STR_table[t.ptr]); return ; } if(t.id==NUM) { printf(&quot;&lt;%d %s %d&gt; \n&quot;,t.linenum,&quot;NUM&quot;,NUM_table[t.ptr]); return ; } if(t.id==ID) { printf(&quot;&lt;%d %s %s&gt; \n&quot;,t.linenum,&quot;ID&quot;,ID_table[t.ptr]); return ; } if(t.id==RES) { printf(&quot;&lt;%d %s %s&gt; \n&quot;,t.linenum,&quot;RES&quot;,reserved_words[t.ptr]); return ; } if(t.id==SYM) { printf(&quot;&lt;%d %s %s&gt; \n&quot;,t.linenum,&quot;SYM&quot;,symbol_table[t.ptr-100]); return ; } return ;}vector&lt;Token&gt;* getTokenlist(const char* filename) { tokens-&gt;clear(); file=fopen(filename,&quot;r&quot;); Token temp; while(temp=scan(),!(temp.id==SYM&amp;&amp;temp.ptr==EOFF)) { if(temp.id!=-1) { tokens-&gt;push_back(temp); if(temp.id==RES&amp;&amp;strcmp(&quot;end&quot;,reserved_words[temp.ptr])==0) { char c; if(c=getNextChar(),c==&apos;.&apos;) { break; } else { ungetNextChar(); } } } } fclose(file); return tokens;}void show_Token_list() { int len=tokens-&gt;size(); for(int i=0; i&lt;len; i++) { show_token(tokens-&gt;at(i)); }}void write_token(FILE* file,Token t) { if(t.id==STR) { fprintf(file,&quot;&lt;%s %s&gt; \n&quot;,&quot;STR&quot;,STR_table[t.ptr]); return ; } if(t.id==NUM) { fprintf(file,&quot;&lt;%s %d&gt; \n&quot;,&quot;NUM&quot;,NUM_table[t.ptr]); return ; } if(t.id==ID) { fprintf(file,&quot;&lt;%s %s&gt; \n&quot;,&quot;ID&quot;,ID_table[t.ptr]); return ; } if(t.id==RES) { fprintf(file,&quot;&lt;%s %s&gt; \n&quot;,&quot;RES&quot;,reserved_words[t.ptr]); return ; } if(t.id==SYM) { fprintf(file,&quot;&lt;%s %s&gt; \n&quot;,&quot;SYM&quot;,symbol_table[t.ptr-100]); return ; } return ;}void save_Token_list(const char* filename) { FILE* f=fopen(filename,&quot;w&quot;); int len=tokens-&gt;size(); for(int i=0; i&lt;len; i++) { write_token(f,tokens-&gt;at(i)); } fclose(f);}/***************************************************************************************//***************** &#x8BED;&#x6CD5;&#x5206;&#x6790; *****************//***************************************************************************************/void syntaxError(const char* message) { if(strcmp(message,&quot;outofrange&quot;)==0) { printf(&quot;&#x51FA;&#x73B0;&#x8D8A;&#x754C;&#x9519;&#x8BEF;&quot;); printf(&quot; Token_n:%d tokens-&gt;size:%d\n&quot;,Token_n,tokens-&gt;size()); exit(-1); } printf(&quot;&#x884C;&#x53F7;&#xFF1A;%d %s&quot;,tokens-&gt;at(Token_n).linenum,message); printf(&quot;&#x5F53;&#x524D;token&#xFF1A;&quot;); show_token(tokens-&gt;at(Token_n)); exit(-1);}Node* MatchRES(const char* expected) { if(Token_n&gt;=(int)tokens-&gt;size())syntaxError(&quot;outofrange&quot;); int id=tokens-&gt;at(Token_n).id,ptr=tokens-&gt;at(Token_n).ptr; if(id==RES&amp;&amp;strcmp(expected,reserved_words[ptr])==0) { Node*t =new Node(expected); Token_n++; return t; } char* message=new char[100]; strcpy(message,&quot;match res error.\nexpect: &quot;); strcat(message,expected); strcat(message,&quot;\n&quot;); syntaxError(message); delete message; return NULL;}Node* MatchNUM() { if(Token_n&gt;=(int)tokens-&gt;size())syntaxError(&quot;outofrange&quot;); int id=tokens-&gt;at(Token_n).id; if(id==NUM) { Node* t= new Node(&quot;NUM&quot;); Token_n++; return t; } syntaxError(&quot;match num error\n&quot;); return NULL;}Node* MatchSTR() { if(Token_n&gt;=(int)tokens-&gt;size())syntaxError(&quot;outofrange&quot;); int id=tokens-&gt;at(Token_n).id; if(id==STR) { Node* t= new Node(&quot;STR&quot;); Token_n++; return t; } syntaxError(&quot;match str error\n&quot;); return NULL;}Node* MatchID() { if(Token_n&gt;=(int)tokens-&gt;size())syntaxError(&quot;outofrange&quot;); int id=tokens-&gt;at(Token_n).id; if(id==ID) { Node* t =new Node(&quot;ID&quot;); Token_n++; return t; } syntaxError(&quot;match id error\n&quot;); return NULL;}Node* MatchSYM(const int expected) { if(Token_n&gt;=(int)tokens-&gt;size())syntaxError(&quot;outofrange&quot;); int id=tokens-&gt;at(Token_n).id,ptr=tokens-&gt;at(Token_n).ptr; if(id==SYM&amp;&amp;ptr==expected) { Node* t =new Node(symbol_table[ptr-100]); Token_n++; return t; } char* message=new char[100]; strcpy(message,&quot;match symbol error.\nexpect: &quot;); strcat(message,symbol_table[expected-100]); strcat(message,&quot;\n&quot;); syntaxError(message); delete message; return NULL;}bool isRES(const char* res) { if(Token_n&gt;=(int)tokens-&gt;size())syntaxError(&quot;outofrange&quot;); int id=tokens-&gt;at(Token_n).id,ptr=tokens-&gt;at(Token_n).ptr; if(id==RES&amp;&amp;strcmp(reserved_words[ptr],res)==0)return true; return false;}bool isSYM(const int res) { if(Token_n&gt;=(int)tokens-&gt;size())syntaxError(&quot;outofrange&quot;); int id=tokens-&gt;at(Token_n).id,ptr=tokens-&gt;at(Token_n).ptr; if(id==SYM&amp;&amp;ptr==res)return true; return false;}bool isID() { if(Token_n&gt;=(int)tokens-&gt;size())syntaxError(&quot;outofrange&quot;); int id=tokens-&gt;at(Token_n).id; if(id==ID)return true; return false;}bool isNUM() { if(Token_n&gt;=(int)tokens-&gt;size())syntaxError(&quot;outofrange&quot;); int id=tokens-&gt;at(Token_n).id; if(id==NUM)return true; return false;}bool isSTR() { if(Token_n&gt;=(int)tokens-&gt;size())syntaxError(&quot;outofrange&quot;); int id=tokens-&gt;at(Token_n).id; if(id==STR)return true; return false;}Node* Program() { Node* t=new Node(&quot;Program&quot;); add(t-&gt;children,ProgramHead()); add(t-&gt;children,DeclarePart()); add(t-&gt;children,ProgramBody()); return t;}Node* ProgramHead() { Node* t=new Node(&quot;ProgramHead&quot;); add(t-&gt;children,MatchRES(&quot;program&quot;)); add(t-&gt;children,MatchID()); return t;}Node* DeclarePart() { Node* t=new Node(&quot;DeclarePart&quot;); add(t-&gt;children,TypeDeclaration()); add(t-&gt;children,VarDeclaration()); add(t-&gt;children,ProcDeclaration()); return t;}Node* TypeDec() { Node* t=new Node(&quot;TypeDec&quot;); add(t-&gt;children,MatchRES(&quot;type&quot;)); add(t-&gt;children,TypeDecList()); return t;}Node* TypeDeclaration() { Node*t=NULL; if(isRES(&quot;type&quot;)) { t=new Node(&quot;TypeDeclaration&quot;); add(t-&gt;children,TypeDec()); } return t;}Node* TypeDecList() { Node* t=new Node(&quot;TypeDecList&quot;); add(t-&gt;children,TypeId()); add(t-&gt;children,MatchSYM(EQU)); add(t-&gt;children,TypeName()); add(t-&gt;children,MatchSYM(SEMI)); add(t-&gt;children,TypeDecMore()); return t;}Node* TypeDecMore() { Node*t=NULL; if(isID()) { t=new Node(&quot;TypeDecMore&quot;); add(t-&gt;children,TypeDecList()); } return t;}Node* TypeId() { Node* t=new Node(&quot;TypeId&quot;); add(t-&gt;children,MatchID()); return t;}Node* TypeName() { Node* t=new Node(&quot;TypeName&quot;); if(isRES(&quot;integer&quot;)||isRES(&quot;char&quot;)) { add(t-&gt;children,BaseType()); return t; } if(isRES(&quot;array&quot;)||isRES(&quot;record&quot;)) { add(t-&gt;children,StructureType()); return t; } add(t-&gt;children,MatchID()); return t;}Node* BaseType() { Node*t=NULL; if(isRES(&quot;integer&quot;)) { t=new Node(&quot;BaseType&quot;); add(t-&gt;children,MatchRES(&quot;integer&quot;)); return t; } if(isRES(&quot;char&quot;)) { t=new Node(&quot;BaseType&quot;); add(t-&gt;children,MatchRES(&quot;char&quot;)); return t; } syntaxError(&quot;not a base type\n&quot;); return t;}Node* StructureType() { Node*t=NULL; if(isRES(&quot;array&quot;)) { t=new Node(&quot;StructureType&quot;); add(t-&gt;children,ArrayType()); return t; } if(isRES(&quot;record&quot;)) { t=new Node(&quot;StructureType&quot;); add(t-&gt;children,RecType()); return t; } return t;}Node* ArrayType() { Node* t=new Node(&quot;ArrayType&quot;); add(t-&gt;children,MatchRES(&quot;array&quot;)); add(t-&gt;children,MatchSYM(LSQUBRACK)); add(t-&gt;children,MatchNUM()); add(t-&gt;children,MatchSYM(INDEX)); add(t-&gt;children,MatchNUM()); add(t-&gt;children,MatchSYM(RSQUBRACK)); add(t-&gt;children,MatchRES(&quot;of&quot;)); add(t-&gt;children,BaseType()); return t;}Node* RecType() { Node* t=new Node(&quot;RecType&quot;); add(t-&gt;children,MatchRES(&quot;record&quot;)); add(t-&gt;children,FieldDecList()); add(t-&gt;children,MatchRES(&quot;end&quot;)); return t;}Node* FieldDecList() { Node*t=NULL; if(isRES(&quot;integer&quot;)||isRES(&quot;char&quot;)) { t=new Node(&quot;FieldDecList&quot;); add(t-&gt;children,BaseType()); add(t-&gt;children,IdList()); add(t-&gt;children,MatchSYM(SEMI)); add(t-&gt;children,FieldDecMore()); return t; } if(isRES(&quot;array&quot;)) { t=new Node(&quot;FieldDecList&quot;); add(t-&gt;children,ArrayType()); add(t-&gt;children,IdList()); add(t-&gt;children,MatchSYM(SEMI)); add(t-&gt;children,FieldDecMore()); return t; } syntaxError(&quot;field declare list error\n&quot;); return t;}Node* FieldDecMore() { Node*t=NULL; if(isRES(&quot;integer&quot;)||isRES(&quot;char&quot;)||isRES(&quot;array&quot;)) { t=new Node(&quot;FieldDecMore&quot;); add(t-&gt;children,FieldDecList()); } return t;}Node* IdList() { Node* t=new Node(&quot;IdList&quot;); add(t-&gt;children,MatchID()); add(t-&gt;children,IdMore()); return t;}Node* IdMore() { Node*t=NULL; if(isSYM(COM)) { t=new Node(&quot;IdMore&quot;); add(t-&gt;children,MatchSYM(COM)); add(t-&gt;children,IdList()); } return t;}Node* VarDec() { Node* t=new Node(&quot;VarDec&quot;); add(t-&gt;children,MatchRES(&quot;var&quot;)); add(t-&gt;children,VarDecList()); return t;}Node* VarDeclaration() { Node*t=NULL; if(isRES(&quot;var&quot;)) { t=new Node(&quot;VarDeclaration&quot;); add(t-&gt;children,VarDec()); } return t;}Node* VarDecList() { Node* t=new Node(&quot;VarDecList&quot;); add(t-&gt;children,TypeName()); add(t-&gt;children,VarIdList()); add(t-&gt;children,MatchSYM(SEMI)); add(t-&gt;children,VarDecMore()); return t;}Node* VarDecMore() { Node*t=NULL; if(isRES(&quot;integer&quot;)||isRES(&quot;char&quot;)||isRES(&quot;array&quot;)||isRES(&quot;record&quot;)||isID()) { t=new Node(&quot;VarDecMore&quot;); add(t-&gt;children,VarDecList()); } return t;}Node* VarIdList() { Node* t=new Node(&quot;VarIdList&quot;); add(t-&gt;children,MatchID()); add(t-&gt;children,VarIdMore()); return t;}Node* VarIdMore() { Node*t=NULL; if(isSYM(COM)) { t=new Node(&quot;VarIdMore&quot;); add(t-&gt;children,MatchSYM(COM)); add(t-&gt;children,VarIdList()); } return t;}Node* ProcDec() { Node* t=new Node(&quot;ProcDec&quot;); add(t-&gt;children,MatchRES(&quot;procedure&quot;)); add(t-&gt;children,MatchID()); add(t-&gt;children,MatchSYM(LBRACK)); add(t-&gt;children,ParamList()); add(t-&gt;children,MatchSYM(RBRACK)); add(t-&gt;children,MatchSYM(SEMI)); add(t-&gt;children,DeclarePart()); add(t-&gt;children,ProcBody()); add(t-&gt;children,ProcDeclaration()); return t;}Node* ProcDeclaration() { Node*t=NULL; if(isRES(&quot;procedure&quot;)) { t=new Node(&quot;ProcDeclaration&quot;); add(t-&gt;children,ProcDec()); } return t;}Node* ParamList() { Node*t=NULL; if(isRES(&quot;integer&quot;)||isRES(&quot;char&quot;)||isRES(&quot;array&quot;)||isRES(&quot;record&quot;)||isID()||isRES(&quot;var&quot;)) { t=new Node(&quot;ParamList&quot;); add(t-&gt;children,ParamDecList()); } return t;}Node* ParamDecList() { Node* t=new Node(&quot;ParamDecList&quot;); add(t-&gt;children,Param()); add(t-&gt;children,ParamMore()); return t;}Node* ParamMore() { Node*t=NULL; if(isSYM(SEMI)) { t=new Node(&quot;ParamMore&quot;); add(t-&gt;children,MatchSYM(SEMI)); add(t-&gt;children,ParamDecList()); } return t;}Node* Param() { Node*t=NULL; if(isRES(&quot;integer&quot;)||isRES(&quot;char&quot;)||isRES(&quot;array&quot;)||isRES(&quot;record&quot;)||isID()) { t=new Node(&quot;Param&quot;); add(t-&gt;children,TypeName()); add(t-&gt;children,FormList()); return t; } if(isRES(&quot;var&quot;)) { t=new Node(&quot;Param&quot;); add(t-&gt;children,MatchRES(&quot;var&quot;)); add(t-&gt;children,TypeName()); add(t-&gt;children,FormList()); return t; } syntaxError(&quot;param error\n&quot;); return t;}Node* FormList() { Node* t=new Node(&quot;FormList&quot;); add(t-&gt;children,MatchID()); add(t-&gt;children,FidMore()); return t;}Node* FidMore() { Node*t=NULL; if(isSYM(COM)) { t=new Node(&quot;FidMore&quot;); add(t-&gt;children,MatchSYM(COM)); add(t-&gt;children,FormList()); } return t;}Node* ProcDecPart() { Node* t=new Node(&quot;ProcDecPart&quot;); add(t-&gt;children,DeclarePart()); return t;}Node* ProcBody() { Node* t=new Node(&quot;ProcBody&quot;); add(t-&gt;children,ProgramBody()); return t;}Node* ProgramBody() { Node* t=new Node(&quot;ProgramBody&quot;); add(t-&gt;children,MatchRES(&quot;begin&quot;)); add(t-&gt;children,StmList()); add(t-&gt;children,MatchRES(&quot;end&quot;)); return t;}Node* StmList() { Node* t=new Node(&quot;StmList&quot;); add(t-&gt;children,Stm()); add(t-&gt;children,StmMore()); return t;}Node* StmMore() { Node*t=NULL; if(isSYM(SEMI)) { t=new Node(&quot;StmMore&quot;); add(t-&gt;children,MatchSYM(SEMI)); add(t-&gt;children,StmList()); } return t;}Node* Stm() { Node* t=new Node(&quot;Stm&quot;); if(isRES(&quot;if&quot;)) { add(t-&gt;children,ConditionalStm()); return t; } if(isRES(&quot;while&quot;)) { add(t-&gt;children,LoopStm()); return t; } if(isRES(&quot;read&quot;)) { add(t-&gt;children,InputStm()); return t; } if(isRES(&quot;write&quot;)) { add(t-&gt;children,OutputStm()); return t; } if(isRES(&quot;return&quot;)) { add(t-&gt;children,ReturnStm()); return t; } if(isID()) { add(t-&gt;children,MatchID()); add(t-&gt;children,AssCall()); return t; } delete t; return NULL;}Node* AssCall() { Node*t=NULL; if(isSYM(LSQUBRACK)||isSYM(POINT)||isSYM(ASSI)) { t=new Node(&quot;AssCall&quot;); add(t-&gt;children,AssignmentRest()); return t; } if(isSYM(LBRACK)) { t=new Node(&quot;AssCall&quot;); add(t-&gt;children,CallStmRest()); return t; } syntaxError(&quot;ass call error\n&quot;); return t;}Node* AssignmentRest() { Node* t=new Node(&quot;AssignmentRest&quot;); if(isSYM(LSQUBRACK)||isSYM(POINT)) { add(t-&gt;children,VariMore()); } add(t-&gt;children,MatchSYM(ASSI)); add(t-&gt;children,Exp()); return t;}Node* ConditionalStm() { Node* t=new Node(&quot;ConditionalStm&quot;); add(t-&gt;children,MatchRES(&quot;if&quot;)); add(t-&gt;children,Exp()); if(isSYM(LT))add(t-&gt;children,MatchSYM(LT)); else if(isSYM(EQU))add(t-&gt;children,MatchSYM(EQU)); else syntaxError(&quot;condition error\n&quot;); add(t-&gt;children,Exp()); add(t-&gt;children,MatchRES(&quot;then&quot;)); add(t-&gt;children,StmList()); add(t-&gt;children,MatchRES(&quot;else&quot;)); add(t-&gt;children,StmList()); add(t-&gt;children,MatchRES(&quot;fi&quot;)); return t;}Node* LoopStm() { Node* t=new Node(&quot;LoopStm&quot;); add(t-&gt;children,MatchRES(&quot;while&quot;)); add(t-&gt;children,Exp()); if(isSYM(LT))add(t-&gt;children,MatchSYM(LT)); else if(isSYM(EQU))add(t-&gt;children,MatchSYM(EQU)); else syntaxError(&quot;condition error\n&quot;); add(t-&gt;children,Exp()); add(t-&gt;children,MatchRES(&quot;do&quot;)); add(t-&gt;children,StmList()); add(t-&gt;children,MatchRES(&quot;endwh&quot;)); return t;}Node* InputStm() { Node* t=new Node(&quot;InputStm&quot;); add(t-&gt;children,MatchRES(&quot;read&quot;)); add(t-&gt;children,MatchSYM(LBRACK)); add(t-&gt;children,MatchID()); add(t-&gt;children,MatchSYM(RBRACK)); return t;}Node* OutputStm() { Node* t=new Node(&quot;OutputStm&quot;); add(t-&gt;children,MatchRES(&quot;write&quot;)); add(t-&gt;children,MatchSYM(LBRACK)); add(t-&gt;children,Exp()); add(t-&gt;children,MatchSYM(RBRACK)); return t;}Node* ReturnStm() { Node* t=new Node(&quot;ReturnStm&quot;); add(t-&gt;children,MatchRES(&quot;return&quot;)); return t;}Node* CallStmRest() { Node* t=new Node(&quot;CallStmRest&quot;); add(t-&gt;children,MatchSYM(LBRACK)); add(t-&gt;children,ActParamList()); add(t-&gt;children,MatchSYM(RBRACK)); return t;}Node* ActParamList() { Node*t=NULL; if(isSYM(LBRACK)||isNUM()||isID()) { t=new Node(&quot;ActParamList&quot;); add(t-&gt;children,Exp()); add(t-&gt;children,ActParamMore()); } return t;}Node* ActParamMore() { Node*t=NULL; if(isSYM(COM)) { t=new Node(&quot;ActParamMore&quot;); add(t-&gt;children,MatchSYM(COM)); add(t-&gt;children,ActParamList()); } return t;}Node* Exp() { Node* t=new Node(&quot;Exp&quot;); add(t-&gt;children,Term()); add(t-&gt;children,OtherTerm()); return t;}Node* OtherTerm() { Node*t=NULL; if(isSYM(PLUS)||isSYM(SUB)) { t=new Node(&quot;OtherTerm&quot;); add(t-&gt;children,AddOp()); add(t-&gt;children,Exp()); } return t;}Node* Term() { Node* t=new Node(&quot;Term&quot;); add(t-&gt;children,Factor()); add(t-&gt;children,OtherFactor()); return t;}Node* OtherFactor() { Node*t=NULL; if(isSYM(MUL)||isSYM(DIV)) { t=new Node(&quot;OtherFactor&quot;); add(t-&gt;children,MultOp()); add(t-&gt;children,Term()); } return t;}Node* Factor() { Node* t=new Node(&quot;Factor&quot;); if(isNUM()) { add(t-&gt;children,MatchNUM()); return t; } if(isSTR()) { add(t-&gt;children,MatchSTR()); return t; } if(isSYM(LBRACK)) { add(t-&gt;children,MatchSYM(LBRACK)); add(t-&gt;children,Exp()); add(t-&gt;children,MatchSYM(RBRACK)); return t; } if(isID()) { add(t-&gt;children,Variable()); return t; } delete t; syntaxError(&quot;factor error\n&quot;); return NULL;}Node* Variable() { Node* t=new Node(&quot;Variable&quot;); add(t-&gt;children,MatchID()); add(t-&gt;children,VariMore()); return t;}Node* VariMore() { Node*t=NULL; if(isSYM(LSQUBRACK)) { t=new Node(&quot;VariMore&quot;); add(t-&gt;children,MatchSYM(LSQUBRACK)); add(t-&gt;children,Exp()); add(t-&gt;children,MatchSYM(RSQUBRACK)); } if(isSYM(POINT)) { t=new Node(&quot;VariMore&quot;); add(t-&gt;children,MatchSYM(POINT)); add(t-&gt;children,FieldVar()); } return t;}Node* FieldVar() { Node* t=new Node(&quot;FieldVar&quot;); add(t-&gt;children,MatchID()); add(t-&gt;children,FieldVarMore()); return t;}Node* FieldVarMore() { Node*t=NULL; if(isSYM(LSQUBRACK)) { t=new Node(&quot;FieldVarMore&quot;); add(t-&gt;children,MatchSYM(LSQUBRACK)); add(t-&gt;children,Exp()); add(t-&gt;children,MatchSYM(RSQUBRACK)); } return t;}Node* CmpOp() { Node*t=NULL; if(isSYM(LT)) { t=new Node(&quot;CmpOp&quot;); add(t-&gt;children,MatchSYM(LT)); return t; } if(isSYM(EQU)) { t=new Node(&quot;CmpOp&quot;); add(t-&gt;children,MatchSYM(EQU)); return t; } syntaxError(&quot;cmpop error\n&quot;); return t;}Node* AddOp() { Node*t=NULL; if(isSYM(PLUS)) { t=new Node(&quot;AddOp&quot;); add(t-&gt;children,MatchSYM(PLUS)); return t; } if(isSYM(SUB)) { t=new Node(&quot;AddOp&quot;); add(t-&gt;children,MatchSYM(SUB)); return t; } syntaxError(&quot;cmpop error\n&quot;); return t;}Node* MultOp() { Node*t=NULL; if(isSYM(MUL)) { t=new Node(&quot;MultOp&quot;); add(t-&gt;children,MatchSYM(MUL)); return t; } if(isSYM(DIV)) { t=new Node(&quot;MultOp&quot;); add(t-&gt;children,MatchSYM(DIV)); return t; } syntaxError(&quot;cmpop error\n&quot;); return t;}Node* Parse() { num_of_lines=1; Node* root=Program(); return root;}void show_tree(Node* root,int depth,vector&lt;int&gt;* v,bool islast) { if(root==NULL)return ; printf(&quot;\n&quot;); for(int i=0; i&lt;depth; i++) { if(v-&gt;at(i)==1)printf(&quot; &#x2502;&quot;); else printf(&quot; &quot;); } if(islast) { printf(&quot; &#x2514;&#x2500;%s&quot;,root-&gt;desc); v-&gt;at(depth)=0; } else printf(&quot; &#x251C;&#x2500;%s&quot;,root-&gt;desc); if(depth+1==(int)v-&gt;size())v-&gt;push_back(1); v-&gt;at(depth+1)=1; int len=root-&gt;children.size(); for(int i=0; i&lt;len; i++) { if(i==len-1)show_tree(root-&gt;children.at(i),depth+1,v,true); else show_tree(root-&gt;children.at(i),depth+1,v,false); }}int main() { tokens=new vector&lt;Token&gt;(); getTokenlist(&quot;cs1.txt&quot;); save_Token_list(&quot;tokens.txt&quot;); //&#x6253;&#x5370;&#x663E;&#x793A; printf(&quot;TOKENS:\n\n&quot;); show_Token_list(); printf(&quot;\n\n\n\n&#x8BED;&#x6CD5;&#x6811;:\n\n&quot;); vector&lt;int&gt;* v=new vector&lt;int&gt;(); v-&gt;push_back(0); show_tree(Parse(),0,v,true); return 0;} cs1.txt123456789101112131415161718192021222324252627282930313233343536373839404142434445{&#x5192;&#x6CE1;&#x6392;&#x5E8F;}{&#x8F93;&#x5165;m,&#x8868;&#x793A;&#x8981;&#x6392;&#x5E8F;&#x7684;&#x6570;&#x7684;&#x4E2A;&#x6570;&#xFF1B;&#x63A5;&#x7740;&#x8F93;&#x5165;m&#x4E2A;&#x6574;&#x6570;&#xFF1B; &#x8F93;&#x51FA;&#x4ECE;&#x5C0F;&#x5230;&#x5927;&#x6392;&#x5E8F;&#x540E;&#x7684;&#x7ED3;&#x679C;}program pvar integer i,j,num; array[1..20] of integer a;procedure q(integer num);var integer i,j,k; integer t;begin i:=&apos;lklklk&apos;; j:=1; while i &lt; num do j:=num-i+1; k:=1; while k&lt;j do if a[k+1] &lt; a[k] then t:=a[k]; a[k]:=a[k+1]; a[k+1]:=t else t:=0 fi; k:=k+1 endwh; i:=i+1 endwhendbegin read(num); i:=1; while i&lt;(num+1) do read(j); a[i]:=j; i:=i+1 endwh; q(num); i:=1; while i&lt;(num+1) do write(a[i]); i:=i+1 endwhend. &#x4EE3;&#x7801;&#x5199;&#x4E8E;&#x5927;&#x4E09;&#x4E0B;6&#x6708;&#x4EFD;&#xFF0C;&#x7F16;&#x8BD1;&#x539F;&#x7406;&#x8BFE;&#x7A0B;&#x8BBE;&#x8BA1; &#x968F;&#x7B14;&#x5199;&#x4E8E;2016.7.13]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[聊天室（Java实现）]]></title>
      <url>2016%2F07%2F03%2FChatRoom%2F</url>
      <content type="text"><![CDATA[&#x2002;&#x2002;&#x2002; &#x529F;&#x80FD;&#xFF1A;&#x767B;&#x5F55;&#x3000;&#x3000;&#x3000;&#x3000;&#x82E5;&#x7528;&#x6237;&#x8D26;&#x53F7;&#x4E0D;&#x5B58;&#x5728;&#xFF0C;&#x5F39;&#x51FA;&#x9519;&#x8BEF; &#x3000;&#x3000;&#x3000;&#x3000;&#x82E5;&#x7528;&#x6237;&#x5BC6;&#x7801;&#x9519;&#x8BEF;&#xFF0C;&#x5F39;&#x51FA;&#x9519;&#x8BEF; &#x3000;&#x3000;&#x3000;&#x3000;&#x82E5;&#x7528;&#x6237;&#x8D26;&#x53F7;&#x5DF2;&#x5728;&#x7EBF;&#xFF0C;&#x5F39;&#x51FA;&#x9519;&#x8BEF; &#x3000;&#x3000;&#x3000;&#x3000;&#x3000; &#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000; &#x6CE8;&#x518C;&#x3000;&#x3000;&#x3000;&#x3000;&#x82E5;&#x7528;&#x6237;&#x5DF2;&#x6CE8;&#x518C;&#xFF0C;&#x5F39;&#x51FA;&#x9519;&#x8BEF; &#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000; &#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000; &#x804A;&#x5929;&#x5BA4;&#x3000;&#x3000;&#x3000;&#x3000;&#x591A;&#x4EBA;&#x804A;&#x5929;&#xFF0C;&#x7C7B;&#x4F3C;QQ&#x91CC;&#x7684;&#x7FA4;&#x3002; &#x3000;&#x3000;&#x3000;&#x3000;&#x70B9;&#x51FB;&#x53F3;&#x4FA7;&#x7684;&#x5728;&#x7EBF;&#x7528;&#x6237;&#xFF0C;&#x53EF;&#x8FDB;&#x884C;&#x4E00;&#x5BF9;&#x4E00;&#x804A;&#x5929;&#x3002; &#x4E00;&#x5BF9;&#x4E00;&#x804A;&#x5929;&#x3000;&#x3000;&#x3000;&#x3000;&#x5728;&#x804A;&#x5929;&#x5BA4;&#x4E2D;&#x70B9;&#x51FB;&#x5728;&#x7EBF;&#x7528;&#x6237;&#x53EF;&#x8FDB;&#x5165;&#x6B64;&#x7A97;&#x53E3;&#x3002; &#x3000;&#x3000;&#x3000;&#x3000;&#x53D1;&#x9001;&#x6D88;&#x606F;&#x540E;&#xFF0C;&#x5BF9;&#x65B9;&#x4F1A;&#x6536;&#x5230;&#x6D88;&#x606F;&#xFF0C;&#x5E76;&#x5F39;&#x51FA;&#x4E00;&#x5BF9;&#x4E00;&#x804A;&#x5929;&#x7A97;&#x53E3; &#x3002;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000; &#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000; &#x2002;&#x2002;&#x2002;&#x2002; &#x8BF4;&#x660E;&#xFF1A;&#x3000;&#x3000;&#x3000;&#x3000;&#x670D;&#x52A1;&#x7AEF;&#x7684;IP&#x548C;&#x7AEF;&#x53E3;&#x56FA;&#x5B9A;&#x3002;&#xFF08;&#x4EE3;&#x7801;&#x4E2D;&#x4F7F;&#x7528;127.0.0.1&#x4F5C;&#x4E3A;&#x670D;&#x52A1;&#x7AEF;&#x7684;IP&#xFF09; &#x3000;&#x3000;&#x3000;&#x3000;&#x5BA2;&#x6237;&#x7AEF;&#x901A;&#x8FC7;&#x8BE5;IP&#x548C;&#x7AEF;&#x53E3;&#x8BBF;&#x95EE;&#x670D;&#x52A1;&#x5668;&#x3002; &#x3000;&#x3000;&#x3000;&#x3000;&#x5BA2;&#x6237;&#x7AEF;&#x5411;&#x670D;&#x52A1;&#x5668;&#x53D1;&#x9001;&#x6D88;&#x606F;&#xFF0C;&#x670D;&#x52A1;&#x5668;&#x6839;&#x636E;&#x6D88;&#x606F;&#x505A;&#x51FA;&#x4E0D;&#x540C;&#x7684;&#x5904;&#x7406;&#xFF0C;&#x5E76;&#x53EF;&#x80FD;&#x5411;&#x5176;&#x4ED6;&#x5BA2;&#x6237;&#x7AEF;&#x53D1;&#x9001;&#x6D88;&#x606F;&#x3002; &#x3000;&#x3000;&#x3000;&#x3000;&#x6BCF;&#x4E2A;&#x5BA2;&#x6237;&#x7AEF;&#x90FD;&#x6709;&#x4E00;&#x4E2A;&#x5BA2;&#x6237;&#x7AEF;server&#x8FDB;&#x7A0B;&#xFF0C;&#x4EE5;&#x63A5;&#x6536;&#x670D;&#x52A1;&#x7AEF;&#x53D1;&#x6765;&#x7684;&#x6D88;&#x606F;&#x3002; &#x3000;&#x3000;&#x3000;&#x3000;&#x521D;&#x59CB;&#x5316;&#x5BA2;&#x6237;&#x7AEF;&#x65F6;&#xFF0C;&#x542F;&#x52A8;&#x5BA2;&#x6237;&#x7AEF;server&#x8FDB;&#x7A0B;&#xFF0C;&#x76D1;&#x542C;&#x4EFB;&#x610F;&#x4E00;&#x4E2A;&#x53EF;&#x7528;&#x7AEF;&#x53E3;&#x3002;&#x7528;&#x6237;&#x767B;&#x5F55;&#x65F6;&#xFF0C;&#x5C06;&#x672C;&#x5730;&#x8D26;&#x6237;&#x3001;&#x5BC6;&#x7801;&#x3001;&#x672C;&#x5730;&#x7684;server&#x8FDB;&#x7A0B;&#x7AEF;&#x53E3;&#x53D1;&#x7ED9;&#x670D;&#x52A1;&#x7AEF;&#xFF0C;&#x670D;&#x52A1;&#x7AEF;&#x68C0;&#x9A8C;&#x7528;&#x6237;&#x5408;&#x6CD5;&#x6027;&#xFF0C;&#x82E5;&#x5408;&#x3000;&#x6CD5;&#xFF0C;&#x5219;&#x66F4;&#x65B0;&#x8BE5;&#x8D26;&#x6237;&#x7684;IP&#x5730;&#x5740;&#x548C;&#x7AEF;&#x53E3;&#x3002;&#x4EE5;&#x540E;&#x670D;&#x52A1;&#x7AEF;&#x5373;&#x53EF;&#x5411;&#x8BE5;IP&#x53D1;&#x9001;&#x6D88;&#x606F;&#x3002; &#x2002;&#x2002;&#x2002;&#x2002; &#x4EE3;&#x7801;&#xFF1A; &#x3000;&#x3000;&#x9879;&#x76EE;&#x5DE5;&#x7A0B;&#x7ED3;&#x6784;&#xFF1A; &#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000; Server1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package chatroomutil;import java.io.BufferedReader;import java.io.IOException;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;public abstract class Server { protected ServerSocket sSocket; public Server() { } protected int listen() { while (true) { Socket ots = null; try { ots = sSocket.accept(); } catch (IOException e) { ChatRoomUtil.showErrorBox(&quot;&#x670D;&#x52A1;&#x5668;Accept&#x9519;&#x8BEF;&quot;); System.exit(-1); } Thread hThread = new Thread(new handleThread(ots)); hThread.start(); } } // &#x5904;&#x7406;&#x6D88;&#x606F;&#x7684;&#x8FDB;&#x7A0B; &#x7684;&#x5185;&#x90E8;&#x7C7B; class handleThread implements Runnable { Socket ots; handleThread(Socket ots) { this.ots = ots; } @Override public void run() { handleMessage(ots); } }; protected abstract String handle(Socket ots,String rMessage);//&#x5904;&#x7406;&#x51FD;&#x6570;&#xFF0C;&#x8F93;&#x5165;&#x6536;&#x5230;&#x7684;&#x6D88;&#x606F;&#xFF0C;&#x8FD4;&#x56DE;&#x8981;&#x53D1;&#x9001;&#x7684;&#x6D88;&#x606F; private String handleMessage(Socket ots) { StringBuffer buffer=new StringBuffer(); BufferedReader reader=ChatRoomUtil.getMsgFromSocket(ots,buffer);//&#x83B7;&#x53D6;&#x6D88;&#x606F; String rMessage = buffer.toString(); String message=handle(ots,rMessage);//&#x5904;&#x7406;&#x6D88;&#x606F; PrintWriter writer=ChatRoomUtil.putMesgToSocket(ots, message);//&#x53D1;&#x9001;&#x6D88;&#x606F; ChatRoomUtil.closeSocket(ots,reader,writer);//&#x5173;&#x95ED; return null; }} ChatRoomUtil123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package chatroomutil;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;import javax.swing.JOptionPane;public class ChatRoomUtil { public static String showErrorBox(String message) {//&#x663E;&#x793A;&#x9519;&#x8BEF;&#x4FE1;&#x606F;&#x5BF9;&#x8BDD;&#x6846; JOptionPane.showMessageDialog(null, message, &quot;&#x9519;&#x8BEF;&quot;, JOptionPane.ERROR_MESSAGE); return message; } //&#x83B7;&#x53D6;&#x6D88;&#x606F; public static BufferedReader getMsgFromSocket(Socket socket,StringBuffer buffer){ BufferedReader reader = null; try { reader = new BufferedReader( new InputStreamReader(socket.getInputStream())); } catch (IOException e) { ChatRoomUtil.showErrorBox(&quot;&#x83B7;&#x53D6;Socket&#x8F93;&#x5165;&#x6D41;&#x9519;&#x8BEF;&quot;); System.exit(-1); } try { String line = &quot;&quot;; while ((line = reader.readLine()) != null) { buffer.append(line + &quot;\n&quot;); } buffer.deleteCharAt(buffer.length()-1);//&#x53BB;&#x6389;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x56DE;&#x8F66;&#x7B26; } catch (IOException e) { ChatRoomUtil.showErrorBox(&quot;&#x8BFB;&#x53D6;Socket&#x8F93;&#x5165;&#x6D41;&#x9519;&#x8BEF;&quot;); System.exit(-1); } try { socket.shutdownInput(); } catch (IOException e) { ChatRoomUtil.showErrorBox(&quot;&#x5173;&#x95ED;Socket&#x8F93;&#x5165;&#x65F6;&#x53D1;&#x751F;&#x9519;&#x8BEF;&quot;); System.exit(-1); } return reader; } //&#x53D1;&#x9001;&#x6D88;&#x606F; public static PrintWriter putMesgToSocket(Socket socket,String message){ PrintWriter writer = null; try { writer = new PrintWriter(socket.getOutputStream()); } catch (IOException e) { ChatRoomUtil.showErrorBox(&quot;&#x83B7;&#x53D6;Socket&#x8F93;&#x51FA;&#x6D41;&#x9519;&#x8BEF;&quot;); System.exit(-1); } writer.println(message); writer.flush(); try { socket.shutdownOutput(); } catch (IOException e1) { ChatRoomUtil.showErrorBox(&quot;&#x5173;&#x95ED;Socket&#x8F93;&#x51FA;&#x65F6;&#x53D1;&#x751F;&#x9519;&#x8BEF;&quot;); System.exit(-1); } return writer; } //&#x5173;&#x95ED;socket&#x3001;&#x8F93;&#x5165;&#x6D41;&#x3001;&#x8F93;&#x51FA;&#x6D41; public static void closeSocket(Socket socket,BufferedReader reader,PrintWriter writer ){ try { reader.close(); } catch (IOException e) { ChatRoomUtil.showErrorBox(&quot;&#x5173;&#x95ED;Scoket&#x8F93;&#x5165;&#x6D41;&#x65F6;&#x53D1;&#x751F;&#x9519;&#x8BEF;&quot;); System.exit(-1); } writer.close(); try { socket.close(); } catch (IOException e) { ChatRoomUtil.showErrorBox(&quot;&#x5173;&#x95ED;Scoket&#x8F93;&#x51FA;&#x6D41;&#x65F6;&#x53D1;&#x751F;&#x9519;&#x8BEF;&quot;); System.exit(-1); } }} ServerServer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238package chatroomserver;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.io.RandomAccessFile;import java.net.ServerSocket;import java.net.Socket;import java.util.Enumeration;import java.util.Hashtable;import chatroomsend.Send;import chatroomutil.ChatRoomUtil;import chatroomutil.Server;public class ServerServer extends Server { Hashtable&lt;String, User&gt; onlineTable = new Hashtable&lt;String, User&gt;();// &#x5728;&#x7EBF;&#x7528;&#x6237;&#x96C6;&#x5408; Hashtable&lt;String, User&gt; offlineTable = new Hashtable&lt;String, User&gt;();// &#x79BB;&#x7EBF;&#x7528;&#x6237;&#x96C6;&#x5408; // &#x7528;&#x6237;&#x5185;&#x90E8;&#x7C7B; class User { String id; String pwd; String IP; int port; User(String id, String pwd) { this.id = id; this.pwd = pwd; } } // &#x53D1;&#x9001;&#x8FDB;&#x7A0B;&#x5185;&#x90E8;&#x7C7B; class sendThread implements Runnable { String mesg; String IP; int port; sendThread(String IP, int port, String mesg) { this.IP = IP; this.port = port; this.mesg = mesg; } @Override public void run() { Send sendClient = new Send(); sendClient.connect(IP, port, 1000); sendClient.send(mesg); } }; public ServerServer(int port) throws IOException { init(port); initUsers(); listen(); } private int init(int port) throws IOException { try { sSocket = new ServerSocket(port);//&#x7ED1;&#x5B9A;&#x6307;&#x5B9A;&#x7AEF;&#x53E3; } catch (IOException e) { ChatRoomUtil.showErrorBox(&quot;&#x670D;&#x52A1;&#x5668;&#x521D;&#x59CB;&#x5316;&#x5931;&#x8D25;&#xFF0C;&#x65E0;&#x6CD5;&#x7ED1;&#x5B9A;&#x7AEF;&#x53E3;&#x3002;&quot;); System.exit(-1); } return port; } private int initUsers() {//&#x8BFB;&#x53D6;Users&#x6587;&#x4EF6;&#xFF0C;&#x521D;&#x59CB;&#x5316;offlineTable BufferedReader reader = null; try { reader = new BufferedReader(new FileReader(&quot;Users.txt&quot;)); } catch (FileNotFoundException e1) { ChatRoomUtil.showErrorBox(&quot;&#x65E0;&#x6CD5;&#x627E;&#x5230;User&#x6587;&#x4EF6;&quot;); System.exit(-1); } String line; String[] fa; try { while ((line = reader.readLine()) != null) { fa = line.split(&quot;:&quot;, 2); User f = new User(fa[0], fa[1]); offlineTable.put(fa[0], f); } reader.close(); } catch (IOException e) { ChatRoomUtil.showErrorBox(&quot;&#x8BFB;&#x53D6;User&#x6587;&#x4EF6;&#x9519;&#x8BEF;&quot;); System.exit(-1); } return 0; } private int saveNewUser(String id, String pwd) {//&#x5C06;&#x65B0;&#x7528;&#x6237;&#x5199;&#x5165;Users&#x6587;&#x4EF6;&#x6700;&#x540E; try { RandomAccessFile file = new RandomAccessFile(&quot;Users.txt&quot;, &quot;rw&quot;); file.seek(file.length()); file.writeBytes(id + &quot;:&quot; + pwd + &quot;\r\n&quot;); file.close(); } catch (FileNotFoundException e) { ChatRoomUtil.showErrorBox(&quot;&#x5199;&#x5165;User&#x6587;&#x4EF6;&#x9519;&#x8BEF;&quot;); System.exit(-1); } catch (IOException e) { ChatRoomUtil.showErrorBox(&quot;&#x5199;&#x5165;User&#x6587;&#x4EF6;&#x9519;&#x8BEF;&quot;); System.exit(-1); } return 0; } String loginCheck(String id, String pwd, String IP, int port) {//&#x68C0;&#x67E5;&#x767B;&#x5F55;&#x7528;&#x6237;&#x7684;&#x5408;&#x6CD5;&#x6027; System.out.println(&quot;logi check&quot;); if (onlineTable.containsKey(id)) return &quot;alreadyonline&quot;;//&#x8BE5;&#x7528;&#x6237;&#x5DF2;&#x5728;&#x7EBF; User f = offlineTable.get(id); if (f == null) return &quot;nothisid&quot;;//&#x65E0;&#x6B64;&#x7528;&#x6237; if (f.pwd.compareTo(pwd) == 0) { oneUserOnline(id, IP, port); sendOnlinesToNewOnlineUser(id, IP, port); sendNewOnlineUserToOnlines(id); return &quot;yes&quot;;//&#x5408;&#x6CD5; } else { return &quot;wrong&quot;;//&#x5BC6;&#x7801;&#x9519;&#x8BEF; } } int oneUserOnline(String id, String IP, int port) {//&#x4E00;&#x4E2A;&#x65B0;&#x7528;&#x6237;&#x4E0A;&#x7EBF; User f = offlineTable.get(id); offlineTable.remove(id); onlineTable.put(id, f); f.IP = IP; f.port = port; return 0; } int sendNewOnlineUserToOnlines(String id) {//&#x7ED9;&#x6240;&#x6709;&#x5728;&#x7EBF;&#x7528;&#x6237;&#x53D1;&#x9001;&#x65B0;&#x4E0A;&#x7EBF;&#x7684;&#x7528;&#x6237;&#x7684;id Enumeration&lt;User&gt; fs = onlineTable.elements(); while (fs.hasMoreElements()) { User f = fs.nextElement(); if (f.id.compareTo(id) != 0) { Thread hThread = new Thread( new sendThread(f.IP, f.port, &quot;newf&quot; + id)); hThread.start(); } } return 0; } int sendMesg(String mesg) {//&#x5411;&#x6240;&#x6709;&#x5728;&#x7EBF;&#x7528;&#x6237;&#x8F6C;&#x53D1;&#x4E00;&#x6761;&#x6D88;&#x606F; Enumeration&lt;User&gt; fs = onlineTable.elements(); while (fs.hasMoreElements()) { User f = fs.nextElement(); Thread hThread = new Thread( new sendThread(f.IP, f.port, &quot;mesg&quot; + mesg)); hThread.start(); } return 0; } int sendChat(String id, String mesg) {//&#x5411;&#x4E00;&#x4E2A;&#x7528;&#x6237;&#x53D1;&#x9001;&#x4E00;&#x6761;&#x4E00;&#x5BF9;&#x4E00;&#x804A;&#x5929;&#x7684;&#x6D88;&#x606F; User f = onlineTable.get(id); Thread hThread = new Thread( new sendThread(f.IP, f.port, &quot;chat&quot; + mesg)); hThread.start(); return 0; } String newRegisUser(String id, String pwd) {//&#x6709;&#x65B0;&#x6CE8;&#x518C;&#x7684;&#x7528;&#x6237; if (onlineTable.containsKey(id) || offlineTable.containsKey(id)) { return &quot;no&quot;; } offlineTable.put(id, new User(id, pwd)); saveNewUser(id, pwd); return &quot;yes&quot;; } int sendOnlinesToNewOnlineUser(String id, String IP, int port) {//&#x7ED9;&#x65B0;&#x4E0A;&#x7EBF;&#x7684;&#x7528;&#x6237;&#x53D1;&#x9001;&#x6240;&#x6709;&#x5DF2;&#x5728;&#x7EBF;&#x7528;&#x6237;&#x7684;id if (onlineTable.isEmpty() || onlineTable.size() == 1) { return 0; } StringBuffer strBuf = new StringBuffer(); Enumeration&lt;User&gt; fs = onlineTable.elements(); while (fs.hasMoreElements()) { User f = fs.nextElement(); if (f.id.compareTo(id) != 0) { strBuf.append(f.id); strBuf.append(&quot;;&quot;); } } String str = strBuf.toString(); Thread hThread = new Thread(new sendThread(IP, port, &quot;newf&quot; + str)); hThread.start(); return 0; } int oneUserOffline(String id) {//&#x6709;&#x4E00;&#x4E2A;&#x7528;&#x6237;&#x4E0B;&#x7EBF;&#xFF0C;&#x5C06;&#x5176;&#x4E0B;&#x7EBF;&#x6D88;&#x606F;&#x53D1;&#x9001;&#x7ED9;&#x6240;&#x6709;&#x5728;&#x7EBF;&#x7528;&#x6237; Enumeration&lt;User&gt; fs = onlineTable.elements(); while (fs.hasMoreElements()) { User f = fs.nextElement(); if (f.id.compareTo(id) == 0) { onlineTable.remove(id); offlineTable.put(id, f); } else { Thread hThread = new Thread( new sendThread(f.IP, f.port, &quot;offl&quot; + id)); hThread.start(); } } return 0; } protected String handle(Socket ots,String rMessage){ System.out.println(&quot;handle&quot;); if (rMessage.startsWith(&quot;regi&quot;)) {//&#x6CE8;&#x518C; rMessage = rMessage.substring(&quot;regi&quot;.length()); String id = rMessage.substring(0, rMessage.indexOf(&apos;,&apos;)); String pwd = rMessage.substring(rMessage.indexOf(&apos;,&apos;) + 1); return newRegisUser(id, pwd); } if (rMessage.startsWith(&quot;logi&quot;)) {//&#x767B;&#x5F55; System.out.println(&quot;logi&quot;); rMessage = rMessage.substring(&quot;logi&quot;.length()); String id = rMessage.substring(0, rMessage.indexOf(&apos;,&apos;)); String pwd = rMessage.substring(rMessage.indexOf(&apos;,&apos;) + 1, rMessage.lastIndexOf(&apos;,&apos;)); String portstr = rMessage.substring(rMessage.lastIndexOf(&apos;,&apos;) + 1); int port = new Integer(portstr); String IP = ots.getInetAddress().getHostAddress(); return loginCheck(id, pwd, IP, port); } if (rMessage.startsWith(&quot;mesg&quot;)) {//&#x804A;&#x5929;&#x5BA4;&#x6D88;&#x606F; String mesg = rMessage.substring((&quot;mesg&quot;).length()); sendMesg(mesg); return &quot;getm&quot;; } if (rMessage.startsWith(&quot;chat&quot;)) {//&#x4E00;&#x5BF9;&#x4E00;&#x6D88;&#x606F; String chat = rMessage.substring((&quot;chat&quot;).length()); String id = chat.substring(0, chat.indexOf(&apos;:&apos;)); String mesg = chat.substring(chat.indexOf(&apos;:&apos;) + 1); sendChat(id, mesg); return &quot;getm&quot;; } if (rMessage.startsWith(&quot;offl&quot;)) {//&#x4E0B;&#x7EBF; String id = rMessage.substring((&quot;offl&quot;).length()); oneUserOffline(id); return &quot;getm&quot;; } return &quot;getm&quot;; } public static void main(String[] args) { try { new ServerServer(65142); } catch (IOException e) { e.printStackTrace(); } }} Send12345678910111213141516171819202122232425262728293031package chatroomsend;import java.io.BufferedReader;import java.io.IOException;import java.io.PrintWriter;import java.net.InetSocketAddress;import java.net.Socket;import chatroomutil.ChatRoomUtil;public class Send { Socket socket; public Send() { super(); socket = new Socket(); } public int connect(String IP, int port, int timeout) {//&#x8FDE;&#x63A5; try { socket.connect(new InetSocketAddress(IP, port), timeout); } catch (IOException e) { return -1; } return 0; } public String send(String message) { PrintWriter writer=ChatRoomUtil.putMesgToSocket(socket, message); StringBuffer buffer=new StringBuffer(); BufferedReader reader=ChatRoomUtil.getMsgFromSocket(socket,buffer); String rMessage = buffer.toString(); ChatRoomUtil.closeSocket(socket,reader,writer); return rMessage; }} LoginBox123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174package chatroomclient;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.io.IOException;import javax.swing.*;import chatroomsend.Send;import chatroomutil.ChatRoomUtil;public class LoginBox extends JFrame implements ActionListener, MouseListener { private static final long serialVersionUID = -329711894663212488L; ClientServer myServer; String serverIP; int serverPort; JLabel l_account = new JLabel(); JLabel l_password = new JLabel(); JLabel l_regist = new JLabel(); JTextField j_account = new JTextField(); JPasswordField j_password = new JPasswordField(); JButton submit = new JButton(); JButton cancel = new JButton(); JLabel clearAccount = new JLabel(); JLabel clearPassword = new JLabel(); public LoginBox(String ip, int port) { super(&quot;&#x767B;&#x5F55;&quot;); try { myServer = new ClientServer(serverIP, serverPort); Thread myServerThread = new Thread(myServer); myServerThread.start(); } catch (IOException e) { ChatRoomUtil.showErrorBox(&quot;&#x670D;&#x52A1;&#x5668;&#x8FDB;&#x7A0B;&#x521D;&#x59CB;&#x5316;&#x5931;&#x8D25;&#xFF0C;&#x65E0;&#x6CD5;&#x7ED1;&#x5B9A;&#x7AEF;&#x53E3;&#x3002;&quot;); System.exit(-1); } serverIP = ip; serverPort = port; setLayout(null); l_account.setVisible(true); l_account.setBounds(80, 40, 50, 30); l_account.setText(&quot;&#x8D26;&#x53F7;:&quot;); l_password.setVisible(true); l_password.setBounds(80, 80, 50, 30); l_password.setText(&quot;&#x5BC6;&#x7801;:&quot;); j_account.setBounds(130, 40, 150, 30); j_password.setBounds(130, 80, 150, 30); clearAccount.setBounds(280, 42, 26, 26); clearPassword.setBounds(280, 82, 26, 26); submit.setBounds(100, 130, 80, 30); submit.setText(&quot;&#x767B;&#x5F55;&quot;); cancel.setText(&quot;&#x53D6;&#x6D88;&quot;); clearAccount.setText(&quot;X&quot;); clearPassword.setText(&quot;X&quot;); clearAccount.setOpaque(true); clearPassword.setOpaque(true); clearAccount.setBackground(Color.LIGHT_GRAY); clearPassword.setBackground(Color.LIGHT_GRAY); clearAccount.setHorizontalAlignment(JLabel.CENTER); clearPassword.setHorizontalAlignment(JLabel.CENTER); submit.setBackground(Color.LIGHT_GRAY); cancel.setBackground(Color.LIGHT_GRAY); submit.addActionListener(this); cancel.addActionListener(this); cancel.setBounds(190, 130, 80, 30); l_regist.setBounds(270, 200, 70, 30); l_regist.setText(&quot;&#x6CA1;&#x6709;&#x8D26;&#x53F7;?&quot;); this.add(l_account); this.add(l_password); this.add(j_account); this.add(j_password); this.add(submit); this.add(cancel); this.add(l_regist); this.add(clearAccount); this.add(clearPassword); setBounds(480, 240, 370, 270); setVisible(true); setResizable(false); this.setDefaultCloseOperation(EXIT_ON_CLOSE); validate(); l_regist.addMouseListener(this); clearAccount.addMouseListener(this); clearPassword.addMouseListener(this); } String checkPwd(String id, String pwd) { Send sendClient = new Send(); sendClient.connect(serverIP, serverPort, 1000); String ret= sendClient .send(&quot;logi&quot; + id + &quot;,&quot; + pwd + &quot;,&quot; + myServer.getMyServerPort()); if (ret.compareTo(&quot;yes&quot;) == 0) { myServer.chatRoom = new ChatRoom(id, serverIP, serverPort); dispose(); } else if (ret.compareTo(&quot;wrong&quot;) == 0) { ChatRoomUtil.showErrorBox(&quot;&#x767B;&#x5F55;&#x5931;&#x8D25;&#xFF0C;&#x5BC6;&#x7801;&#x6709;&#x8BEF;&#x3002;&quot;); } else if (ret.compareTo(&quot;alreadyonline&quot;) == 0) { ChatRoomUtil.showErrorBox(&quot;&#x767B;&#x5F55;&#x5931;&#x8D25;&#xFF0C;&#x8BE5;&#x8D26;&#x53F7;&#x5DF2;&#x5728;&#x7EBF;&quot;); } else if (ret.compareTo(&quot;nothisid&quot;) == 0) { ChatRoomUtil.showErrorBox(&quot;&#x767B;&#x5F55;&#x5931;&#x8D25;&#xFF0C;&#x8D26;&#x53F7;&#x4E0D;&#x5B58;&#x5728;&#x3002;&quot;); new RegisBox(serverIP, serverPort, myServer.getMyServerPort()); } return ret; } @Override public void actionPerformed(ActionEvent e) { Object t = e.getSource(); if (e.getSource().getClass() == JButton.class) { JButton button = (JButton) (t); if (button.getText().compareTo(&quot;&#x767B;&#x5F55;&quot;) == 0) { String id = j_account.getText(); String pwd = String.valueOf(j_password.getPassword()); if (id.compareTo(&quot;&quot;) == 0 || pwd.compareTo(&quot;&quot;) == 0) { ChatRoomUtil.showErrorBox(&quot;&#x8D26;&#x53F7;&#x4E0E;&#x5BC6;&#x7801;&#x5747;&#x4E0D;&#x80FD;&#x4E3A;&#x7A7A;&quot;); return; } checkPwd(id, pwd); } if (button.getText().compareTo(&quot;&#x53D6;&#x6D88;&quot;) == 0) { dispose(); System.exit(0); } } } @Override public void mouseClicked(MouseEvent e) { if (e.getSource().equals(l_regist)) { new RegisBox(serverIP, serverPort, myServer.getMyServerPort()); } if (e.getSource().equals(clearAccount)) { j_account.setText(&quot;&quot;); } if (e.getSource().equals(clearPassword)) { j_password.setText(&quot;&quot;); } } @Override public void mousePressed(MouseEvent e) { } @Override public void mouseReleased(MouseEvent e) { } @Override public void mouseEntered(MouseEvent e) { Object x = e.getSource(); if (x.equals(l_regist)) { JLabel l = (JLabel) x; l.setForeground(Color.blue); } if (x.equals(clearAccount) || x.equals(clearPassword)) { JLabel l = (JLabel) x; l.setBackground(Color.GRAY); } } @Override public void mouseExited(MouseEvent e) { Object x = e.getSource(); if (x.equals(l_regist)) { JLabel l = (JLabel) x; l.setForeground(Color.BLACK); } if (x.equals(clearAccount) || x.equals(clearPassword)) { JLabel l = (JLabel) x; l.setBackground(Color.LIGHT_GRAY); } } public static void main(String[] args) { String serverIP = &quot;127.0.0.1&quot;; int serverPort = 65142; new LoginBox(serverIP, serverPort); }} RegisBox123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171package chatroomclient;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.*;import chatroomsend.Send;import chatroomutil.ChatRoomUtil;public class RegisBox extends JFrame implements ActionListener { private static final long serialVersionUID = 5795626909275119718L; String serverIP; int serverPort; int myServerPort; JLabel id_label = new JLabel(); JLabel pwd_label = new JLabel(); JLabel pwdCheck_label = new JLabel(); JLabel num_label = new JLabel(); JLabel firstName_label = new JLabel(); JLabel lastName_label = new JLabel(); JLabel age_label = new JLabel(); JLabel sex_label = new JLabel(); JTextField id_text = new JTextField(); JPasswordField pwd_text = new JPasswordField(); JPasswordField pwdCheck_text = new JPasswordField(); JTextField num_text = new JTextField(); JTextField firstName_text = new JTextField(); JTextField lastName_text = new JTextField(); JTextField age_text = new JTextField(); JComboBox sex_box = new JComboBox(); JButton cancel = new JButton(); JButton regis = new JButton(); public RegisBox(String serverIP, int serverPort, int myServerPort) { super(); this.serverIP = serverIP; this.serverPort = serverPort; this.myServerPort = myServerPort; setLayout(null); setTitle(&quot;&#x6CE8;&#x518C;&quot;); id_label.setBounds(60, 23, 50, 20); pwd_label.setBounds(60, 53, 50, 20); pwdCheck_label.setBounds(50, 83, 70, 20); num_label.setBounds(60, 113, 50, 20); firstName_label.setBounds(60, 143, 50, 20); lastName_label.setBounds(60, 173, 50, 20); age_label.setBounds(60, 203, 50, 20); sex_label.setBounds(60, 233, 50, 20); id_text.setBounds(130, 20, 200, 26); pwd_text.setBounds(130, 50, 200, 26); pwdCheck_text.setBounds(130, 80, 200, 26); num_text.setBounds(130, 110, 200, 26); firstName_text.setBounds(130, 140, 200, 26); lastName_text.setBounds(130, 170, 200, 26); age_text.setBounds(130, 200, 200, 26); sex_box.setBounds(130, 230, 200, 26); regis.setBounds(190, 270, 70, 30); cancel.setBounds(270, 270, 70, 30); id_label.setText(&quot;&#x8D26;&#x53F7;&quot;); pwd_label.setText(&quot;&#x5BC6;&#x7801;&quot;); pwdCheck_label.setText(&quot;&#x5BC6;&#x7801;&#x786E;&#x8BA4;&quot;); num_label.setText(&quot;&#x7F16;&#x53F7;&quot;); firstName_label.setText(&quot;&#x540D;&quot;); lastName_label.setText(&quot;&#x59D3;&quot;); age_label.setText(&quot;&#x5E74;&#x9F84;&quot;); sex_label.setText(&quot;&#x6027;&#x522B;&quot;); sex_box.addItem(&quot;&#x7537;&quot;); sex_box.addItem(&quot;&#x5973;&quot;); regis.setText(&quot;&#x63D0;&#x4EA4;&quot;); cancel.setText(&quot;&#x53D6;&#x6D88;&quot;); regis.setBackground(Color.LIGHT_GRAY); cancel.setBackground(Color.LIGHT_GRAY); sex_box.setBackground(Color.LIGHT_GRAY); regis.addActionListener(this); cancel.addActionListener(this); this.add(id_label); this.add(pwd_label); this.add(pwdCheck_label); this.add(num_label); this.add(firstName_label); this.add(lastName_label); this.add(age_label); this.add(sex_label); this.add(id_text); this.add(pwd_text); this.add(pwdCheck_text); this.add(num_text); this.add(firstName_text); this.add(lastName_text); this.add(age_text); this.add(sex_box); this.add(regis); this.add(cancel); setBounds(200, 200, 500, 400); validate(); setResizable(false); setVisible(true); } boolean regis(String serverIP, int serverPort, String id, String pwd, int myServerPort) { Send sendClient = new Send(); sendClient.connect(serverIP, serverPort, 1000); if (sendClient.send(&quot;regi&quot; + id + &quot;,&quot; + pwd).compareTo(&quot;yes&quot;) == 0) { return true; } return false; } boolean check() { String id = id_text.getText(); String pwd = String.valueOf(pwd_text.getPassword()); String pwdc = String.valueOf(pwdCheck_text.getPassword()); String fName = firstName_text.getText(); String lName = lastName_text.getText(); String age = age_text.getText(); String num = num_text.getText(); String sex = sex_box.getSelectedItem().toString(); if (id.compareTo(&quot;&quot;) == 0) { ChatRoomUtil.showErrorBox(&quot;&#x8D26;&#x53F7;&#x4E0D;&#x80FD;&#x4E3A;&#x7A7A;&quot;); return false; } if (pwd.compareTo(&quot;&quot;) == 0) { ChatRoomUtil.showErrorBox(&quot;&#x5BC6;&#x7801;&#x4E0D;&#x80FD;&#x4E3A;&#x7A7A;&quot;); return false; } if (pwdc.compareTo(&quot;&quot;) == 0) { ChatRoomUtil.showErrorBox(&quot;&#x8BF7;&#x786E;&#x8BA4;&#x5BC6;&#x7801;&quot;); return false; } if (pwd.compareTo(pwdc) != 0) { ChatRoomUtil.showErrorBox(&quot;&#x4E24;&#x6B21;&#x8F93;&#x5165;&#x7684;&#x5BC6;&#x7801;&#x4E0D;&#x7B26;&quot;); return false; } if (num.compareTo(&quot;&quot;) == 0) { ChatRoomUtil.showErrorBox(&quot;&#x7F16;&#x53F7;&#x4E0D;&#x80FD;&#x4E3A;&#x7A7A;&quot;); return false; } if (fName.compareTo(&quot;&quot;) == 0) { ChatRoomUtil.showErrorBox(&quot;&#x540D;&#x4E0D;&#x80FD;&#x4E3A;&#x7A7A;&quot;); return false; } if (lName.compareTo(&quot;&quot;) == 0) { ChatRoomUtil.showErrorBox(&quot;&#x59D3;&#x4E0D;&#x80FD;&#x4E3A;&#x7A7A;&quot;); return false; } if (age.compareTo(&quot;&quot;) == 0) { ChatRoomUtil.showErrorBox(&quot;&#x5E74;&#x9F84;&#x4E0D;&#x80FD;&#x4E3A;&#x7A7A;&quot;); return false; } if (sex.compareTo(&quot;&quot;) == 0) { ChatRoomUtil.showErrorBox(&quot;&#x6027;&#x522B;&#x4E0D;&#x80FD;&#x4E3A;&#x7A7A;&quot;); return false; } if (regis(serverIP, serverPort, id, pwd, myServerPort)) { dispose(); } else { ChatRoomUtil.showErrorBox(&quot;&#x6CE8;&#x518C;&#x5931;&#x8D25;&#x3002;&#x8BE5;&#x7528;&#x6237;&#x5DF2;&#x5B58;&#x5728;&quot;); return false; } return true; } @Override public void actionPerformed(ActionEvent e) { Object t = e.getSource(); if (e.getSource().getClass() == JButton.class) { JButton button = (JButton) (t); if (button.getText().compareTo(&quot;&#x63D0;&#x4EA4;&quot;) == 0) { check(); } if (button.getText().compareTo(&quot;&#x53D6;&#x6D88;&quot;) == 0) { dispose(); } } }} ClientServer12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package chatroomclient;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;import chatroomutil.ChatRoomUtil;import chatroomutil.Server;public class ClientServer extends Server implements Runnable { ChatRoom chatRoom; private int myPort; public ClientServer(String serverIP, int serverPort) throws IOException { super(); myPort = init(); } int getMyServerPort() { return myPort; } private int createServerSocket(int i) throws IOException {//&#x7ED1;&#x5B9A;&#x7AEF;&#x53E3;i if (i &gt;= 65536) { ChatRoomUtil.showErrorBox(&quot;ClientServer&#x65E0;&#x7AEF;&#x53E3;&#x53EF;&#x7ED1;&#x5B9A;&quot;); System.exit(-1); } try { sSocket = new ServerSocket(i); } catch (IOException e) { return createServerSocket(i + 1); } return i; } private int init() throws IOException { int port = createServerSocket(1025); return port; } @Override protected String handle(Socket ots,String rMessage){ String message = &quot;getm&quot;; if (rMessage.startsWith(&quot;newf&quot;)) { while (chatRoom == null) { try { Thread.sleep(300); } catch (InterruptedException e) { ChatRoomUtil.showErrorBox(&quot;ClientServer&#x5728;Sleep&#x65F6;&#x51FA;&#x9519;&quot;); System.exit(-1); } } String ids = rMessage.substring((&quot;newf&quot;).length()); String[] idArray = ids.split(&quot;;&quot;); chatRoom.addFriend(idArray); } if (rMessage.startsWith(&quot;offl&quot;)) { String name = rMessage.substring((&quot;offl&quot;).length()); chatRoom.removeFriend(name); } if (rMessage.startsWith(&quot;mesg&quot;)) { String mesg = rMessage.substring((&quot;mesg&quot;).length()); chatRoom.addRecord(mesg); } if (rMessage.startsWith(&quot;chat&quot;)) { String chat = rMessage.substring((&quot;chat&quot;).length()); String id = chat.substring(0, chat.indexOf(&apos;:&apos;)); String mesg = chat.substring(chat.indexOf(&apos;:&apos;) + 1); chatRoom.dialogAddRecord(id, mesg); } return message; } @Override public void run() { listen(); }} ChatRoom123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212package chatroomclient;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.util.HashSet;import java.util.Hashtable;import java.util.Iterator;import java.util.TimerTask;import javax.swing.*;import javax.swing.event.CaretEvent;import javax.swing.event.CaretListener;import chatroomsend.Send;import chatroomutil.ChatRoomUtil;public class ChatRoom extends JFrame implements ActionListener, MouseListener { private static final long serialVersionUID = -9016166784223701159L; String myId; String serverIP; int serverPort; JLabel chatRoomLabel = new JLabel(); JLabel onlineLabel = new JLabel(); JTextArea chatArea = new JTextArea(); JPanel onlineArea = new JPanel(); JTextArea sendArea = new JTextArea(5, 20); JButton sendButton = new JButton(); JScrollPane chatScroll = new JScrollPane(chatArea); JScrollPane onlineScroll = new JScrollPane(onlineArea); JScrollPane sendScroll = new JScrollPane(sendArea); JPanel chatPanel = new JPanel(); JPanel onlinePanel = new JPanel(); JPanel sendPanel = new JPanel(); JPanel chatAndOnlinePanel = new JPanel(); HashSet&lt;String&gt; friends = new HashSet&lt;String&gt;(); Hashtable&lt;String, ChatDialog&gt; chatDialogs = new Hashtable&lt;String, ChatDialog&gt;(); BorderLayout mainLayout = new BorderLayout(); BorderLayout chatLayout = new BorderLayout(); BorderLayout onlineLayout = new BorderLayout(); BorderLayout sendLayout = new BorderLayout(); BorderLayout chatAndOnlineLayout = new BorderLayout(); FlowLayout onlineAreaLayout = new FlowLayout(); public ChatRoom(String id, String serverIP, int port) { super(&quot;&#x804A;&#x5929;&#x5BA4; &quot; + id); this.myId = id; this.serverIP = serverIP; this.serverPort = port; mainLayout.setVgap(5); sendLayout.setHgap(10); chatAndOnlineLayout.setHgap(15); onlineAreaLayout.setVgap(1); this.setLayout(mainLayout); chatPanel.setLayout(chatLayout); onlinePanel.setLayout(onlineLayout); sendPanel.setLayout(sendLayout); chatAndOnlinePanel.setLayout(chatAndOnlineLayout); chatArea.setLineWrap(true); sendArea.setLineWrap(true); onlineArea.setLayout(onlineAreaLayout); onlineArea.setPreferredSize(new Dimension(130, 200)); sendButton.setText(&quot; &#x53D1;&#x9001; &quot;); sendButton.setBackground(Color.LIGHT_GRAY); sendButton.addActionListener(this); onlineLabel.setText(&quot;&#x5728;&#x7EBF;&#x597D;&#x53CB;(&#x70B9;&#x51FB;&#x53EF;&#x5F00;&#x59CB;&#x804A;&#x5929;)&quot;); chatRoomLabel.setText(&quot;&#x804A;&#x5929;&quot;); chatArea.setEditable(false); chatArea.setBackground(new Color(230, 230, 230)); chatPanel.add(chatRoomLabel, BorderLayout.NORTH); chatPanel.add(chatScroll, BorderLayout.CENTER); onlinePanel.add(onlineLabel, BorderLayout.NORTH); onlinePanel.add(onlineScroll, BorderLayout.CENTER); sendPanel.add(sendScroll, BorderLayout.CENTER); sendPanel.add(sendButton, BorderLayout.EAST); chatAndOnlinePanel.add(chatPanel, BorderLayout.CENTER); chatAndOnlinePanel.add(onlinePanel, BorderLayout.EAST); this.add(sendPanel, BorderLayout.SOUTH); this.add(chatAndOnlinePanel, BorderLayout.CENTER); friends.add(myId); this.setBounds(200, 200, 600, 650); setVisible(true); reFreshOnlineArea(); this.setDefaultCloseOperation(DO_NOTHING_ON_CLOSE); this.addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent e) {//&#x70B9;&#x51FB;&#x5173;&#x95ED;&#x6309;&#x94AE;&#x65F6;&#x53D1;&#x9001;&#x4E0B;&#x7EBF;&#x6D88;&#x606F; sendOffLine(); System.exit(0); } }); sendArea.addCaretListener(new CaretListener() { @Override public void caretUpdate(CaretEvent e) { String str = sendArea.getText(); if (str.length() &gt; 5000) { ChatRoomUtil.showErrorBox(&quot;&#x5B57;&#x6570;&#x8FC7;&#x591A;&#xFF0C;&#x8D85;&#x51FA;&#x9650;&#x5236;&#x3002;&quot;); } } }); new java.util.Timer().schedule(new TimerTask() {//&#x5B9A;&#x65F6;&#x5237;&#x65B0;&#x754C;&#x9762; public void run() { repaint(); } }, 400, 400); } int reFreshOnlineArea() {//&#x5237;&#x65B0;&#x5F53;&#x524D;&#x5728;&#x7EBF;&#x7528;&#x6237; int size = friends.size(); onlineArea.removeAll(); Iterator&lt;String&gt; it = friends.iterator(); while (it.hasNext()) { String str = it.next(); String id = str; JLabel label = new JLabel(id); label.addMouseListener(this); label.setPreferredSize(new Dimension(130, 20)); label.setBackground(Color.GRAY); label.setForeground(Color.WHITE); label.setHorizontalAlignment(JLabel.CENTER); label.setOpaque(true); onlineArea.add(label); } onlineArea.setPreferredSize(new Dimension(130, size * 22)); this.repaint(); this.validate(); return 0; } int sendOffLine() {//&#x53D1;&#x9001;&#x4E0B;&#x7EBF;&#x6D88;&#x606F; Send sendClient = new Send(); sendClient.connect(serverIP, serverPort, 1000); sendClient.send(&quot;offl&quot; + myId); return 0; } public int addFriend(String[] fs) {//&#x6DFB;&#x52A0;&#x4E0A;&#x7EBF;&#x7684;&#x7528;&#x6237; for (int i = 0; i &lt; fs.length; i++) { friends.add(fs[i]); } reFreshOnlineArea(); return 0; } public int removeFriend(String friendID) {//&#x79FB;&#x9664;&#x4E00;&#x4E2A;&#x7528;&#x6237;&#xFF08;&#x5DF2;&#x4E0B;&#x7EBF;&#xFF09; friends.remove(friendID); reFreshOnlineArea(); return 0; } public int addRecord(String mesg) {//&#x6DFB;&#x52A0;&#x804A;&#x5929;&#x8BB0;&#x5F55; chatArea.append(mesg + &quot;\n&quot;); chatArea.setCaretPosition(chatArea.getText().length()); this.validate(); return 0; } public int dialogAddRecord(String id, String mesg) {//&#x7ED9;&#x4E00;&#x5BF9;&#x4E00;&#x804A;&#x5929;&#x589E;&#x52A0;&#x804A;&#x5929;&#x8BB0;&#x5F55; if (chatDialogs.containsKey(id) == false) { chatDialogs.put(id, new ChatDialog(this, myId, id, serverIP, serverPort)); } chatDialogs.get(id).addRecord(mesg); return 0; } int removeDialog(String id) {//&#x79FB;&#x9664;&#x4E00;&#x5BF9;&#x4E00;&#x804A;&#x5929; chatDialogs.remove(id); return 0; } private String sendMessage(String mesg) {//&#x53D1;&#x9001;&#x7FA4;&#x804A;&#x6D88;&#x606F; Send sendClient = new Send(); sendClient.connect(serverIP, serverPort, 1000); String getm = sendClient.send(&quot;mesg&quot; + myId + &quot;: \n&quot; + mesg); return getm; } @Override public void actionPerformed(ActionEvent e) { if (e.getSource().getClass() == JButton.class) { sendMessage(sendArea.getText()); sendArea.setText(&quot;&quot;); } } @Override public void mouseClicked(MouseEvent e) { if (e.getSource().getClass() == JLabel.class) { JLabel l = (JLabel) e.getSource(); if (l.getText().compareTo(myId) == 0) { return; } if (chatDialogs.containsKey(l.getText())) { return; } chatDialogs.put(l.getText(), new ChatDialog(this, myId, l.getText(), serverIP, serverPort)); } } @Override public void mouseEntered(MouseEvent e) { if (e.getSource().getClass() == JLabel.class) { JLabel l = (JLabel) e.getSource(); l.setBackground(Color.LIGHT_GRAY); l.setForeground(Color.BLACK); } } @Override public void mouseExited(MouseEvent e) { if (e.getSource().getClass() == JLabel.class) { JLabel l = (JLabel) e.getSource(); l.setBackground(Color.GRAY); l.setForeground(Color.WHITE); } } @Override public void mousePressed(MouseEvent e) { } @Override public void mouseReleased(MouseEvent e) { }} ChatDialog123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package chatroomclient;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.util.HashSet;import java.util.TimerTask;import javax.swing.*;import javax.swing.event.CaretEvent;import javax.swing.event.CaretListener;import chatroomsend.Send;import chatroomutil.ChatRoomUtil;public class ChatDialog extends JFrame implements ActionListener { private static final long serialVersionUID = 1437996471885472344L; String myId; String otsId; String serverIP; int serverPort; JLabel chatRoomLabel = new JLabel(); JTextArea chatArea = new JTextArea(); JTextArea sendArea = new JTextArea(5, 20); JButton sendButton = new JButton(); JScrollPane chatScroll = new JScrollPane(chatArea); JScrollPane sendScroll = new JScrollPane(sendArea); JPanel chatPanel = new JPanel(); JPanel sendPanel = new JPanel(); HashSet&lt;String&gt; friends = new HashSet&lt;String&gt;(); BorderLayout mainLayout = new BorderLayout(); BorderLayout chatLayout = new BorderLayout(); BorderLayout sendLayout = new BorderLayout(); ChatRoom chatRoom; public ChatDialog(final ChatRoom chatRoom, String id, final String otsId, String serverIP, int port) { super(id + &quot;&#x4E0E;&quot; + otsId + &quot;&#x804A;&#x5929;&quot;); this.chatRoom = chatRoom; this.myId = id; this.otsId = otsId; this.serverIP = serverIP; this.serverPort = port; mainLayout.setVgap(5); sendLayout.setHgap(10); this.setLayout(mainLayout); chatPanel.setLayout(chatLayout); sendPanel.setLayout(sendLayout); chatArea.setLineWrap(true); sendArea.setLineWrap(true); sendButton.setText(&quot; &#x53D1;&#x9001; &quot;); sendButton.setBackground(Color.LIGHT_GRAY); sendButton.addActionListener(this); chatRoomLabel.setText(&quot;&#x804A;&#x5929;&quot;); chatArea.setEditable(false); chatArea.setBackground(new Color(230, 230, 230)); chatPanel.add(chatRoomLabel, BorderLayout.NORTH); chatPanel.add(chatScroll, BorderLayout.CENTER); sendPanel.add(sendScroll, BorderLayout.CENTER); sendPanel.add(sendButton, BorderLayout.EAST); this.add(sendPanel, BorderLayout.SOUTH); this.add(chatPanel, BorderLayout.CENTER); this.setBounds(200, 200, 530, 600); setVisible(true); this.setDefaultCloseOperation(DISPOSE_ON_CLOSE); sendArea.addCaretListener(new CaretListener() { @Override public void caretUpdate(CaretEvent e) { String str = sendArea.getText(); if (str.length() &gt; 5000) { ChatRoomUtil.showErrorBox(&quot;&#x5B57;&#x6570;&#x8FC7;&#x591A;&#xFF0C;&#x8D85;&#x51FA;&#x9650;&#x5236;&#x3002;&quot;); } } }); this.setDefaultCloseOperation(DO_NOTHING_ON_CLOSE); this.addWindowListener(new WindowAdapter() { public void windowClosing(WindowEvent e) {//&#x5173;&#x95ED;&#x7A97;&#x53E3;&#x540E;&#xFF0C;ChatRoom&#x8981;&#x79FB;&#x9664;&#x8BE5;&#x5BF9;&#x8BDD; chatRoom.removeDialog(otsId); dispose(); } }); new java.util.Timer().schedule(new TimerTask() { public void run() { repaint(); } }, 400, 400); } public int addRecord(String mesg) { chatArea.append(mesg + &quot;\n&quot;); chatArea.setCaretPosition(chatArea.getText().length()); this.validate(); return 0; } private String sendMessage(String mesg) { Send sendClient = new Send(); sendClient.connect(serverIP, serverPort, 1000); String getm = sendClient.send( &quot;chat&quot; + otsId + &quot;:&quot; + myId + &quot;:&quot; + myId + &quot;: \n&quot; + mesg); addRecord(myId + &quot;: \n&quot; + mesg); return getm; } @Override public void actionPerformed(ActionEvent e) { if (e.getSource().getClass() == JButton.class) { sendMessage(sendArea.getText()); sendArea.setText(&quot;&quot;); } }} Users.txt1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061:12:23:34:45:56:67:78:89:910:1011:1112:1213:1314:1415:1516:1617:1718:1819:1920:2021:2122:2223:2324:2425:2526:2627:2728:2829:2930:3031:3132:3233:3334:3435:3536:3637:3738:3839:3940:4041:4142:4243:4344:4445:4546:4647:4748:4849:4950:5051:5152:5253:5354:5455:5556:5657:5758:5859:5960:6061:6162:6263:6364:6465:6566:6667:6768:6869:6970:7071:7172:7273:7374:7475:7576:7677:7778:7879:7980:8081:8182:8283:8384:8485:8586:8687:8788:8889:8990:9091:9192:9293:9394:9495:9596:96aa:aaqq:qqww:wwee:eeguochengxin:guochengxinhuoda:huodazhangfa:zhangfahanyu:hanyumaxuewei:maxueweilizeyu:lizeyu &#x5199;&#x4E8E;&#x5927;&#x4E09;&#x4E0B;&#x5B9E;&#x8BAD;&#x671F;&#x95F4; &#x968F;&#x7B14;&#x5199;&#x4E8E;2016.7.13]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[俄罗斯方块（Win32实现，Codeblocks+GCC编译）]]></title>
      <url>2016%2F05%2F08%2F%E4%BF%84%E7%BD%97%E6%96%AFC%2B%2B%2F</url>
      <content type="text"><![CDATA[&#x7F18;&#x8D77;&#xFF1A;&#x3000;&#x3000;&#x5728;&#x73A9;Codeblocks&#x81EA;&#x5E26;&#x7684;&#x4FC4;&#x7F57;&#x65AF;&#x65B9;&#x5757;&#x65F6;&#x89C9;&#x5F97;&#x4E0D;&#x9519;&#xFF0C;&#x7136;&#x800C;&#x6709;&#x65F6;&#x95F4;&#x9650;&#x5236;&#x3002;&#x6240;&#x4EE5;&#x60F3;&#x81EA;&#x5DF1;&#x518D;&#x5199;&#x4E00;&#x4E2A;&#x3002; &#x540E;&#x6765;&#x53D1;&#x73B0;&#x5728;&#x8BBE;&#x7F6E;&#x4E2D;&#x662F;&#x53EF;&#x4EE5;&#x53D6;&#x6D88;&#x65F6;&#x95F4;&#x9650;&#x5236;&#x7684;&#x3002;&#x3002;&#x3002;Orz &#x7A0B;&#x5E8F;&#x6548;&#x679C;&#xFF1A; &#x4E3B;&#x8981;&#x5185;&#x5BB9;&#xFF1A;&#x3000;&#x3000;&#x7A0B;&#x5E8F;&#x4E2D;&#x6709;&#x4E00;&#x4E2A;board&#x6570;&#x7EC4;&#xFF0C;&#x5176;&#x4E2D;&#x6709;&#x8981;&#x663E;&#x793A;&#x7684;&#x90E8;&#x5206;&#xFF0C;&#x4E5F;&#x6709;&#x4E0D;&#x663E;&#x793A;&#x7684;&#x90E8;&#x5206;&#xFF0C;&#x4E0D;&#x663E;&#x793A;&#x7684;&#x90E8;&#x5206;&#x90FD;&#x5B58;&#x50A8;1&#x3002; &#x3000;&#x3000;&#x5982;&#x4E0B;&#x56FE;&#xFF1A; &#x3000;&#x3000;&#x3000;&#x3000; &#x3000;&#x3000;shape&#x91C7;&#x7528;4*4&#x6570;&#x7EC4;(shape)&#x4FDD;&#x5B58;&#x3002;&#x5982;&#xFF1A; 0 0 0 00 1 0 01 1 1 00 0 0 0 &#x3000;&#x3000;&#x53E6;&#x5916;&#x7528;&#x53D8;&#x91CF;row&#x548C;column&#x4FDD;&#x5B58;shape&#x6570;&#x7EC4;&#x5DE6;&#x4E0A;&#x89D2;&#x5728;board&#x4E2D;&#x7684;&#x4F4D;&#x7F6E;&#x3002; &#x3000;&#x3000;&#x6BCF;&#x6B21;&#x4E0B;&#x843D;&#x6216;&#x5DE6;&#x53F3;&#x79FB;&#x52A8;&#xFF0C;&#x5148;&#x5BF9;row&#x548C;column&#x505A;&#x51FA;&#x6539;&#x53D8;&#xFF0C;&#x7136;&#x540E;&#x68C0;&#x6D4B;&#x5F53;&#x524D;row&#x548C;column&#x4E0B;&#xFF0C;shape&#x662F;&#x5426;&#x91CD;&#x5408;&#x4E86;&#x4E3A;1&#x7684;&#x683C;&#x5B50;&#xFF0C;&#x5982;&#x679C;&#x6709;&#x91CD;&#x5408;&#xFF0C;&#x5C31;&#x8BF4;&#x660E;shape&#x51FA;&#x754C;&#x4E86;&#x6216;&#x8005;&#x5230;&#x8FBE;&#x4E0B;&#x843D;&#x6700;&#x4F4E;&#x70B9;&#xFF0C;&#x5219;&#x8981;&#x6062;&#x590D;row&#x548C;column&#x503C;&#x3002;&#x53E6;&#x5916;&#xFF0C;&#x5982;&#x679C;&#x662F;&#x4E0B;&#x843D;&#xFF0C;&#x8FD8;&#x8981;&#x5C06;shape&#x653E;&#x5728;board&#x4E0A;&#xFF0C;&#x5E76;&#x4EA7;&#x751F;&#x65B0;&#x7684;shape&#x3002; &#x3000;&#x3000;&#x65CB;&#x8F6C;&#x65F6;&#xFF0C;&#x5148;&#x5BF9;shape&#x6570;&#x7EC4;&#x8FDB;&#x884C;&#x65CB;&#x8F6C;&#x64CD;&#x4F5C;&#xFF0C;&#x7136;&#x540E;&#x68C0;&#x6D4B;&#x91CD;&#x5408;&#xFF0C;&#x5982;&#x679C;&#x6709;&#x91CD;&#x5408;&#xFF0C;&#x5219;&#x53CD;&#x5411;&#x65CB;&#x8F6C;&#x56DE;&#x6765;&#x3002; &#x2002;&#x2002;&#x2002;&#x2002; &#x4EE3;&#x7801;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553#if defined(UNICODE) &amp;&amp; !defined(_UNICODE)#define _UNICODE#elif defined(_UNICODE) &amp;&amp; !defined(UNICODE)#define UNICODE#endif#include &lt;tchar.h&gt;#include &lt;windows.h&gt;#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;/*-----------------&#x5B8F;&#x5B9A;&#x4E49;--------------------------------------------------------*/#define WIDTH 180#define HEIGHT 400#define LONG_SLEEP 300#define BKCOLOR RGB(238,238,238)//&#x80CC;&#x666F;&#x8272;/*-----------------&#x53D8;&#x91CF;----------------------------------------------------------*/static int shapes[7][4][4];//&#x5B58;&#x50A8;7&#x4E2A;&#x5F62;&#x72B6;static int high_score[4]= {0,0,0,0};//&#x524D;&#x4E09;&#x4E2A;&#x5143;&#x7D20;&#x5B58;&#x50A8;&#x6700;&#x9AD8;&#x5206;&#xFF0C;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x5143;&#x7D20;&#x5B58;&#x50A8;&#x6B64;&#x6B21;&#x5F97;&#x5206;static int **shape;//&#x5F53;&#x524D;&#x5F62;&#x72B6;static int **board;static int M=15;//&#x663E;&#x793A;&#x7684;&#x5217;&#x6570;static int N=30;//&#x663E;&#x793A;&#x7684;&#x884C;&#x6570;static int MM=M+8;//board&#x7684;&#x5217;&#x6570;static int NN=N+4;//board&#x7684;&#x884C;&#x6570;static int LEFT=4;//&#x663E;&#x793A;&#x7684;&#x6700;&#x5DE6;&#x4E00;&#x5217;static int RIGHT=LEFT+M-1;//&#x663E;&#x793A;&#x7684;&#x6700;&#x53F3;&#x4E00;&#x5217;static int TOP=0;//&#x663E;&#x793A;&#x7684;&#x6700;&#x4E0A;&#x4E00;&#x5217;static int BOTTOM=N-1;//&#x663E;&#x793A;&#x7684;&#x6700;&#x4E0B;&#x4E00;&#x5217;static int score=0;static int row=0;//&#x5F62;&#x72B6;&#x6240;&#x5728;&#x884C;static int column=MM/2;//&#x5F62;&#x72B6;&#x5750;&#x5728;&#x5217;static bool is_pause=false;static HBRUSH grey_brush =CreateSolidBrush (RGB(210,210,210));static HBRUSH white_brush =CreateSolidBrush (RGB(130,130,130));static HBRUSH bk_brush =CreateSolidBrush (BKCOLOR);static HPEN hPen = CreatePen(PS_SOLID,1,RGB(147,155,166));static int lattices_top=40;//&#x4E0A;&#x9762;&#x7559;&#x767D;static int lattices_left=20;//&#x5DE6;&#x4FA7;&#x7559;&#x767D;static int width=WIDTH/M;//&#x6BCF;&#x4E2A;&#x683C;&#x5B50;&#x7684;&#x5BBD;&#x5EA6;static int height=(HEIGHT-lattices_top)/N;//&#x6BCF;&#x4E2A;&#x683C;&#x5B50;&#x7684;&#x9AD8;&#x5EA6;/*-----------------&#x51FD;&#x6570;-----------------------------------------------------------*/void add_score() ;bool check_is_lose() ;void clear_up() ;//&#x6D88;&#x9664;&#x6CA1;&#x6709;&#x7A7A;&#x683C;&#x5B50;&#x7684;&#x884C;void* down_thread_function(void * args) ;//&#x5F62;&#x72B6;&#x4E0B;&#x843D;&#x8FDB;&#x7A0B;&#x8981;&#x6267;&#x884C;&#x7684;&#x51FD;&#x6570;void exit_game(HWND hwnd) ;void give_new_shape() ;//&#x968F;&#x673A;&#x751F;&#x6210;&#x4E00;&#x4E2A;&#x65B0;&#x5F62;&#x72B6;int handle_key(HWND hwnd,WPARAM wParam) ;int init_down_thread(HWND hwnd) ;//&#x521D;&#x59CB;&#x5316;&#x5F62;&#x72B6;&#x4E0B;&#x843D;&#x8FDB;&#x7A0B;int init_game(HWND hwnd) ;//&#x521D;&#x59CB;&#x5316;&#x6E38;&#x620F;&#x7A0B;&#x5E8F;void init_play() ;//&#x521D;&#x59CB;&#x5316;&#x6E38;&#x620F;&#x6570;&#x636E;bool is_legel() ;//&#x68C0;&#x6D4B;&#x5F62;&#x72B6;&#x5728;&#x5F53;&#x524D;&#x4F4D;&#x7F6E;&#x662F;&#x5426;&#x5408;&#x6CD5;&#xFF08;&#x5373;&#x662F;&#x5426;&#x91CD;&#x5408;&#x4E86;&#x975E;&#x7A7A;&#x7684;&#x683C;&#x5B50;&#xFF09;int load_scores(int* a) ;//&#x8BFB;&#x53D6;&#x6E38;&#x620F;&#x6700;&#x9AD8;&#x5206;&#x6570;&#x636E;int load_shape() ;//&#x4ECE;&#x6587;&#x4EF6;&#x4E2D;&#x52A0;&#x8F7D;7&#x4E2A;&#x5F62;&#x72B6;void lose_game(HWND hwnd) ;int move_down(HWND hwnd) ;//&#x5F62;&#x72B6;&#x4E0B;&#x843D;int move_lr(HWND hwnd,int lr) ;//&#x5F62;&#x72B6;&#x5DE6;&#x53F3;&#x79FB;&#x52A8;void paint_lattice(HDC hdc,int x,int y,int color) ;//&#x663E;&#x793A;&#x4E00;&#x4E2A;&#x683C;&#x5B50;void paint_UI(HDC hdc) ;//&#x753B;&#x754C;&#x9762;void reset_rc() ;void rerotate_matrix(int mn) ;//&#x987A;&#x65F6;&#x9488;&#x65CB;&#x8F6C;&#x4E00;&#x4E2A;&#x884C;&#x5217;&#x6570;&#x4E3A;mn&#x7684;&#x65B9;&#x9635;void rotate_matrix(int mn) ;//&#x9006;&#x65F6;&#x9488;&#x65CB;&#x8F6C;&#x4E00;&#x4E2A;&#x884C;&#x5217;&#x6570;&#x4E3A;mn&#x7684;&#x65B9;&#x9635;int rotate_shape(HWND hwnd) ;//&#x65CB;&#x8F6C;&#x5F53;&#x524D;&#x5F62;&#x72B6;&#x5E76;&#x66F4;&#x65B0;&#x754C;&#x9762;bool save_score(HWND hwnd) ;//&#x4FDD;&#x5B58;&#x6700;&#x9AD8;&#x5206;&#x6570;&#x636E;void shape_to_ground() ;//&#x5F53;&#x524D;&#x5F62;&#x72B6;&#x843D;&#x5730;&#x4E4B;&#x540E;&#xFF0C;&#x66F4;&#x65B0;boardbool sort_scores(int* a) ;//&#x5BF9;&#x6700;&#x9AD8;&#x5206;&#x548C;&#x6B64;&#x6B21;&#x5F97;&#x5206;&#x6392;&#x5E8F;&#xFF0C;&#x82E5;&#x521B;&#x9020;&#x65B0;&#x7EAA;&#x5F55;&#x5219;&#x8FD4;&#x56DE;truevoid update_UI(HWND hwnd) ;//&#x66F4;&#x65B0;&#x754C;&#x9762;&#xFF0C;&#x4EC5;&#x66F4;&#x65B0;Rect&#x533A;&#x57DF;&#xFF08;&#x5F62;&#x72B6;&#x6240;&#x5728;&#x7684;&#x90A3;&#x51E0;&#x884C;&#xFF09;&#x5185;void update_UI_all(HWND hwnd) ;//&#x66F4;&#x65B0;&#x754C;&#x9762;&#xFF0C;&#x66F4;&#x65B0;&#x6574;&#x4E2A;&#x754C;&#x9762;int write_scores(int* a) ;//&#x5199;&#x6700;&#x9AD8;&#x5206;&#x6570;&#x636E;/* Declare Windows procedure */LRESULT CALLBACK WindowProcedure (HWND, UINT, WPARAM, LPARAM);/* Make the class name into a global variable */TCHAR szClassName[ ] = _T(&quot;Tris&quot;);int WINAPI WinMain (HINSTANCE hThisInstance, HINSTANCE hPrevInstance, LPSTR lpszArgument, int nCmdShow) { HWND hwnd; /* This is the handle for our window */ MSG messages; /* Here messages to the application are saved */ WNDCLASSEX wincl; /* Data structure for the windowclass */ /* The Window structure */ wincl.hInstance = hThisInstance; wincl.lpszClassName = szClassName; wincl.lpfnWndProc = WindowProcedure; /* This function is called by windows */ wincl.style = CS_DBLCLKS; /* Catch double-clicks */ wincl.cbSize = sizeof (WNDCLASSEX); /* Use default icon and mouse-pointer */ wincl.hIcon = LoadIcon (NULL, IDI_APPLICATION); wincl.hIconSm = LoadIcon (NULL, IDI_APPLICATION); wincl.hCursor = LoadCursor (NULL, IDC_ARROW); wincl.lpszMenuName = NULL; /* No menu */ wincl.cbClsExtra = 0; /* No extra bytes after the window class */ wincl.cbWndExtra = 0; /* structure or the window instance */ /* Use Windows&apos;s default colour as the background of the window */ wincl.hbrBackground =bk_brush; /* Register the window class, and if it fails quit the program */ if (!RegisterClassEx (&amp;wincl)) return 0; /* The class is registered, let&apos;s create the program*/ hwnd = CreateWindowEx ( 0, /* Extended possibilites for variation */ szClassName, /* Classname */ _T(&quot;Tris&quot;), /* Title Text */ WS_OVERLAPPEDWINDOW, /* default window */ CW_USEDEFAULT, /* Windows decides the position */ CW_USEDEFAULT, /* where the window ends up on the screen */ WIDTH+200, /* The programs width */ HEIGHT+70, /* and height in pixels */ HWND_DESKTOP, /* The window is a child-window to desktop */ NULL, /* No menu */ hThisInstance, /* Program Instance handler */ NULL /* No Window Creation data */ ); /* Make the window visible on the screen */ ShowWindow (hwnd, nCmdShow); /* Run the message loop. It will run until GetMessage() returns 0 */ while (GetMessage (&amp;messages, NULL, 0, 0)) { /* Translate virtual-key messages into character messages */ TranslateMessage(&amp;messages); /* Send message to WindowProcedure */ DispatchMessage(&amp;messages); } /* The program return-value is 0 - The value that PostQuitMessage() gave */ return messages.wParam;}//&#x4ECE;&#x6587;&#x4EF6;&#x4E2D;&#x52A0;&#x8F7D;7&#x4E2A;&#x5F62;&#x72B6;int load_shape() { FILE* f=fopen(&quot;shapes.txt&quot;,&quot;rb&quot;); if(f==NULL) { return -1; } for(int i=0; i&lt;7; i++) { for(int j=0; j&lt;4; j++) { for(int k=0; k&lt;4; k++) { if(fscanf(f,&quot;%d&quot;,&amp;shapes[i][j][k])!=1) { return -1; } } } } fclose(f); return 0;}//&#x968F;&#x673A;&#x751F;&#x6210;&#x4E00;&#x4E2A;&#x65B0;&#x5F62;&#x72B6;void give_new_shape() { int shape_num=rand()%7; for(int i=0; i&lt;4; i++) { for(int j=0; j&lt;4; j++) { shape[i][j]=shapes[shape_num][i][j]; } }}void add_score() { score+=100;}//&#x6D88;&#x9664;&#x6CA1;&#x6709;&#x7A7A;&#x683C;&#x5B50;&#x7684;&#x884C;void clear_up() { for(int i=row; i&lt;=row+3; i++) { if(i&gt;BOTTOM)continue; bool there_is_blank=false; for(int j=LEFT; j&lt;=RIGHT; j++) { if(board[i][j]==0) { there_is_blank=true; break; } } if(!there_is_blank) { add_score(); for(int r=i; r&gt;=1; r--) { for(int c=LEFT; c&lt;=RIGHT; c++) { board[r][c]=board[r-1][c]; } } } }}//&#x68C0;&#x6D4B;&#x5F62;&#x72B6;&#x5728;&#x5F53;&#x524D;&#x4F4D;&#x7F6E;&#x662F;&#x5426;&#x5408;&#x6CD5;&#xFF08;&#x5373;&#x662F;&#x5426;&#x91CD;&#x5408;&#x4E86;&#x975E;&#x7A7A;&#x7684;&#x683C;&#x5B50;&#xFF09;bool is_legel() { for(int i=0; i&lt;4; i++) { for(int j=0; j&lt;4; j++) { if(shape[i][j]==1&amp;&amp;board[row+i][column+j]==1) { return false; } } } return true;}//&#x9006;&#x65F6;&#x9488;&#x65CB;&#x8F6C;&#x4E00;&#x4E2A;&#x884C;&#x5217;&#x6570;&#x4E3A;mn&#x7684;&#x65B9;&#x9635;void rotate_matrix(int mn) { int** a=shape; int s=0; for(int n=mn; n&gt;=1; n-=2) { for(int i=0; i&lt;n-1; i++) { int t=a[s+i][s]; a[s+i][s]=a[s][s+n-i-1]; a[s][s+n-i-1]=a[s+n-i-1][s+n-1]; a[s+n-i-1][s+n-1]=a[s+n-1][s+i]; a[s+n-1][s+i]=t; } s++; }}//&#x987A;&#x65F6;&#x9488;&#x65CB;&#x8F6C;&#x4E00;&#x4E2A;&#x884C;&#x5217;&#x6570;&#x4E3A;mn&#x7684;&#x65B9;&#x9635;void rerotate_matrix(int mn) { int** a=shape; int s=0; for(int n=mn; n&gt;=1; n-=2) { for(int i=0; i&lt;n-1; i++) { int t=a[s+i][s]; a[s+i][s]=a[s+n-1][s+i]; a[s+n-1][s+i]=a[s+n-i-1][s+n-1]; a[s+n-i-1][s+n-1]=a[s][s+n-i-1]; a[s][s+n-i-1]=t; } s++; }}//&#x663E;&#x793A;&#x4E00;&#x4E2A;&#x683C;&#x5B50;void paint_lattice(HDC hdc,int x,int y,int color) { if(x&lt;TOP||x&gt;BOTTOM||y&lt;LEFT||y&gt;RIGHT) { return ; } x-=TOP; y-=LEFT; int left=lattices_left+y*width; int right=lattices_left+y*width+width; int top=lattices_top+x*height; int bottom=lattices_top+x*height+height; MoveToEx (hdc,left,top, NULL) ; LineTo (hdc,right,top) ; MoveToEx (hdc,left,top, NULL) ; LineTo (hdc,left,bottom) ; MoveToEx (hdc,left,bottom, NULL) ; LineTo (hdc,right,bottom) ; MoveToEx (hdc,right,top, NULL) ; LineTo (hdc,right,bottom) ; SelectObject(hdc, grey_brush); if(color==0) { SelectObject(hdc, white_brush); } Rectangle(hdc,left,top,right,bottom);}//&#x66F4;&#x65B0;&#x754C;&#x9762;&#xFF0C;&#x4EC5;&#x66F4;&#x65B0;Rect&#x533A;&#x57DF;&#xFF08;&#x5F62;&#x72B6;&#x6240;&#x5728;&#x7684;&#x90A3;&#x51E0;&#x884C;&#xFF09;&#x5185;void update_UI(HWND hwnd) { static RECT rect; rect.left=lattices_left; rect.right=lattices_left+M*width+width; rect.top=lattices_top+(row-1)*height; rect.bottom=lattices_top+(row+4)*height; InvalidateRect (hwnd,&amp;rect, false) ;}//&#x66F4;&#x65B0;&#x754C;&#x9762;&#xFF0C;&#x66F4;&#x65B0;&#x6574;&#x4E2A;&#x754C;&#x9762;void update_UI_all(HWND hwnd) { InvalidateRect (hwnd,NULL, false) ;}//&#x753B;&#x754C;&#x9762;void paint_UI(HDC hdc) { SetBkColor(hdc,BKCOLOR); SelectObject(hdc,hPen); //&#x9009;&#x7528;&#x753B;&#x7B14; char score_str[20]; sprintf(score_str,&quot;Score:%d&quot;,score); TextOut(hdc,10,10,score_str,strlen(score_str)); sprintf(score_str,&quot;Highest Scores:&quot;); TextOut(hdc,WIDTH+50,50,score_str,strlen(score_str)); for(int i=0; i&lt;3; i++) { sprintf(score_str,&quot;%d&quot;,high_score[i]); TextOut(hdc,WIDTH+50,50+(i+1)*20,score_str,strlen(score_str)); } for(int i=TOP; i&lt;=BOTTOM; i++) { for(int j=LEFT; j&lt;=RIGHT; j++) { paint_lattice(hdc,i,j,board[i][j]); } } for(int i=0; i&lt;4; i++) { for(int j=0; j&lt;4; j++) { if(shape[i][j]==1) paint_lattice(hdc,row+i,column+j,shape[i][j]); } }}//&#x65CB;&#x8F6C;&#x5F53;&#x524D;&#x5F62;&#x72B6;&#x5E76;&#x66F4;&#x65B0;&#x754C;&#x9762;int rotate_shape(HWND hwnd) { int mn=4; rotate_matrix(mn); if(!is_legel()) { rerotate_matrix(mn); } update_UI(hwnd);}void reset_rc() { row=0; column=MM/2-2;}//&#x8BFB;&#x53D6;&#x6E38;&#x620F;&#x6700;&#x9AD8;&#x5206;&#x6570;&#x636E;int load_scores(int* a) { FILE* f=fopen(&quot;scores.txt&quot;,&quot;r&quot;); if(f==NULL)return -1; fscanf(f,&quot;%d%d%d&quot;,&amp;a[0],&amp;a[1],&amp;a[2]); return 0;}//&#x521D;&#x59CB;&#x5316;&#x6E38;&#x620F;&#x6570;&#x636E;void init_play() { load_scores(high_score); for(int i=0; i&lt;NN; i++) { for(int j=0; j&lt;MM; j++) { board[i][j]=0; } } for(int i=0; i&lt;N; i++) { for(int j=0; j&lt;LEFT; j++) { board[i][j]=1; } } for(int i=0; i&lt;N; i++) { for(int j=RIGHT+1; j&lt;MM; j++) { board[i][j]=1; } } for(int i=BOTTOM+1; i&lt;NN; i++) { for(int j=0; j&lt;MM; j++) { board[i][j]=1; } } reset_rc(); score=0; give_new_shape(); is_pause=false; return ;}bool check_is_lose() { if(row==0)return true; return false;}//&#x5BF9;&#x6700;&#x9AD8;&#x5206;&#x548C;&#x6B64;&#x6B21;&#x5F97;&#x5206;&#x6392;&#x5E8F;&#xFF0C;&#x82E5;&#x521B;&#x9020;&#x65B0;&#x7EAA;&#x5F55;&#x5219;&#x8FD4;&#x56DE;truebool sort_scores(int* a) { int temp=a[3]; for(int i=0; i&lt;4; i++) { for(int j=0; j&lt;3; j++) { if(a[j]&lt;a[j+1]) { int t=a[j]; a[j]=a[j+1]; a[j+1]=t; } } } if(temp&gt;a[3])return true; return false;}//&#x5199;&#x6700;&#x9AD8;&#x5206;&#x6570;&#x636E;int write_scores(int* a) { FILE* f=fopen(&quot;scores.txt&quot;,&quot;w&quot;); if(f==NULL)return -1; fprintf(f,&quot;%d\n%d\n%d\n&quot;,a[0],a[1],a[2]); return 0;}//&#x4FDD;&#x5B58;&#x6700;&#x9AD8;&#x5206;&#x6570;&#x636E;bool save_score(HWND hwnd) { high_score[3]=score; bool made_record=sort_scores(high_score); if(write_scores(high_score)!=0) { MessageBox(hwnd,&quot;Write file error.Program will exit.&quot;,&quot;Error&quot;,NULL); DestroyWindow(hwnd); } return made_record;}void lose_game(HWND hwnd) { if(is_pause)return ; is_pause=true; char message[200]=&quot;You lose the Game.\n&quot;; char title[50]=&quot;Game Over&quot;; if(save_score(hwnd)) { strcat(message,&quot;You have made a new record.\n&quot;); char score_str[100]; sprintf(score_str,&quot;The Highest Scores:\n%d\n%d\n%d\n&quot;,high_score[0],high_score[1],high_score[2]); strcat(message,score_str); } strcat(message,&quot;\nPlay again?\n&quot;); if(MessageBox(hwnd,message,title,MB_YESNO)==IDYES) { init_play(); update_UI_all(hwnd); } else { exit(0); }}void exit_game(HWND hwnd) { is_pause=true; char message[200]=&quot;&quot;; char title[50]=&quot;Exit&quot;; if(save_score(hwnd)) { strcat(message,&quot;You have made a new record.\n&quot;); char score_str[100]; sprintf(score_str,&quot;The Highest Scores:\n%d\n%d\n%d\n&quot;,high_score[0],high_score[1],high_score[2]); strcat(message,score_str); MessageBox(hwnd,message,title,NULL); } exit(0);}//&#x5F53;&#x524D;&#x5F62;&#x72B6;&#x843D;&#x5730;&#x4E4B;&#x540E;&#xFF0C;&#x66F4;&#x65B0;boardvoid shape_to_ground() { for(int i=0; i&lt;4; i++) { for(int j=0; j&lt;4; j++) { board[row+i][column+j]=shape[i][j]==1?1:board[row+i][column+j]; } }}//&#x5F62;&#x72B6;&#x4E0B;&#x843D;int move_down(HWND hwnd) { row++; if(!is_legel()) { row--; if(check_is_lose()) { lose_game(hwnd); return 0; } shape_to_ground(); clear_up(); update_UI_all(hwnd); reset_rc(); give_new_shape(); } update_UI(hwnd);}//&#x8FDB;&#x7A0B;&#x53C2;&#x6570;&#x7ED3;&#x6784;&#x4F53;struct thread_arg { HWND arg_hwnd;};//&#x5F62;&#x72B6;&#x4E0B;&#x843D;&#x8FDB;&#x7A0B;&#x8981;&#x6267;&#x884C;&#x7684;&#x51FD;&#x6570;void* down_thread_function(void * args) { thread_arg *arg=(thread_arg*)args; HWND dhwnd=arg-&gt;arg_hwnd; while(true) { if(is_pause) { Sleep(300); continue; } move_down(dhwnd); Sleep(LONG_SLEEP); }}//&#x521D;&#x59CB;&#x5316;&#x5F62;&#x72B6;&#x4E0B;&#x843D;&#x8FDB;&#x7A0B;int init_down_thread(HWND hwnd) { int ret; pthread_t t; thread_arg *argp=new thread_arg; argp-&gt;arg_hwnd=hwnd; ret=pthread_create(&amp;t,NULL,down_thread_function,argp); delete argp; if(ret!=0) { return -1; } return 0;}//&#x521D;&#x59CB;&#x5316;&#x6E38;&#x620F;&#x7A0B;&#x5E8F;int init_game(HWND hwnd) { board=new int*[NN]; for(int i=0; i&lt;NN; i++) { board[i]=new int[MM]; } shape=new int*[4]; for(int i=0; i&lt;4; i++) { shape[i]=new int[4]; } srand(time(0)); if(load_shape()!=0) { MessageBox(hwnd,&quot;Read file error.Program will exit.&quot;,&quot;Error&quot;,NULL); exit(-1); } init_play(); update_UI_all(hwnd); if(init_down_thread(hwnd)!=0) { MessageBox(hwnd,&quot;Thread error.Program will exit.&quot;,&quot;Error&quot;,NULL); exit(-1); } return 0;}//&#x5F62;&#x72B6;&#x5DE6;&#x53F3;&#x79FB;&#x52A8;int move_lr(HWND hwnd,int lr) { int temp=column; if(lr==0)column--; else { column++; } if(!is_legel()) { column=temp; } update_UI(hwnd);}int handle_key(HWND hwnd,WPARAM wParam) { if(wParam==VK_ESCAPE) {//ESC&#x9000;&#x51FA; exit_game(hwnd); } if(wParam==VK_SPACE) {//&#x7A7A;&#x683C;&#x6682;&#x505C; is_pause=!is_pause; } if(is_pause==true) { Sleep(300); return 0; } if(wParam==VK_UP) { rotate_shape(hwnd); } if(wParam==VK_DOWN) { move_down(hwnd); } if(wParam==VK_LEFT) { move_lr(hwnd,0); } if(wParam==VK_RIGHT) { move_lr(hwnd,1); } return 0;}/* This function is called by the Windows function DispatchMessage() */HWND hwnd;LRESULT CALLBACK WindowProcedure (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) { static HDC hdc; static HDC hdcBuffer; static HBITMAP hBitMap; static PAINTSTRUCT ps ; switch (message) { /* handle the messages */ case WM_CREATE: init_game(hwnd); break; case WM_KEYDOWN: handle_key(hwnd,wParam); break; case WM_DESTROY: exit_game(hwnd); PostQuitMessage (0); /* send a WM_QUIT to the message queue */ break; case WM_PAINT: hdc = BeginPaint (hwnd, &amp;ps) ; paint_UI(hdc); EndPaint (hwnd, &amp;ps) ; break; default: /* for messages that we don&apos;t deal with */ return DefWindowProc (hwnd, message, wParam, lParam); } return 0;} &#x7A0B;&#x5E8F;&#x5199;&#x4E8E;2016&#x5E74;&#x4E94;&#x4E00;&#x671F;&#x95F4; &#x968F;&#x7B14;&#x5199;&#x4E8E;2016.5.8]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java迷宫游戏]]></title>
      <url>2016%2F05%2F08%2F%E8%BF%B7%E5%AE%AB%2F</url>
      <content type="text"><![CDATA[&#x7F18;&#x8D77;&#xFF1A;&#x3000;&#x3000;&#x53BB;&#x5E74;&#xFF08;&#x5927;&#x4E09;&#x4E0A;&#x5B66;&#x671F;&#xFF09;&#x6BD4;&#x8F83;&#x559C;&#x6B22;&#x5199;&#x5C0F;&#x6E38;&#x620F;&#xFF0C;&#x4E8E;&#x662F;&#x60F3;&#x8BD5;&#x7740;&#x5199;&#x4E2A;&#x8FF7;&#x5BAB;&#x8BD5;&#x4E00;&#x4E0B;&#x3002; &#x7A0B;&#x5E8F;&#x6548;&#x679C;&#xFF1A; &#x6309;&#x4E0B;&#x7A7A;&#x683C;&#x663E;&#x793A;&#x8DEF;&#x5F84;&#xFF1A; &#x601D;&#x8003;&#x8FC7;&#x7A0B;&#xFF1A;&#x3000;&#x3000;&#x8FF7;&#x5BAB;&#x7531;&#x4E00;&#x4E2A;&#x4E00;&#x4E2A;&#x683C;&#x5B50;&#x7EC4;&#x6210;&#xFF0C;&#x8981;&#x6C42;&#x4ECE;&#x5165;&#x53E3;&#x5230;&#x51FA;&#x53E3;&#x53EA;&#x6709;&#x4E00;&#x6761;&#x8DEF;&#x5F84;. &#x3000;&#x3000;&#x60F3;&#x4E86;&#x4E00;&#x4E0B;&#x5404;&#x79CD;&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF0C;&#x4F3C;&#x4E4E;&#x6811;&#x662F;&#x6BD4;&#x8F83;&#x5408;&#x9002;&#x7684;&#xFF0C;&#x4ECE;&#x6839;&#x8282;&#x70B9;&#x5230;&#x6BCF;&#x4E00;&#x4E2A;&#x5B50;&#x8282;&#x70B9;&#x90FD;&#x53EA;&#x6709;&#x4E00;&#x6761;&#x8DEF;&#x5F84;&#x3002;&#x5047;&#x8BBE;&#x5165;&#x53E3;&#x662F;&#x6839;&#x8282;&#x70B9;&#xFF0C;&#x51FA;&#x53E3;&#x662F;&#x6811;&#x4E2D;&#x67D0;&#x4E2A;&#x5B50;&#x8282;&#x70B9;&#xFF0C;&#x90A3;&#x4E48;&#xFF0C;&#x4ECE;&#x6839;&#x8282;&#x70B9;&#x5230;&#x8BE5;&#x5B50;&#x8282;&#x70B9;&#x7684;&#x8DEF;&#x5F84;&#x80AF;&#x5B9A;&#x662F;&#x552F;&#x4E00;&#x7684;&#x3002; &#x3000;&#x3000;&#x6240;&#x4EE5;&#x5982;&#x679C;&#x80FD;&#x6784;&#x9020;&#x4E00;&#x68F5;&#x6811;&#x628A;&#x6240;&#x6709;&#x7684;&#x683C;&#x5B50;&#x90FD;&#x8986;&#x76D6;&#x5230;&#xFF0C;&#x4E5F;&#x5C31;&#x80FD;&#x591F;&#x505A;&#x51FA;&#x4E00;&#x4E2A;&#x8FF7;&#x5BAB;&#x4E86;&#x3002; &#x3000;&#x3000;&#x53E6;&#x5916;&#x8FD8;&#x8981;&#x6C42;&#x6811;&#x7684;&#x7236;&#x8282;&#x70B9;&#x548C;&#x5B50;&#x8282;&#x70B9;&#x5FC5;&#x987B;&#x662F;&#x754C;&#x9762;&#x4E0A;&#x76F8;&#x90BB;&#x7684;&#x683C;&#x5B50;&#x3002; &#x3000;&#x3000;&#x5728;&#x754C;&#x9762;&#x663E;&#x793A;&#x65F6;&#xFF0C;&#x7236;&#x8282;&#x70B9;&#x548C;&#x5B50;&#x8282;&#x70B9;&#x4E4B;&#x95F4;&#x5171;&#x7528;&#x7684;&#x8FB9;&#x4E0D;&#x753B;&#xFF0C;&#x5176;&#x4ED6;&#x7684;&#x8FB9;&#x90FD;&#x753B;&#x51FA;&#x6765;&#xFF0C;&#x5C31;&#x80FD;&#x753B;&#x51FA;&#x4E00;&#x4E2A;&#x8FF7;&#x5BAB;&#x3002; &#x3000;&#x3000;&#x4E4B;&#x540E;&#x5C31;&#x662F;&#x60F3;&#x4E00;&#x4E0B;&#x8BE5;&#x600E;&#x4E48;&#x5B9E;&#x73B0;&#x8FD9;&#x6837;&#x4E00;&#x68F5;&#x6811;&#x3002; &#x9996;&#x8981;&#x7684;&#x4E24;&#x4E2A;&#x95EE;&#x9898;&#xFF1A; &#x6811;&#x600E;&#x4E48;&#x8868;&#x793A;&#xFF1F; &#x600E;&#x4E48;&#x6784;&#x9020;&#x8FD9;&#x68F5;&#x6811;&#xFF1F; &#x3000;&#x3000; 1.&#x6811;&#x600E;&#x4E48;&#x8868;&#x793A;&#xFF1F;&#x3000;&#x3000;&#x5047;&#x8BBE;&#x50CF;&#x5199;&#x4E8C;&#x53C9;&#x6811;&#x4E00;&#x6837;&#x5B9E;&#x73B0;&#x8FD9;&#x68F5;&#x6811;&#xFF0C;&#x90A3;&#x4E48;&#x6BCF;&#x4E2A;&#x6811;&#x8282;&#x70B9;&#x91CC;&#x5C31;&#x8981;&#x5B58;&#x50A8;&#x4E00;&#x4E2A;&#x5750;&#x6807;&#xFF08;X,Y&#xFF09;&#x8868;&#x793A;&#x4E00;&#x4E2A;&#x683C;&#x5B50;&#xFF0C;&#x53E6;&#x5916;&#x8FD8;&#x8981;&#x5B58;&#x50A8;&#x56DB;&#x4E2A;&#x6307;&#x9488;&#x3002;&#x6307;&#x9488;&#x4E2D;&#x6709;&#x7684;&#x4E3A;&#x7A7A;&#xFF0C;&#x6709;&#x7684;&#x4E0D;&#x4E3A;&#x7A7A;&#xFF0C;&#x4E0D;&#x4E3A;&#x7A7A;&#x7684;&#x6307;&#x9488;&#x6307;&#x5411;&#x5B50;&#x8282;&#x70B9;&#xFF0C;&#x5B50;&#x8282;&#x70B9;&#x4FDD;&#x5B58;&#x90BB;&#x5C45;&#x683C;&#x5B50;&#x7684;&#x5750;&#x6807;&#x3002;&#x8FD9;&#x6837;&#x505A;&#x6700;&#x5927;&#x7684;&#x95EE;&#x9898;&#x662F;&#x65E0;&#x6CD5;&#x5224;&#x5B9A;&#x662F;&#x5426;&#x6240;&#x6709;&#x7684;&#x683C;&#x5B50;&#x90FD;&#x5728;&#x6811;&#x4E2D;&#x3002;&#x4E5F;&#x8BB8;&#x8FD8;&#x8981;&#x7528;&#x4E00;&#x4E2A;&#x4E8C;&#x7EF4;&#x6570;&#x7EC4;&#x4F5C;&#x6807;&#x5FD7;&#x6570;&#x7EC4;&#x3002; &#x3000;&#x3000;&#x5047;&#x5982;&#x7528;&#x4E8C;&#x7EF4;&#x6570;&#x7EC4;&#x8868;&#x793A;&#x8FF7;&#x5BAB;&#x7684;&#x683C;&#x5B50;&#x3002;&#x6BCF;&#x4E2A;&#x6570;&#x7EC4;&#x5143;&#x7D20;&#x5B58;&#x50A8;&#x4E00;&#x4E2A;&#x6307;&#x5411;&#x7236;&#x8282;&#x70B9;&#x7684;&#x5F15;&#x7528;&#xFF0C;&#x8FD9;&#x6837;&#x4E5F;&#x53EF;&#x4EE5;&#x5F62;&#x6210;&#x4E00;&#x4E2A;&#x865A;&#x62DF;&#x7684;&#x6811;&#x3002;&#x4E8E;&#x662F;&#x5C31;&#x7528;&#x4E00;&#x4E2A;NN&#x7684;&#x4E8C;&#x7EF4;&#x6570;&#x7EC4;&#xFF0C;&#x8868;&#x793A;NN&#x4E2A;&#x683C;&#x5B50;&#xFF0C;&#x6BCF;&#x4E2A;&#x6570;&#x7EC4;&#x5143;&#x7D20;(Lattice)&#x4E2D;&#x6709;&#x4E00;&#x4E2A;&#x6307;&#x5411;&#x7236;&#x8282;&#x70B9;&#x7684;&#x5F15;&#x7528;(father)&#x3002;&#x53E6;&#x5916;&#xFF0C;&#x4E3A;&#x4E86;&#x80FD;&#x65B9;&#x4FBF;&#x7684;&#x83B7;&#x53D6;&#x683C;&#x5B50;&#x7684;&#x5750;&#x6807;&#xFF0C;&#x8FD8;&#x8981;&#x4FDD;&#x5B58;&#x5750;&#x6807;&#x4FE1;&#x606F;&#x3002; 2.&#x600E;&#x4E48;&#x6784;&#x9020;&#x8FD9;&#x68F5;&#x6811;&#xFF1F;&#x3000;&#x3000;&#x9996;&#x5148;&#x9009;&#x5B9A;&#x4E00;&#x4E2A;&#x683C;&#x5B50;&#x4F5C;&#x4E3A;&#x6839;&#x8282;&#x70B9;&#x3002;&#x4E3A;&#x4E86;&#x8BA9;&#x8FF7;&#x5BAB;&#x7684;&#x5F62;&#x72B6;&#x591F;&#x968F;&#x673A;&#xFF0C;&#x6211;&#x9009;&#x62E9;&#x968F;&#x673A;&#x751F;&#x6210;&#x4E00;&#x4E2A;&#x5750;&#x6807;&#x4F5C;&#x4E3A;&#x6839;&#x8282;&#x70B9;&#x3002;&#x5176;&#x5B9E;&#xFF0C;&#x9009;&#x62E9;&#x786E;&#x5B9A;&#x7684;&#x4E00;&#x4E2A;&#x5750;&#x6807;&#x4E5F;&#x53EF;&#x4EE5;&#x3002; &#x3000;&#x3000;&#x7136;&#x540E;&#xFF0C;&#x600E;&#x6837;&#x5F80;&#x8FD9;&#x68F5;&#x6811;&#x4E0A;&#x589E;&#x52A0;&#x8282;&#x70B9;&#x5462;&#xFF1F; &#x3000;&#x3000;&#x5728;&#x8FD9;&#x91CC;&#x6211;&#x8D70;&#x4E86;&#x4E0D;&#x5C11;&#x5F2F;&#x8DEF;&#xFF0C;&#x4E00;&#x5F00;&#x59CB;&#x60F3;&#x7684;&#x662F;&#x4E00;&#x79CD;&#x73B0;&#x5728;&#x770B;&#x6765;&#x7C7B;&#x4F3C;&#x56DE;&#x6EAF;&#x7684;&#x7B97;&#x6CD5;&#xFF08;&#x5F53;&#x65F6;&#x8FD8;&#x4E0D;&#x77E5;&#x9053;&#x56DE;&#x6EAF;&#x7B97;&#x6CD5;&#x3002;&#x3002;&#xFF09;&#xFF0C;&#x4F46;&#x662F;&#x65F6;&#x95F4;&#x590D;&#x6742;&#x5EA6;&#x5F88;&#x9AD8;&#xFF0C;&#x5927;&#x6982;&#x5F53;&#x8FF7;&#x5BAB;&#x4E3A;64*64&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x7B97;&#x6CD5;&#x5C31;&#x4E0D;&#x51FA;&#x7ED3;&#x679C;&#x4E86;&#x3002; &#x3000;&#x3000;&#x7136;&#x540E;&#xFF0C;&#x53C8;&#x4F7F;&#x7528;&#x4E86;&#x4E00;&#x79CD;&#x626B;&#x6DF1;&#x5EA6;&#x641C;&#x7D22;&#x4E5F;&#x662F;&#x56DE;&#x6EAF;&#x63CF;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x6BCF;&#x6B21;&#x626B;&#x63CF;&#x5728;&#x5F53;&#x524D;&#x6811;&#x4E2D;&#x627E;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#xFF0C;&#x770B;&#x5B83;&#x7684;&#x90BB;&#x5C45;&#x683C;&#x5B50;&#x662F;&#x5426;&#x5728;&#x6811;&#x4E2D;&#xFF0C;&#x5982;&#x679C;&#x8FD8;&#x6CA1;&#x5728;&#x6811;&#x4E2D;&#xFF0C;&#x5C31;&#x5C06;&#x8BE5;&#x90BB;&#x5C45;&#x683C;&#x5B50;&#x52A0;&#x5165;&#x6811;&#x4E2D;&#xFF0C;&#x5982;&#x679C;&#x5DF2;&#x5728;&#x6811;&#x4E2D;&#xFF0C;&#x5C31;&#x770B;&#x4E0B;&#x4E00;&#x4E2A;&#x90BB;&#x5C45;&#x683C;&#x5B50;&#xFF0C;&#x5982;&#x679C;&#x8BE5;&#x8282;&#x70B9;&#x6240;&#x6709;&#x90BB;&#x5C45;&#x683C;&#x5B50;&#x90FD;&#x5728;&#x6811;&#x4E2D;&#x4E86;&#xFF0C;&#x5C31;&#x627E;&#x4E0B;&#x4E00;&#x4E2A;&#x8282;&#x70B9;&#xFF0C;&#x7EE7;&#x7EED;&#x540C;&#x6837;&#x7684;&#x64CD;&#x4F5C;&#x3002;&#x53E6;&#x5916;&#x4E3A;&#x4E86;&#x8BA9;&#x8FF7;&#x5BAB;&#x751F;&#x6210;&#x7684;&#x968F;&#x673A;&#xFF0C;&#x626B;&#x63CF;&#x7684;&#x8D77;&#x59CB;&#x4F4D;&#x7F6E;&#x662F;&#x968F;&#x673A;&#x7684;&#x5C31;&#x53EF;&#x4EE5;&#x4E86;&#x3002;&#x4F46;&#x662F;&#xFF0C;&#x8BE5;&#x65B9;&#x6CD5;&#x751F;&#x6210;&#x7684;&#x8FF7;&#x5BAB;&#x4E2D;&#x7684;&#x8DEF;&#x5F84;&#x603B;&#x662F;&#x4E0D;&#x591F;&#x6DF1;&#xFF0C;&#x6CA1;&#x6709;&#x6211;&#x60F3;&#x8981;&#x7684;&#x66F2;&#x6298;&#x6DF1;&#x5165;&#x7684;&#x6548;&#x679C;&#x3002;&#x6BD5;&#x7ADF;&#x662F;&#x7C7B;&#x4F3C;&#x5E7F;&#x5EA6;&#x641C;&#x7D22;&#x7684;&#x65B9;&#x6CD5;&#x3002;&#x800C;&#x4E14;&#xFF0C;&#x8FD9;&#x6837;&#x505A;&#x603B;&#x8FD8;&#x50CF;&#x662F;&#x9760;&#x86EE;&#x529B;&#xFF0C;&#x7B97;&#x6CD5;&#x4E0D;&#x591F;&#x806A;&#x660E;&#x7B80;&#x6D01;&#x3002; &#x3000;&#x3000;&#x6700;&#x540E;&#xFF0C;&#x6211;&#x7EC8;&#x4E8E;&#x60F3;&#x5230;&#x4F7F;&#x7528;&#x6DF1;&#x5EA6;&#x641C;&#x7D22;&#x3002;&#x3002;&#x5927;&#x6982;&#x662F;&#x56E0;&#x4E3A;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x5DF2;&#x7ECF;&#x5B66;&#x8FC7;&#x4E86;&#x4E00;&#x5E74;&#xFF0C;&#x53C8;&#x6CA1;&#x592A;&#x7EC3;&#xFF0C;&#x5FD8;&#x4E86;&#x4E0D;&#x5C11;&#xFF0C;&#x6240;&#x4EE5;&#x4E00;&#x76F4;&#x6CA1;&#x60F3;&#x5230;&#x8FD9;&#x4E2A;&#x5E94;&#x8BE5;&#x7B2C;&#x4E00;&#x60F3;&#x5230;&#x7684;&#x65B9;&#x6CD5;&#x3002;&#x3002; &#x3000;&#x3000;&#x968F;&#x673A;&#x9009;&#x62E9;&#x4E00;&#x4E2A;&#x683C;&#x5B50;&#x4F5C;&#x4E3A;&#x6839;&#x8282;&#x70B9;&#xFF0C;&#x4ECE;&#x5B83;&#x5F00;&#x59CB;&#x968F;&#x673A;&#x5730;&#x6DF1;&#x5EA6;&#x641C;&#x7D22;&#x524D;&#x8FDB;&#xFF0C;&#x5F00;&#x51FA;&#x4E00;&#x6761;&#x8DEF;&#x6765;&#xFF0C;&#x76F4;&#x5230;&#x65E0;&#x8DEF;&#x53EF;&#x8D70;&#x4E86;&#xFF0C;&#x9000;&#x56DE;&#x4E00;&#x6B65;&#xFF0C;&#x6362;&#x53E6;&#x4E00;&#x6761;&#x8DEF;&#xFF0C;&#x518D;&#x8D70;&#x5230;&#x65E0;&#x8DEF;&#x53EF;&#x8D70;&#xFF0C;&#x56DE;&#x9000;&#x4E00;&#x6B65;&#xFF0C;&#x6362;&#x53E6;&#x4E00;&#x6761;&#x2026;&#x2026;&#x5982;&#x6B64;&#x5FAA;&#x73AF;&#x5F80;&#x590D;&#xFF0C;&#x76F4;&#x5230;&#x5B8C;&#x5168;&#x65E0;&#x8DEF;&#x53EF;&#x8D70;&#x3002;&#x3002;&#x3002;&#x5176;&#x5B9E;&#x4E5F;&#x8FD8;&#x662F;&#x56DE;&#x6EAF;&#x3002; &#x3000;&#x3000;&#x5728;&#x7A0B;&#x5E8F;&#x91CC;&#x5C31;&#x662F;&#x4EE5;&#x4E0B;&#x8FC7;&#x7A0B;&#xFF08;&#x8BE6;&#x89C1;&#x4EE3;&#x7801;&#x4E2D;&#x7684;createMaze()&#x51FD;&#x6570;&#xFF09;&#xFF1A; &#x968F;&#x673A;&#x9009;&#x62E9;&#x4E00;&#x4E2A;&#x683C;&#x5B50;&#x4F5C;&#x4E3A;&#x6839;&#x8282;&#x70B9;&#xFF0C;&#x5C06;&#x5B83;&#x538B;&#x8FDB;&#x6808;&#x91CC;&#x3002;&#x7136;&#x540E;&#x5728;&#x6808;&#x4E0D;&#x4E3A;&#x7A7A;&#x7684;&#x65F6;&#x5019;&#x6267;&#x884C;&#x4EE5;&#x4E0B;&#x5FAA;&#x73AF;&#xFF1A; &#x53D6;&#x51FA;&#x4E00;&#x4E2A;&#x683C;&#x5B50;&#xFF0C;&#x5C06;&#x5B83;&#x7684;INTREE&#x6807;&#x5FD7;&#x8BBE;&#x7F6E;&#x4E3A;1&#xFF0C;&#x7136;&#x540E;&#x5C06;&#x5B83;&#x7684;&#x6240;&#x6709;&#x4E0D;&#x5728;&#x6811;&#x4E2D;&#x7684;&#x90BB;&#x5C45;&#x683C;&#x5B50;&#x538B;&#x8FDB;&#x6808;&#x91CC;&#xFF08;&#x987A;&#x5E8F;&#x968F;&#x673A;&#xFF09;&#xFF0C;&#x5E76;&#x4E14;&#x8BA9;&#x8FD9;&#x4E9B;&#x90BB;&#x5C45;&#x683C;&#x5B50;&#x7684;father&#x6307;&#x5411;&#x8BE5;&#x683C;&#x5B50;&#x3002; &#x3000;&#x3000;&#x89E3;&#x51B3;&#x4E86;&#x8FD9;&#x4E24;&#x4E2A;&#x95EE;&#x9898;&#xFF0C;&#x5176;&#x4F59;&#x7684;&#x753B;&#x8FF7;&#x5BAB;&#x3001;&#x663E;&#x793A;&#x8DEF;&#x5F84;&#x3001;&#x5C0F;&#x7403;&#x79FB;&#x52A8;&#x4E5F;&#x5C31;&#x6BD4;&#x8F83;&#x7B80;&#x5355;&#x4E86;&#x3002; &#x4EE3;&#x7801;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281package maze;import java.awt.Color;import java.awt.Graphics;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.util.Random;import java.util.Stack;import javax.swing.JFrame;import javax.swing.JOptionPane;import javax.swing.JPanel;class Lattice { static final int INTREE = 1; static final int NOTINTREE = 0; private int x = -1; private int y = -1; private int flag = NOTINTREE; private Lattice father = null; public Lattice(int xx, int yy) { x = xx; y = yy; } public int getX() { return x; } public int getY() { return y; } public int getFlag() { return flag; } public Lattice getFather() { return father; } public void setFather(Lattice f) { father = f; } public void setFlag(int f) { flag = f; } public String toString() { return new String(&quot;(&quot; + x + &quot;,&quot; + y + &quot;)\n&quot;); }}public class Maze extends JPanel { private static final long serialVersionUID = -8300339045454852626L; private int NUM, width, padding;// width &#x6BCF;&#x4E2A;&#x683C;&#x5B50;&#x7684;&#x5BBD;&#x5EA6;&#x548C;&#x9AD8;&#x5EA6; private Lattice[][] maze; private int ballX, ballY; private boolean drawPath = false; Maze(int m, int wi, int p) { NUM = m; width = wi; padding = p; maze = new Lattice[NUM][NUM]; for (int i = 0; i &lt;= NUM - 1; i++) for (int j = 0; j &lt;= NUM - 1; j++) maze[i][j] = new Lattice(i, j); createMaze(); setKeyListener(); this.setFocusable(true); } private void init() { for (int i = 0; i &lt;= NUM - 1; i++) for (int j = 0; j &lt;= NUM - 1; j++) { maze[i][j].setFather(null); maze[i][j].setFlag(Lattice.NOTINTREE); } ballX = 0; ballY = 0; drawPath = false; createMaze(); // setKeyListener(); this.setFocusable(true); repaint(); } public int getCenterX(int x) { return padding + x * width + width / 2; } public int getCenterY(int y) { return padding + y * width + width / 2; } public int getCenterX(Lattice p) { return padding + p.getY() * width + width / 2; } public int getCenterY(Lattice p) { return padding + p.getX() * width + width / 2; } private void checkIsWin() { if (ballX == NUM - 1 &amp;&amp; ballY == NUM - 1) { JOptionPane.showMessageDialog(null, &quot;YOU WIN !&quot;, &quot;&#x4F60;&#x8D70;&#x51FA;&#x4E86;&#x8FF7;&#x5BAB;&#x3002;&quot;, JOptionPane.PLAIN_MESSAGE); init(); } } synchronized private void move(int c) { int tx = ballX, ty = ballY; // System.out.println(c); switch (c) { case KeyEvent.VK_LEFT : ty--; break; case KeyEvent.VK_RIGHT : ty++; break; case KeyEvent.VK_UP : tx--; break; case KeyEvent.VK_DOWN : tx++; break; case KeyEvent.VK_SPACE : if (drawPath == true) { drawPath = false; } else { drawPath = true; } break; default : } if (!isOutOfBorder(tx, ty) &amp;&amp; (maze[tx][ty].getFather() == maze[ballX][ballY] || maze[ballX][ballY].getFather() == maze[tx][ty])) { ballX = tx; ballY = ty; } } private void setKeyListener() { this.addKeyListener(new KeyAdapter() { public void keyPressed(KeyEvent e) { int c = e.getKeyCode(); move(c); repaint(); checkIsWin(); } }); } private boolean isOutOfBorder(Lattice p) { return isOutOfBorder(p.getX(), p.getY()); } private boolean isOutOfBorder(int x, int y) { return (x &gt; NUM - 1 || y &gt; NUM - 1 || x &lt; 0 || y &lt; 0) ? true : false; } private Lattice[] getNeis(Lattice p) { final int[] adds = {-1, 0, 1, 0, -1};// &#x987A;&#x5E8F;&#x4E3A;&#x4E0A;&#x53F3;&#x4E0B;&#x5DE6; if (isOutOfBorder(p)) { return null; } Lattice[] ps = new Lattice[4];// &#x987A;&#x5E8F;&#x4E3A;&#x4E0A;&#x53F3;&#x4E0B;&#x5DE6; int xt; int yt; for (int i = 0; i &lt;= 3; i++) { xt = p.getX() + adds[i]; yt = p.getY() + adds[i + 1]; if (isOutOfBorder(xt, yt)) continue; ps[i] = maze[xt][yt]; } return ps; } private void createMaze() { Random random = new Random(); int rx = Math.abs(random.nextInt()) % NUM; int ry = Math.abs(random.nextInt()) % NUM; Stack&lt;Lattice&gt; s = new Stack&lt;Lattice&gt;(); Lattice p = maze[rx][ry]; Lattice neis[] = null; s.push(p); while (!s.isEmpty()) { p = s.pop(); p.setFlag(Lattice.INTREE); neis = getNeis(p); int ran = Math.abs(random.nextInt()) % 4; for (int a = 0; a &lt;= 3; a++) { ran++; ran %= 4; if (neis[ran] == null || neis[ran].getFlag() == Lattice.INTREE) continue; s.push(neis[ran]); neis[ran].setFather(p); } } // changeFather(maze[0][0],null); } private void changeFather(Lattice p, Lattice f) { if (p.getFather() == null) { p.setFather(f); return; } else { changeFather(p.getFather(), p); } } private void clearFence(int i, int j, int fx, int fy, Graphics g) { int sx = padding + ((j &gt; fy ? j : fy) * width), sy = padding + ((i &gt; fx ? i : fx) * width), dx = (i == fx ? sx : sx + width), dy = (i == fx ? sy + width : sy); if (sx != dx) { sx++; dx--; } else { sy++; dy--; } g.drawLine(sx, sy, dx, dy); } protected void paintComponent(Graphics g) { super.paintComponent(g); for (int i = 0; i &lt;= NUM; i++) { g.drawLine(padding + i * width, padding, padding + i * width, padding + NUM * width); } for (int j = 0; j &lt;= NUM; j++) { g.drawLine(padding, padding + j * width, padding + NUM * width, padding + j * width); } g.setColor(this.getBackground()); for (int i = NUM - 1; i &gt;= 0; i--) { for (int j = NUM - 1; j &gt;= 0; j--) { Lattice f = maze[i][j].getFather(); if (f != null) { int fx = f.getX(), fy = f.getY(); clearFence(i, j, fx, fy, g); } } } g.drawLine(padding, padding + 1, padding, padding + width - 1); int last = padding + NUM * width; g.drawLine(last, last - 1, last, last - width + 1); g.setColor(Color.RED); g.fillOval(getCenterX(ballY) - width / 3, getCenterY(ballX) - width / 3, width / 2, width / 2); if (drawPath == true) drawPath(g); } private void drawPath(Graphics g) { Color PATH_COLOR = Color.ORANGE, BOTH_PATH_COLOR = Color.PINK; if (drawPath == true) g.setColor(PATH_COLOR); else g.setColor(this.getBackground()); Lattice p = maze[NUM - 1][NUM - 1]; while (p.getFather() != null) { p.setFlag(2); p = p.getFather(); } g.fillOval(getCenterX(p) - width / 3, getCenterY(p) - width / 3, width / 2, width / 2); p = maze[0][0]; while (p.getFather() != null) { if (p.getFlag() == 2) { p.setFlag(3); g.setColor(BOTH_PATH_COLOR); } g.drawLine(getCenterX(p), getCenterY(p), getCenterX(p.getFather()), getCenterY(p.getFather())); p = p.getFather(); } g.setColor(PATH_COLOR); p = maze[NUM - 1][NUM - 1]; while (p.getFather() != null) { if (p.getFlag() == 3) break; g.drawLine(getCenterX(p), getCenterY(p), getCenterX(p.getFather()), getCenterY(p.getFather())); p = p.getFather(); } } public static void main(String[] args) { final int n = 30, width = 600, padding = 20, LX = 200, LY = 100; JPanel p = new Maze(n, (width - padding - padding) / n, padding); JFrame frame = new JFrame(&quot;MAZE(&#x6309;&#x7A7A;&#x683C;&#x952E;&#x663E;&#x793A;&#x6216;&#x9690;&#x85CF;&#x8DEF;&#x5F84;)&quot;); frame.getContentPane().add(p); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(width + padding, width + padding + padding); frame.setLocation(LX, LY); frame.setVisible(true); }} &#x7A0B;&#x5E8F;&#x5B8C;&#x6210;&#x4E8E;&#x5927;&#x4E09;&#x4E0A;&#x5B66;&#x671F;&#x3002; &#x968F;&#x7B14;&#x5199;&#x4E8E;2016.5.8]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读文件错误]]></title>
      <url>2016%2F04%2F29%2F%E8%AF%BB%E6%96%87%E4%BB%B6%E9%94%99%E8%AF%AF%2F</url>
      <content type="text"><![CDATA[&#x4ECA;&#x5929;&#x60F3;&#x5199;&#x4E2A;&#x5C0F;&#x7A0B;&#x5E8F;&#xFF0C;&#x4F46;&#x4E00;&#x5F00;&#x59CB;&#x5C31;&#x4E0D;&#x987A;&#x5229;&#x3002; &#x60F3;&#x4ECE;&#x6587;&#x4EF6;&#x4E2D;&#x8BFB;&#x53D6;&#x6570;&#x636E;&#xFF0C;&#x4F46;&#x4F7F;&#x7528; fscanf &#xFF0C;&#x603B;&#x662F;&#x8BFB;&#x4E0D;&#x51FA;&#x4EFB;&#x4F55;&#x4FE1;&#x606F;&#x3002; &#x6700;&#x540E;&#x65E0;&#x5948;&#x4E86;&#xFF0C;&#x6539;&#x7528; fread &#x770B;&#x4E00;&#x4E0B;&#x80FD;&#x8BFB;&#x51FA;&#x4EC0;&#x4E48;&#x5185;&#x5BB9;&#xFF0C;&#x53D1;&#x73B0;&#x9664;&#x4E86;&#x5F00;&#x59CB;&#x51E0;&#x4E2A;&#x5B57;&#x7B26;&#x662F;&#x4E71;&#x7801;&#xFF0C;&#x4E4B;&#x540E;&#x8BFB;&#x53D6;&#x7684;&#x6570;&#x636E;&#x90FD;&#x662F;&#x6B63;&#x5E38;&#x7684;&#x3002; &#x8FD9;&#x4E2A;&#x73B0;&#x8C61;&#x6B63;&#x662F;&#x524D;&#x4E00;&#x6BB5;&#x65F6;&#x95F4;&#x9047;&#x5230;&#x8FC7;&#x7684;&#xFF0C;&#x56E0;&#x4E3A;&#x6587;&#x4EF6;&#x7F16;&#x7801;&#x662F; UTF-8 &#xFF0C;&#x6240;&#x4EE5;&#x65E0;&#x6CD5;&#x8BFB;&#x51FA;&#x6B63;&#x786E;&#x7684; ASCII &#x7801;&#x3002; &#x9A6C;&#x4E0A;&#x5C06;&#x6587;&#x4EF6;&#x91CD;&#x65B0;&#x4EE5; ANSI &#x683C;&#x5F0F;&#x7F16;&#x7801;&#x3002;&#x7A0B;&#x5E8F;&#x7ACB;&#x523B;&#x6B63;&#x5E38;&#x4E86;&#x3002; &#x4E4B;&#x6240;&#x4EE5;&#x6BCF;&#x6B21;&#x65B0;&#x5EFA;&#x4E00;&#x4E2A;&#x6587;&#x672C;&#x6587;&#x6863;&#x90FD;&#x662F; UTF-8 &#x7F16;&#x7801;&#xFF0C;&#x662F;&#x53BB;&#x5E74;&#x7F16;&#x5199;&#x7F51;&#x9875;&#x65F6;&#x8BBE;&#x7F6E;&#x7684;&#x3002;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在文件夹中 的指定类型文件中 查找字符串（CodeBlocks+GCC编译，控制台程序，仅能在Windows上运行）]]></title>
      <url>2016%2F04%2F15%2Ffindstr%2F</url>
      <content type="text"><![CDATA[&#x8BF4;&#x660E;&#xFF1A;&#x3000;&#x3000;&#x7A0B;&#x5E8F;&#x4F7F;&#x7528; io.h &#x4E2D;&#x7684;_findfirst &#x548C; _findnext &#x51FD;&#x6570;&#x904D;&#x5386;&#x6587;&#x4EF6;&#x5939;&#xFF0C;&#x6545;&#x800C;&#x7A0B;&#x5E8F;&#x53EA;&#x80FD;&#x5728; Windows &#x4E0B;&#x4F7F;&#x7528;&#x3002;&#x3000;&#x3000; &#x3000;&#x3000;&#x7A0B;&#x5E8F;&#x904D;&#x5386;&#x5F53;&#x524D;&#x6587;&#x4EF6;&#x5939;&#xFF0C;&#x5BF9;&#x5176;&#x4E2D;&#x7684;&#x6587;&#x4EF6;&#x5939;&#x6267;&#x884C;&#x9012;&#x5F52;&#x904D;&#x5386;&#x3002;&#x540C;&#x65F6;&#x68C0;&#x67E5;&#x904D;&#x5386;&#x5230;&#x7684;&#x6587;&#x4EF6;&#x662F;&#x5426;&#x5C5E;&#x4E8E;&#x6307;&#x5B9A;&#x7C7B;&#x578B;&#xFF0C;&#x5982;&#x679C;&#x662F;&#xFF0C;&#x5219;&#x5C06;&#x5728;&#x8BE5;&#x6587;&#x4EF6;&#x4E2D;&#x67E5;&#x627E;&#x6307;&#x5B9A;&#x5B57;&#x7B26;&#x4E32;&#x3002;&#x3000; &#x3000;&#x3000;&#x5728;&#x6587;&#x4EF6;&#x4E2D;&#x67E5;&#x627E;&#x5B57;&#x7B26;&#x4E32;&#x65F6;&#xFF0C;&#x5F00;&#x8F9F;&#x4E00;&#x4E2A;&#x4E0E;&#x6307;&#x5B9A;&#x5B57;&#x7B26;&#x4E32; text &#xFF08;&#x957F;&#x5EA6;&#x4E3A;len &#xFF09;&#x540C;&#x6837;&#x5927;&#x5C0F;&#x7684;&#x5B57;&#x7B26;&#x4E32;&#x6570;&#x7EC4; temp &#x3002;&#x6570;&#x7EC4;&#x4E0A;&#x6709;&#x4E24;&#x4E2A;&#x6307;&#x9488;&#xFF1A;&#x4E00;&#x4E2A;&#x662F;&#x5B57;&#x7B26;&#x4E32;&#x6BD4;&#x8F83;&#x7684;&#x5F00;&#x59CB;&#x4F4D;&#x7F6E; s &#xFF0C;&#x4E00;&#x4E2A;&#x662F;&#x65B0;&#x5B57;&#x7B26;&#x5199;&#x5165;&#x7684;&#x4F4D;&#x7F6E; d &#x3002;&#x6BCF;&#x4ECE;&#x6587;&#x4EF6;&#x4E2D;&#x8BFB;&#x5165;&#x4E00;&#x4E2A;&#x5B57;&#x7B26;&#xFF0C;&#x5C31;&#x5199;&#x5165; temp[d] &#xFF0C;&#x4E4B;&#x540E; temp &#x4ECE; s &#x5230; d &#x4E0E; text &#x4ECE; 0 &#x5230; len-1 &#x6BD4;&#x8F83;&#xFF0C;&#x4E4B;&#x540E;&#xFF0C; s &#x4E0E; d &#x5747;&#x540E;&#x79FB;&#x4E00;&#x4F4D;&#xFF0C;&#x518D;&#x7EE7;&#x7EED;&#x8BFB;&#x5165;&#x5B57;&#x7B26;&#xFF0C;&#x5199;&#x5165;&#xFF0C;&#x6BD4;&#x8F83;&#xFF0C;&#x540E;&#x79FB;&#x3002;&#x3002;&#x3002; &#x4EE3;&#x7801;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;string.h&gt;#include&lt;io.h&gt;using namespace std;vector&lt;char*&gt; types;char text[256];void ls_path(char * path);bool is_in_types(char* filename);void findtext(char * filename,char* text);void solve(char* name,struct _finddata_t *f) { if(strcmp(f-&gt;name,&quot;.&quot;)==0)return ; if(strcmp(f-&gt;name,&quot;..&quot;)==0)return ; char *fullpath=new char[256]; strcpy(fullpath,name); int len=strlen(name); fullpath[len-1]=&apos;\0&apos;; strcat(fullpath,f-&gt;name); if(f-&gt;attrib&amp;_A_SUBDIR) { strcat(fullpath,&quot;/*&quot;); ls_path(fullpath); } else { if(is_in_types(f-&gt;name)) { findtext(fullpath,text); } } delete fullpath;}void ls_path(char * path) { struct _finddata_t f; int p; char *name=new char[260]; strcpy(name,path); if((p=_findfirst(name, &amp;f))!=-1) { solve(name,&amp;f); while(_findnext(p, &amp;f)==0) { solve(name,&amp;f); } } delete name;}int strrncmp(char* a,const char* b,int n) {//&#x6BD4;&#x8F83;&#x4E24;&#x5B57;&#x7B26;&#x4E32;&#x7684;&#x6700;&#x540E;n&#x4E2A;&#x5B57;&#x7B26; int len=strlen(a); int j=0; for(int i=len-n; i&lt;=len-1; i++) { if(a[i]!=b[j])return false; j++; } return j==n?true:false;}bool is_in_types(char* filename) { for(int i=0; i&lt;types.size(); i++) { if(strrncmp(filename,types[i],strlen(types[i]))) { return true; } } return false;}bool cmp(const char* temp,const int len,const int s,const int d,const char* text) { int j=0; for(int i=s;; i++,i%=len) { if(temp[i]!=text[j])return false; if(i==d)break; j++; } return true;}void findtext(char * filename,char* text) { FILE *f=fopen(filename,&quot;r&quot;); char c; int linenum=0; int len=strlen(text); char* temp=new char[len]; int s=0,d=len-1; while(c=fgetc(f),c!=EOF) { temp[d]=c; if(cmp(temp,len,s,d,text))printf(&quot;&#x6587;&#x4EF6;&#x540D;: %s \n&#x884C;&#x53F7;: %d\n&quot;,filename,linenum+1); if(c==&apos;\n&apos;||c==&apos;\r&apos;||c==&apos;\r\n&apos;) { linenum++; } d++; d%=len; s++; s%=len; } delete temp; fclose(f);}int main() { printf(&quot;**************************************\n&quot;); printf(&quot;&#x672C;&#x7A0B;&#x5E8F;&#x5728;&#x5176;&#x6240;&#x5728;&#x6587;&#x4EF6;&#x5939;&#x4E2D;&#x67E5;&#x627E;&#x6307;&#x5B9A;&#x7C7B;&#x578B;&#x6587;&#x4EF6;\n&#x4E2D;&#x662F;&#x5426;&#x6709;&#x6307;&#x5B9A;&#x5B57;&#x7B26;&#x4E32;&#xFF0C;&#x5E76;&#x8F93;&#x51FA;&#x6240;&#x5728;&#x884C;&#x53F7;&#x3002;\n&quot;); printf(&quot; CopyRight: maxuewei2\n&quot;); printf(&quot;**************************************\n&quot;); while(true) { types.clear(); printf(&quot;\n&#x8BF7;&#x8F93;&#x5165;&#x8981;&#x67E5;&#x627E;&#x7684;&#x5B57;&#x7B26;&#x4E32;:\n&quot;); while(gets(text),strcmp(text,&quot;&quot;)==0); printf(&quot;&#x8BF7;&#x8F93;&#x5165;&#x6587;&#x4EF6;&#x7C7B;&#x578B;&#xFF0C;&#x5982;&#x2018;txt&#x2019;:(&#x6309;&#x4E24;&#x4E0B;ENTER&#x5F00;&#x59CB;&#x67E5;&#x627E;)\n&quot;); char t[30]; while(gets(t),strcmp(t,&quot;&quot;)!=0) { char* tt=new char[30]; strcpy(tt,&quot;.&quot;); strcat(tt,t); types.push_back(tt); } delete t; printf(&quot;&#x67E5;&#x627E;&#x7ED3;&#x679C;:\n&quot;); ls_path(&quot;*&quot;); } types.clear(); delete text; getchar(); return 0;} &#x8FD0;&#x884C;&#x6548;&#x679C;&#xFF1A; &#x7A0B;&#x5E8F;&#x5B8C;&#x6210;&#x4E8E;2016.4.15 &#x535A;&#x5BA2;&#x66F4;&#x65B0;&#x4E8E;2016.4.15]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flappy Bird (Java实现)]]></title>
      <url>2016%2F04%2F12%2FFlappyBird%2F</url>
      <content type="text"><![CDATA[&#x8FD0;&#x884C;&#x6548;&#x679C;&#xFF1A; &#x4EE3;&#x7801;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256package bird;import java.awt.Graphics;import java.awt.Image;import java.awt.Toolkit;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.Random;import javax.swing.JFrame;import javax.swing.JOptionPane;import javax.swing.JPanel;public class Bird extends JPanel { private final int WIDTH=288; private int HEIGHT=512+112;// Image img; private Image bg,land,pipe_up,pipe_down,bird,score_h,score_t,score_n; private int y=300,land_x=0,pipe_x=200,current_y=0,time=0,down=0,bg_x=0,t=0,score=0,yt=-1; private int a = 0, b = 0, c = 0; private int[] pipe_ys=new int[4]; private Image [] score_number=new Image[10]; private Random random; Bird(){ getBestScores() ; Toolkit tool = this.getToolkit(); bg= tool.getImage(&quot;images/bg_day.png&quot;); land=tool.getImage(&quot;images/land.png&quot;); pipe_up= tool.getImage(&quot;images/pipe_up.png&quot;); pipe_down= tool.getImage(&quot;images/pipe_down.png&quot;); bird= tool.getImage(&quot;images/bird0_01.png&quot;); random = new Random(); for(int i=0;i&lt;=9;i++){ score_number[i]= tool.getImage(&quot;images/number_score_0&quot;+i+&quot;.png&quot;); } init(); this.addKeyListener( new KeyAdapter() { public void keyPressed(KeyEvent e) { int c = e.getKeyCode(); //System.out.print(c); switch (c) { case KeyEvent.VK_LEFT : break; case KeyEvent.VK_RIGHT : break; case KeyEvent.VK_UP : System.exit(0); break; case KeyEvent.VK_DOWN : break; case KeyEvent.VK_SPACE : down=0; if(time&lt;=0)time=16; break; default : // System.out.print(&quot;hey&quot;); } } }); this.setFocusable(true); } void init(){ y=300; land_x=0; pipe_x=200; current_y=0; time=0; down=0; bg_x=0; t=0; score=0; yt=-1; for(int i=0;i&lt;=3;i++){ pipe_ys[i]=-1* Math.abs(random.nextInt()) % 150; } } public int get_Height(){return HEIGHT;} public int get_Width(){return WIDTH;} private void move(){ while(true){ moveImg(); try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } moveBird(); repaint(); check(); t++; } } private void moveBird(){ time--; if(t%1==0){if(time&gt;0){y-=4;}} if(time&lt;=-5&amp;&amp;y&lt;=512-37){if(t%3==0){down+=1;y+=down;}} } private void moveImg(){ bg_x--; if(bg_x&lt;-288)bg_x+=288; land_x-=1; if(land_x&lt;-20)land_x+=23; pipe_x-=1; if(pipe_x&lt;=-52){ pipe_x+=200; int ran = Math.abs(random.nextInt()) % 200; ran=-ran; pipe_ys[current_y]=ran; current_y++; current_y%=4; } } private void check(){ int temp=current_y; for(int i=0;i&lt;=3;i++){ if(80+34&gt;=pipe_x&amp;&amp;80&lt;=pipe_x+52){ if(yt!=current_y){score++;yt=current_y;} if(y&lt;=pipe_ys[temp]+320||y+25&gt;=pipe_ys[temp]+450){ gameOver(); init(); } } } } private int gameOver() { if (score &gt; a) { c = b; b = a; a = score; save(); //System.exit(0); } else if (score &gt; b) { c = b; b = score; save(); //System.exit(0); return 0; } else if (score &gt; c) { c = score; save(); //System.exit(0); return 0; } JOptionPane.showMessageDialog(null, &quot;GAME OVER!\n\nBEST SCORE:\n&quot;+a+&quot;\n&quot;+b+&quot;\n&quot;+c, &quot;&#x4F60;&#x6B7B;&#x4E86;(&#x6309;&#x4EFB;&#x610F;&#x952E;&#x518D;&#x6765;&#x4E00;&#x6B21;)&quot;, JOptionPane.PLAIN_MESSAGE); //System.exit(0); return 0; } private void getBestScores() { BufferedReader reader = null; try { reader = new BufferedReader(new FileReader(&quot;score.txt&quot;)); } catch (FileNotFoundException e) { e.printStackTrace(); } try { a = Integer.parseInt(reader.readLine()); b = Integer.parseInt(reader.readLine()); c = Integer.parseInt(reader.readLine()); } catch (NumberFormatException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } try { reader.close(); } catch (IOException e) { e.printStackTrace(); } /*String bestS = new String(&quot;Best Score: &quot; + new Integer(a).toString() + &quot; &quot; + new Integer(b).toString() + &quot; &quot; + new Integer(c).toString());*/ return ; } private int save() { BufferedWriter writer = null; try { writer = new BufferedWriter(new FileWriter(&quot;score.txt&quot;)); } catch (IOException e) { e.printStackTrace(); } String d = new Integer(a).toString(), e = new Integer(b).toString(), f = new Integer(c).toString(); try { writer.write(d); writer.newLine(); writer.write(e); writer.newLine(); writer.write(f); writer.flush(); writer.close(); } catch (NumberFormatException ev) { ev.printStackTrace(); } catch (IOException ev) { ev.printStackTrace(); } return 0; } private void showScore(Graphics g){ int score_h=score/100,score_t=score%100/10,score_n=score%10; if(score_h!=0){g.drawImage(score_number[score_h], 80,20,this);} g.drawImage(score_number[score_t], 80+20,20,this); g.drawImage(score_number[score_n], 80+20+20,20,this); } public void paint(Graphics g) {//Component super.paintComponent(g); //g.drawLine(x,y,200,200); g.drawImage(bg, bg_x,0,this); g.drawImage(bg, bg_x+288,0,this); //g.drawImage(land_1, landx_1, HEIGHT-land_1.getHeight(this), WIDTH,WIDTH*land_1.getHeight(this)/land_1.getWidth(this), this); int temp=current_y; for(int i=0;i&lt;=3;i++){ g.drawImage(pipe_down,pipe_x+i*200,pipe_ys[temp],this); g.drawImage(pipe_up,pipe_x+i*200,pipe_ys[temp]+450,this); g.drawImage(bird,80,y,this); temp++; temp%=4; } g.drawImage(land, land_x,512,this); showScore(g); } public static void main(String[] args) { JFrame frame = new JFrame(&quot;&#xFF08;&#x6309;UP&#x952E;&#x9000;&#x51FA;&#xFF09;&quot;); Bird b=new Bird(); frame.getContentPane() .add(b); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(b.get_Width(),b.get_Height()); frame.setLocation(200, 100); frame.setVisible(true); b.move(); }} &#x7D20;&#x6750;&#xFF1A;bg_day.png bird0_01.png land.png pipe_up.png pipe_down.png number_score_00.png~number_score_09.png (&#x6570;&#x5B57;&#x5747;&#x4E3A;&#x767D;&#x8272;&#xFF0C;&#x56FE;&#x7247;&#x80CC;&#x666F;&#x4E3A;&#x900F;&#x660E;&#x3002;&#x4E3A;&#x80FD;&#x591F;&#x5728;&#x535A;&#x5BA2;&#x4E2D;&#x663E;&#x793A;&#x51FA;&#x6765;&#xFF0C;&#x7279;&#x8BBE;&#x7F6E;&#x4E3A;&#x7070;&#x8272;&#x80CC;&#x666F;) &#x7A0B;&#x5E8F;&#x5199;&#x4E8E;&#x5927;&#x4E09;&#x4E0A;&#x5B66;&#x671F;&#x3002; 2016.4.12&#x66F4;&#x65B0;&#x535A;&#x5BA2;&#x3002;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[局域网象棋游戏（C++实现，使用Socket，界面使用Win32，CodeBlocks+GCC编译）]]></title>
      <url>2016%2F03%2F22%2F%E5%B1%80%E5%9F%9F%E7%BD%91%E8%B1%A1%E6%A3%8B%2F</url>
      <content type="text"><![CDATA[&#x76EE;&#x5F55; &#x6210;&#x679C; &#x8FD0;&#x884C;&#x6548;&#x679C;&#x56FE; &#x8FC7;&#x7A0B; 1. &#x9996;&#x5148;&#x7684;&#x95EE;&#x9898;&#x662F;&#x4E0B;&#x68CB;&#x7684;&#x4E24;&#x7AEF;&#x5E94;&#x8BE5;&#x662F;&#x4EC0;&#x4E48;&#x6837;&#x7684;&#xFF1F; 2. &#x63A5;&#x4E0B;&#x6765;&#x7684;&#x95EE;&#x9898;&#x662F;&#x600E;&#x4E48;&#x8868;&#x793A;&#xFF0C;&#x600E;&#x4E48;&#x5B58;&#x50A8;&#xFF1F; 3. &#x7136;&#x540E;&#x5E94;&#x8BE5;&#x600E;&#x4E48;&#x901A;&#x4FE1;&#x5462;&#xFF1F; &#x4EE3;&#x7801; main.cpp chinese_chess.h Server.h Client.h END &#x2002;&#x2002;&#x2002;&#x2002; &#x6210;&#x679C; &#x8FD0;&#x884C;&#x6548;&#x679C;&#x56FE; &#x3000;&#x3000;&#x5DE6;&#x8FB9;&#x662F;&#x5728;&#x865A;&#x62DF;&#x673A;&#x91CC;&#x8FD0;&#x884C;&#x7684;&#xFF0C;&#x53F3;&#x8FB9;&#x662F;&#x5728;Host&#x673A;&#x4E0A;&#x8FD0;&#x884C;&#x7684;&#x3002; &#x8FC7;&#x7A0B;&#x3000;&#x3000;&#x8BB0;&#x4E0D;&#x8D77;&#x81EA;&#x5DF1;&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x5199;&#x8FD9;&#x4E2A;&#x8C61;&#x68CB;&#x6E38;&#x620F;&#x7684;&#xFF0C;&#x5927;&#x6982;&#x662F;&#x56E0;&#x4E3A;&#x521A;&#x5B66;&#x4E86;&#x70B9;&#x513F;Socket &#xFF0C;&#x6240;&#x4EE5;&#x60F3;&#x7528;&#x7528;&#xFF0C;&#x4E8E;&#x662F;&#x5C31;&#x5199;&#x4E2A;&#x5C40;&#x57DF;&#x7F51;&#x5BF9;&#x6218;&#x7684;&#x8C61;&#x68CB;&#x5427;&#x3002;&#x3002;&#x3002; 1.&#x9996;&#x5148;&#x7684;&#x95EE;&#x9898;&#x662F;&#x4E0B;&#x68CB;&#x7684;&#x4E24;&#x7AEF;&#x5E94;&#x8BE5;&#x662F;&#x4EC0;&#x4E48;&#x6837;&#x7684;&#xFF1F; &#x3000;&#x3000;&#x6211;&#x5E0C;&#x671B;&#x4E0B;&#x68CB;&#x7684;&#x4E24;&#x4E2A;&#x4EBA;&#x4F7F;&#x7528;&#x76F8;&#x540C;&#x7684;&#x7A0B;&#x5E8F;&#x3002;&#x6240;&#x4EE5;&#x5C31;&#x4E0D;&#x80FD;&#x50CF;FTP&#x4E00;&#x6837;&#xFF0C;&#x4E00;&#x4E2A;&#x5BA2;&#x6237;&#x7AEF;&#xFF0C;&#x4E00;&#x4E2A;&#x670D;&#x52A1;&#x5668;&#x7AEF;&#xFF0C;&#x800C;&#x53EA;&#x80FD;&#x6BCF;&#x4E2A;&#x7A0B;&#x5E8F;&#x90FD;&#x662F;&#x4E00;&#x6837;&#x7684;&#xFF0C;&#x65E2;&#x662F;&#x5BA2;&#x6237;&#x7AEF;&#xFF08;Client&#xFF09;&#xFF0C;&#x53C8;&#x662F;&#x670D;&#x52A1;&#x5668;&#x7AEF;&#xFF08;Server&#xFF09;&#x3002;&#x5728;&#x901A;&#x4FE1;&#x65F6;&#xFF0C;&#x5DF1;&#x65B9;&#x7684;Client &#x5411;&#x5BF9;&#x65B9;&#x7684;Server &#x53D1;&#x9001;&#x4FE1;&#x606F;&#xFF0C;&#x5BF9;&#x65B9;&#x7684;Client &#x5411;&#x5DF1;&#x65B9;&#x7684;Server &#x53D1;&#x9001;&#x4FE1;&#x606F;&#x3002;&#x4E24;&#x7AEF;&#x90FD;&#x5B58;&#x50A8;&#x68CB;&#x76D8;&#x4FE1;&#x606F;&#xFF0C;&#x901A;&#x8FC7;&#x901A;&#x4FE1;&#x4FDD;&#x6301;&#x68CB;&#x76D8;&#x4FE1;&#x606F;&#x7684;&#x4E00;&#x81F4;&#x3002; &#x3000;&#x3000;&#x7136;&#x540E;&#x5462;&#xFF0C;&#x5E94;&#x8BE5;&#x662F;&#x4E00;&#x7AEF;&#x70B9;&#x51FB;&#x754C;&#x9762;&#x79FB;&#x5B50;&#x4E4B;&#x540E;&#xFF0C;&#x5E94;&#x8BE5;&#x80FD;&#x901A;&#x77E5;&#x5BF9;&#x65B9;&#x8FDB;&#x884C;&#x76F8;&#x540C;&#x7684;&#x79FB;&#x52A8;&#x3002; &#x3000;&#x3000;&#x7EFC;&#x5408;&#x4EE5;&#x4E0A;&#x4E24;&#x70B9;&#xFF0C;&#x8FD0;&#x884C;&#x8FC7;&#x7A0B;&#x5E94;&#x8BE5;&#x662F;&#x8FD9;&#x6837;&#x7684;&#xFF1A; &#x3000;&#x3000;&#x5F53;&#x5728;&#x754C;&#x9762;&#x4E0A;&#x70B9;&#x51FB;&#x68CB;&#x5B50;&#x65F6;&#xFF0C;&#x5148;&#x5224;&#x65AD;&#x5F53;&#x524D;&#x662F;&#x5426;&#x8F6E;&#x5230;&#x81EA;&#x5DF1;&#x843D;&#x5B50;&#xFF0C;&#x5982;&#x679C;&#x662F;&#xFF0C;&#x5219;&#x8FDB;&#x884C;&#x79FB;&#x52A8;&#xFF0C;&#x66F4;&#x65B0;&#x754C;&#x9762;&#xFF0C;&#x5E76;&#x901A;&#x8FC7;Client &#x5411;&#x5BF9;&#x65B9;Server &#x53D1;&#x9001;&#x79FB;&#x52A8;&#x4FE1;&#x606F;&#x3002;&#x5BF9;&#x65B9;Server &#x6536;&#x5230;&#x540E;&#xFF0C;&#x8FDB;&#x884C;&#x540C;&#x6837;&#x7684;&#x79FB;&#x52A8;&#xFF0C;&#x66F4;&#x65B0;&#x754C;&#x9762;&#x3002; &#x3000;&#x3000;&#x8FD9;&#x91CC;&#x8981;&#x6C42;Server&#x80FD;&#x968F;&#x65F6;&#x63A5;&#x5230;&#x5BF9;&#x65B9;&#x53D1;&#x6765;&#x7684;&#x6D88;&#x606F;&#xFF0C;&#x6240;&#x4EE5;Server&#x7684;&#x76D1;&#x542C;&#x5E94;&#x8BE5;&#x662F;&#x4E00;&#x4E2A;&#x989D;&#x5916;&#x7684;&#x7EBF;&#x7A0B;&#x3002; 2.&#x63A5;&#x4E0B;&#x6765;&#x7684;&#x95EE;&#x9898;&#x662F;&#x600E;&#x4E48;&#x8868;&#x793A;&#xFF0C;&#x600E;&#x4E48;&#x5B58;&#x50A8;&#xFF1F; &#x3000;&#x3000;&#x68CB;&#x76D8;&#xFF0C;&#x5E94;&#x8BE5;&#x7528;&#x4E8C;&#x7EF4;&#x6570;&#x7EC4;&#x5B58;&#x50A8;&#x6BD4;&#x8F83;&#x597D;&#xFF0C;&#x6570;&#x7EC4;&#x5750;&#x6807;&#xFF08;&#x4EE5;&#x4E0B;&#x6240;&#x8BF4;&#x7684;&#x201D;&#x6570;&#x7EC4;&#x5750;&#x6807; &#x201C;&#x662F;&#x6307;&#x8BE5;&#x4E8C;&#x7EF4;&#x6570;&#x7EC4;&#x4E2D;&#x7684;&#x4E00;&#x4E2A;(x,y)&#x6570;&#x5BF9;&#xFF09;&#x5BF9;&#x5E94;&#x68CB;&#x76D8;&#x5750;&#x6807;&#x3002;&#x90A3;&#x4E48;&#x6570;&#x7EC4;&#x91CC;&#x5B58;&#x50A8;&#x4EC0;&#x4E48;&#x5462;&#xFF0C;&#x4E00;&#x5171;&#x6709;&#x8ECA;&#x3001;&#x9A6C;&#x3001;&#x8C61;&#x3001;&#x58EB;&#x3001;&#x5C06;&#x3001;&#x7832;&#x3001;&#x5352;&#x4E03;&#x79CD;&#x68CB;&#x5B50;&#xFF0C;&#x90A3;&#x4E48;&#x8BBE;&#x7F6E;&#x4E00;&#x4E2A;&#x68CB;&#x5B50;&#x7C7B;&#x4F5C;&#x4E3A;&#x57FA;&#x7C7B;&#xFF0C;&#x7136;&#x540E;&#x8BBE;&#x7F6E;&#x4E03;&#x4E2A;&#x7C7B;&#x7EE7;&#x627F;&#x68CB;&#x5B50;&#x7C7B;&#xFF1F;&#x57FA;&#x7C7B;&#x6709;&#x4E00;&#x4E2A;move&#x51FD;&#x6570;&#xFF0C;&#x6BCF;&#x4E2A;&#x5B50;&#x7C7B;&#x91CD;&#x5199;&#x8BE5;&#x51FD;&#x6570;&#xFF1F;&#x4F46;&#x662F;&#x79FB;&#x52A8;&#x4F3C;&#x4E4E;&#x53EA;&#x662F;&#x6211;&#x7A0B;&#x5E8F;&#x7684;&#x4E00;&#x5C0F;&#x90E8;&#x5206;&#xFF0C;&#x8FD9;&#x6837;&#x4F3C;&#x4E4E;&#x6CA1;&#x5FC5;&#x8981;&#x3002; &#x3000;&#x3000;&#x90A3;&#x4E48;&#x5B58;&#x50A8;&#x6574;&#x578B;&#x6570;&#x503C;&#xFF1F;&#x4E0D;&#x540C;&#x7684;&#x6570;&#x503C;&#x4EE3;&#x8868;&#x4E0D;&#x540C;&#x7684;&#x68CB;&#x5B50;&#xFF1F;&#x4F3C;&#x4E4E;&#x53EF;&#x4EE5;&#x3002; &#x3000;&#x3000;&#x90A3;&#x4E48;&#x5C31;&#x7528;7&#x4E2A;&#x6570;&#x4EE3;&#x66FF;&#x4E03;&#x79CD;&#x68CB;&#x5B50;&#xFF0C;&#x4F46;&#x662F;&#x68CB;&#x5B50;&#x6709;&#x9ED1;&#x767D;&#x8272;&#xFF0C;&#x8981;&#x7528;&#x4E00;&#x4E2A;&#x6570;&#x8868;&#x793A;&#x68CB;&#x5B50;&#x7C7B;&#x578B;&#xFF08;&#x5373;&#x662F;&#x8ECA;&#x3001;&#x9A6C;&#x6216;&#x5176;&#x4ED6;&#xFF09;&#x548C;&#x68CB;&#x5B50;&#x989C;&#x8272;&#x4E24;&#x4E2A;&#x4FE1;&#x606F;&#xFF0C;&#x90A3;&#x5C31;&#x7528;BLANK =8&#x4EE3;&#x8868;&#x7A7A;&#x5B50;&#xFF0C;&#x9ED1;&#x65B9;&#x7684;&#x8ECA;&#x3001;&#x9A6C;&#x3001;&#x8C61;&#x3001;&#x58EB;&#x3001;&#x5C06;&#x3001;&#x7832;&#x3001;&#x5352;&#x5206;&#x522B;&#x4E3A;1&#x5230;7&#xFF0C;&#x767D;&#x65B9;&#x7684;&#x8ECA;&#x3001;&#x9A6C;&#x3001;&#x76F8;&#x3001;&#x58EB;&#x3001;&#x5E05;&#x3001;&#x70AE;&#x3001;&#x5175;&#x5206;&#x522B;&#x4E3A;9&#x5230;15&#x3002; &#x3000;&#x3000;&#x8FD9;&#x6837;&#x5224;&#x65AD;&#x67D0;&#x6570;&#x7EC4;&#x5750;&#x6807;&#x4E0A;&#x68CB;&#x5B50;&#x7684;&#x989C;&#x8272;&#xFF0C;&#x5C31;&#x628A;&#x5176;&#x503C;&#x4E0E;BLANK &#x6BD4;&#x8F83;&#xFF0C;&#x5927;&#x4E8E;BLANK&#x4E3A;&#x767D;&#x8272;&#xFF0C;&#x5426;&#x5219;&#x4E3A;&#x9ED1;&#x8272;&#x3002; &#x3000;&#x3000;&#x5224;&#x65AD;&#x67D0;&#x6570;&#x7EC4;&#x5750;&#x6807;&#x4E0A;&#x68CB;&#x5B50;&#x7684;&#x7C7B;&#x578B;&#xFF0C;&#x5219;&#x5C06;&#x5176;&#x503C;&#x6A21;BLANK &#x3002; &#x3000;&#x3000;&#x53E6;&#x5916;&#xFF0C;&#x56E0;&#x4E3A;&#x4E0B;&#x68CB;&#x53CC;&#x65B9;&#x7684;&#x89C6;&#x89D2;&#x662F;&#x76F8;&#x53CD;&#x7684;&#xFF0C;&#x6240;&#x4EE5;&#xFF0C;&#x68CB;&#x76D8;&#x5728;&#x5B58;&#x50A8;&#x65F6;&#x5E94;&#x8BE5;&#x662F;&#x76F8;&#x53CD;&#x7684;&#xFF0C;&#x79FB;&#x52A8;&#x65F6;&#x7684;&#x5750;&#x6807;&#x4E5F;&#x5E94;&#x8BE5;&#x8FDB;&#x884C;&#x8F6C;&#x6362;&#x3002; 3.&#x7136;&#x540E;&#x5E94;&#x8BE5;&#x600E;&#x4E48;&#x901A;&#x4FE1;&#x5462;&#xFF1F; &#x3000;&#x3000;&#x6211;&#x5E0C;&#x671B;&#x8FD9;&#x4E2A;&#x7A0B;&#x5E8F;&#x6253;&#x5F00;&#x540E;&#xFF0C;&#x5C31;&#x80FD;&#x627E;&#x5230;&#x5BF9;&#x65B9;&#xFF0C;&#x5E76;&#x786E;&#x5B9A;&#x8C01;&#x662F;&#x9ED1;&#x8272;&#xFF0C;&#x8C01;&#x662F;&#x767D;&#x8272;&#x3002; &#x3000;&#x3000;&#x4E5F;&#x8BB8;&#x53EF;&#x4EE5;&#x8BA9;Client &#x5728;&#x8FD0;&#x884C;&#x4E4B;&#x540E;&#x5C31;&#x5BF9;&#x5C40;&#x57DF;&#x7F51;&#x8FDB;&#x884C;&#x7AEF;&#x53E3;&#x626B;&#x63CF;&#xFF0C;&#x7136;&#x540E;&#x7ED9;&#x51FA;&#x6B63;&#x5728;&#x8FD0;&#x884C;&#x6B64;&#x7A0B;&#x5E8F;&#x7684;IP &#x5730;&#x5740;&#x5217;&#x8868;&#xFF0C;&#x8BA9;&#x7528;&#x6237;&#x9009;&#x62E9;&#x8981;&#x8FDE;&#x63A5;&#x5230;&#x54EA;&#x4E2A;&#xFF0C;&#x5982;&#x679C;&#x5BF9;&#x65B9;&#x5DF2;&#x7ECF;&#x6709;&#x4E86;&#x8FDE;&#x63A5;&#xFF0C;&#x5219;&#x5BF9;&#x65B9;&#x4F1A;&#x62D2;&#x7EDD;&#x6B64;&#x8FDE;&#x63A5;&#xFF0C;&#x5982;&#x679C;&#x5BF9;&#x65B9;&#x6CA1;&#x6709;&#x8FDE;&#x63A5;&#xFF0C;&#x5219;&#x5BF9;&#x65B9;&#x7A0B;&#x5E8F;&#x4F1A;&#x5411;&#x5BF9;&#x65B9;&#x7528;&#x6237;&#x63D0;&#x793A;&#x8BE5;&#x8FDE;&#x63A5;&#x8BF7;&#x6C42;&#xFF0C;&#x5982;&#x679C;&#xFF0C;&#x5BF9;&#x65B9;&#x7528;&#x6237;&#x540C;&#x610F;&#xFF0C;&#x5219;&#x8FDE;&#x63A5;&#x5EFA;&#x7ACB;&#xFF0C;&#x5426;&#x5219;&#x4F9D;&#x7136;&#x662F;&#x62D2;&#x7EDD;&#x6B64;&#x8FDE;&#x63A5;&#x3002; &#x3000;&#x3000;&#x4F46;&#x662F;&#xFF0C;&#x6211;&#x6CA1;&#x6709;&#x91C7;&#x7528;&#x4EE5;&#x4E0A;&#x6240;&#x8FF0;&#x65B9;&#x6CD5;&#xFF08;&#x56E0;&#x4E3A;&#x592A;&#x590D;&#x6742;&#xFF0C;&#x6211;&#x8FD8;&#x662F;&#x5148;&#x505A;&#x597D;&#x4E3B;&#x4F53;&#x5DE5;&#x4F5C;&#x5427;=_=&#xFF09; &#x3000;&#x3000;&#x6240;&#x4EE5;&#x5728;&#x7A0B;&#x5E8F;&#x5F00;&#x59CB;&#x8FD0;&#x884C;&#x540E;&#xFF0C;&#x4F1A;&#x8BA9;&#x7528;&#x6237;&#x8F93;&#x5165;&#x5BF9;&#x65B9;&#x7684;IP &#x5730;&#x5740;&#xFF0C;&#x7136;&#x540E;Server &#x5F00;&#x59CB;&#x76D1;&#x542C;&#x3002;&#x4E4B;&#x540E;Client &#x5F00;&#x59CB;&#x5411;&#x5BF9;&#x65B9;&#x53D1;&#x51FA;&#x8FDE;&#x63A5;&#x8BF7;&#x6C42;&#x3002; &#x3000;&#x3000;Server &#x76D1;&#x542C;&#x65F6;&#xFF0C;&#x5982;&#x679C;&#x6536;&#x5230;&#x8FDE;&#x63A5;&#x8BF7;&#x6C42;&#xFF0C;&#x5C31;&#x770B;&#x5BF9;&#x65B9;&#x7684;IP &#x5730;&#x5740;&#x662F;&#x5426;&#x662F;&#x7528;&#x6237;&#x8F93;&#x5165;&#x7684;IP &#x5730;&#x5740;&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x662F;&#xFF0C;&#x8BF4;&#x660E;&#x8FDE;&#x63A5;&#x8BF7;&#x6C42;&#x4E0D;&#x662F;&#x7528;&#x6237;&#x6240;&#x5E0C;&#x671B;&#x7684;&#x5BF9;&#x65B9;&#x53D1;&#x9001;&#x7684;&#xFF0C;&#x90A3;&#x5C31;&#x7EE7;&#x7EED;&#x76D1;&#x542C;&#x3002; &#x3000;&#x3000;Client &#x8BF7;&#x6C42;&#x8FDE;&#x63A5;&#x65F6;&#xFF0C;&#x5982;&#x679C;&#x5BF9;&#x65B9;&#x540C;&#x610F;&#x4E86;&#xFF0C;&#x5C31;&#x8981;&#x5F00;&#x59CB;&#x786E;&#x5B9A;&#x81EA;&#x5DF1;&#x7684;&#x989C;&#x8272;&#x4E86;&#x3002; &#x3000;&#x3000;&#x786E;&#x5B9A;&#x989C;&#x8272;&#x8FD9;&#x91CC;&#x56F0;&#x6270;&#x4E86;&#x6211;&#x5F88;&#x4E45;&#xFF0C;&#x6700;&#x540E;&#x91C7;&#x7528;&#x7684;&#x89E3;&#x51B3;&#x65B9;&#x6CD5;&#x662F;&#x8FD9;&#x6837;&#x7684;&#xFF1A; &#x6838;&#x5FC3;&#x601D;&#x60F3;&#x5C31;&#x662F;&#x8C01;&#x5148;&#x53D1;&#x51FA;&#x8FDE;&#x63A5;&#x8BF7;&#x6C42;&#xFF0C;&#x8C01;&#x5C31;&#x662F;&#x9ED1;&#x8272;&#x3002; &#x4E5F;&#x5C31;&#x662F;&#x5728;Client &#x8FDE;&#x63A5;&#x4E0A;&#x5BF9;&#x65B9;&#x4E4B;&#x540E;&#xFF0C;&#x8981;&#x5224;&#x65AD;Server &#x662F;&#x4E0D;&#x662F;&#x5DF2;&#x7ECF;&#x8FDE;&#x63A5;&#x4E86;&#x5BF9;&#x65B9;&#xFF0C;&#x5982;&#x679C;Server &#x5DF2;&#x8FDE;&#x63A5;&#xFF0C;&#x5C31;&#x8BF4;&#x660E;&#x662F;&#x5BF9;&#x65B9;&#x5148;&#x53D1;&#x51FA;&#x7684;&#x8FDE;&#x63A5;&#x8BF7;&#x6C42;&#xFF0C;&#x90A3;&#x4E48;&#x5BF9;&#x65B9;&#x5C31;&#x662F;&#x9ED1;&#x8272;&#xFF0C;&#x81EA;&#x5DF1;&#x5C31;&#x8BBE;&#x4E3A;&#x767D;&#x8272;&#x3002;&#x5982;&#x679C;Server &#x6CA1;&#x6709;&#x8FDE;&#x63A5;&#xFF0C;&#x5C31;&#x8BF4;&#x660E;&#x81EA;&#x5DF1;&#x5148;&#x8FDE;&#x63A5;&#x4E0A;&#x4E86;&#x5BF9;&#x65B9;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x81EA;&#x5DF1;&#x662F;&#x9ED1;&#x8272;&#x3002; &#x3000;&#x3000;&#x4EE5;&#x4E0A;&#x5C31;&#x662F;&#x7F16;&#x7801;&#x524D;&#x53CA;&#x7F16;&#x7801;&#x65F6;&#x7684;&#x5927;&#x81F4;&#x60F3;&#x6CD5;&#x3002; &#x4EE3;&#x7801; main.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341#if defined(UNICODE) &amp;&amp; !defined(_UNICODE)#define _UNICODE#elif defined(_UNICODE) &amp;&amp; !defined(UNICODE)#define UNICODE#endif#include &lt;tchar.h&gt;#include &lt;windows.h&gt;#include &lt;pthread.h&gt;#include &quot;chinese_chess.h&quot;#include &quot;Server.h&quot;#include &quot;Client.h&quot;#define WIDTH 400 //&#x754C;&#x9762;&#x5BBD;&#x5EA6;#define HEIGHT 400 //&#x754C;&#x9762;&#x9AD8;&#x5EA6;#define ZERO_X 50 //&#x68CB;&#x76D8;&#x5DE6;&#x8FB9;&#x754C;#define ZERO_Y 50 //&#x68CB;&#x76D8;&#x4E0A;&#x8FB9;&#x754C;#define PIECE_BKCOLOR RGB(175,143,89) //&#x68CB;&#x5B50;&#x80CC;&#x666F;&#x8272;#define PIECE_WH 30 //&#x68CB;&#x76D8;&#x6BCF;&#x4E2A;&#x683C;&#x5B50;&#x7684;&#x5BBD;&#x5EA6;&#x548C;&#x9AD8;&#x5EA6;HWND hwnd; /* This is the handle for our window */char* ots_ip; //&#x5B58;&#x50A8;&#x5BF9;&#x65B9;IP&#x5730;&#x5740;&#x7684;&#x5B57;&#x7B26;&#x4E32;int port;bool is_connect_alive=false; //&#x662F;&#x5426;&#x8FDE;&#x63A5;&#x5230;&#x5BF9;&#x65B9;Board * chess_board; //&#x68CB;&#x76D8;Server *server;Client *client;int chess_sx=-1; //&#x79FB;&#x52A8;&#x8D77;&#x59CB;&#x4F4D;&#x7F6E;&#x7684;&#x6570;&#x7EC4;&#x5750;&#x6807;int chess_sy=-1;int chess_dx=-1; //&#x79FB;&#x52A8;&#x76EE;&#x6807;&#x4F4D;&#x7F6E;&#x7684;&#x6570;&#x7EC4;&#x5750;&#x6807;int chess_dy=-1;/* Declare Windows procedure */LRESULT CALLBACK WindowProcedure (HWND, UINT, WPARAM, LPARAM);/* Make the class name into a global variable */TCHAR szClassName[ ] = _T(&quot;Chinese Chess&quot;);int WINAPI WinMain (HINSTANCE hThisInstance, HINSTANCE hPrevInstance, LPSTR lpszArgument, int nCmdShow) { MSG messages; /* Here messages to the application are saved */ WNDCLASSEX wincl; /* Data structure for the windowclass */ /* The Window structure */ wincl.hInstance = hThisInstance; wincl.lpszClassName = szClassName; wincl.lpfnWndProc = WindowProcedure; /* This function is called by windows */ wincl.style = CS_DBLCLKS; /* Catch double-clicks */ wincl.cbSize = sizeof (WNDCLASSEX); /* Use default icon and mouse-pointer */ wincl.hIcon = LoadIcon (NULL, IDI_APPLICATION); wincl.hIconSm = LoadIcon (NULL, IDI_APPLICATION); wincl.hCursor = LoadCursor (NULL, IDC_ARROW); wincl.lpszMenuName = NULL; /* No menu */ wincl.cbClsExtra = 0; /* No extra bytes after the window class */ wincl.cbWndExtra = 0; /* structure or the window instance */ /* Use Windows&apos;s default colour as the background of the window */ wincl.hbrBackground = (HBRUSH) COLOR_BACKGROUND; /* Register the window class, and if it fails quit the program */ if (!RegisterClassEx (&amp;wincl)) return 0; /* The class is registered, let&apos;s create the program*/ hwnd = CreateWindowEx ( 0, /* Extended possibilites for variation */ szClassName, /* Classname */ _T(&quot;Chinese Chess&quot;), /* Title Text */ WS_OVERLAPPEDWINDOW, /* default window */ CW_USEDEFAULT, /* Windows decides the position */ CW_USEDEFAULT, /* where the window ends up on the screen */ WIDTH, /* The programs width */ HEIGHT, /* and height in pixels */ HWND_DESKTOP, /* The window is a child-window to desktop */ NULL, /* No menu */ hThisInstance, /* Program Instance handler */ NULL /* No Window Creation data */ ); /* Make the window visible on the screen */ ShowWindow (hwnd, nCmdShow); /* Run the message loop. It will run until GetMessage() returns 0 */ while (GetMessage (&amp;messages, NULL, 0, 0)) { /* Translate virtual-key messages into character messages */ TranslateMessage(&amp;messages); /* Send message to WindowProcedure */ DispatchMessage(&amp;messages); } /* The program return-value is 0 - The value that PostQuitMessage() gave */ return messages.wParam;}//&#x628A;&#x6570;&#x7EC4;&#x5750;&#x6807;&#x8F6C;&#x6362;&#x4E3A;&#x754C;&#x9762;&#x5750;&#x6807;void xy_to_pixel(int x,int y,int*pixelx,int *pixely) { *pixely=x*PIECE_WH+ZERO_Y; *pixelx=y*PIECE_WH+ZERO_X;}//&#x628A;&#x754C;&#x9762;&#x5750;&#x6807;&#x8F6C;&#x6362;&#x4E3A;&#x6570;&#x7EC4;&#x5750;&#x6807;void pixel_to_xy(int pixelx,int pixely,int*x,int *y) { int r=PIECE_WH/2; *y=(pixelx-(ZERO_X-r))/PIECE_WH; *x=(pixely-(ZERO_Y-r))/PIECE_WH;}//&#x4EE5;&#x6570;&#x7EC4;&#x5750;&#x6807;&#x753B;&#x7EBF;void draw_line(HDC hdc,int sx,int sy,int dx,int dy) { int psx,psy,pdx,pdy; xy_to_pixel(sx,sy,&amp;psx,&amp;psy); xy_to_pixel(dx,dy,&amp;pdx,&amp;pdy); MoveToEx (hdc, psx,psy, NULL) ; LineTo (hdc, pdx, pdy) ;}//&#x4EE5;&#x6570;&#x7EC4;&#x5750;&#x6807;&#x753B;&#x68CB;&#x5B50;void paint_piece(HDC hdc,int x,int y,int color,int type) { static HBRUSH piece_brush =CreateSolidBrush (PIECE_BKCOLOR); //&#x68CB;&#x5B50;&#x7684;&#x80CC;&#x666F;&#x8272; if(type==0||color==BLANK)return ; int px,py; xy_to_pixel(x,y,&amp;px,&amp;py); int r=PIECE_WH/2; SelectObject (hdc,piece_brush ) ; Ellipse(hdc,px-r,py-r,px+r,py+r); char *text=new char[5]; switch(type) { case JU: strcpy(text,&quot;&#x8ECA;&quot;); break; case MA: strcpy(text,&quot;&#x9A6C;&quot;); break; case XIANG: if(color==BLACK)strcpy(text,&quot;&#x8C61;&quot;); else strcpy(text,&quot;&#x76F8;&quot;); break; case SHI: strcpy(text,&quot;&#x58EB;&quot;); break; case JIANG: if(color==BLACK)strcpy(text,&quot;&#x5C06;&quot;); else strcpy(text,&quot;&#x5E05;&quot;); break; case PAO: if(color==BLACK)strcpy(text,&quot;&#x7832;&quot;); else strcpy(text,&quot;&#x70AE;&quot;); break; case ZU: if(color==BLACK)strcpy(text,&quot;&#x5352;&quot;); else strcpy(text,&quot;&#x5175;&quot;); break; default: strcpy(text,&quot;&quot;); } SetBkColor(hdc,PIECE_BKCOLOR);//&#x8BBE;&#x7F6E;&#x6587;&#x5B57;&#x80CC;&#x666F;&#x8272; if(color==BLACK) { SetTextColor(hdc,RGB(0,0,0)); //&#x8BBE;&#x7F6E;&#x6587;&#x5B57;&#x989C;&#x8272; } else { SetTextColor(hdc,RGB(255,255,255)); } TextOut (hdc, px-r/2, py-r/2,text , strlen(&quot;&#x9A6C;&quot;)) ; delete text;}void* main_listen(void *) { server-&gt;listen_message(); return 0;}//&#x521B;&#x5EFA;&#x7EBF;&#x7A0B;&#xFF0C;&#x4F7F;server&#x5F00;&#x59CB;&#x76D1;&#x542C;bool start_listen() { pthread_t listen_p; int ret; ret= pthread_create( &amp;listen_p, NULL, main_listen,NULL ); // if( ret != 0 ) { //&#x521B;&#x5EFA;&#x7EBF;&#x7A0B;&#x6210;&#x529F;&#x8FD4;&#x56DE;0 //printf(&quot;pthread_create error:error_code=%d\n&quot;,ret ); handle_error(THREAD_ERROR,true,true); return false; } return true;}void* chess_connect(void *) { server=new Server();//&#x521B;&#x5EFA;Server&#x5BF9;&#x8C61; client=new Client(); //&#x521B;&#x5EFA;Client&#x5BF9;&#x8C61;&#xFF0C; start_listen(); //&#x521B;&#x5EFA;&#x7EBF;&#x7A0B;&#xFF0C;server&#x5F00;&#x59CB;&#x76D1;&#x542C; //Sleep(100); client-&gt;connect_to_ots(); //client&#x5F00;&#x59CB;&#x8FDE;&#x63A5;&#x5BF9;&#x65B9;server&#xFF0C;&#x8FDE;&#x63A5;&#x6210;&#x529F;&#x540E;&#x8FD4;&#x56DE; InvalidateRect(hwnd,NULL,true);}void init() { pthread_t connect_p; int ret; ret= pthread_create( &amp;connect_p, NULL, chess_connect,NULL); // if( ret != 0 ) { //&#x521B;&#x5EFA;&#x7EBF;&#x7A0B;&#x6210;&#x529F;&#x8FD4;&#x56DE;0 //printf(&quot;pthread_create error:error_code=%d\n&quot;,ret ); handle_error(THREAD_ERROR,true,true); return ; }}/* This function is called by the Windows function DispatchMessage() */LRESULT CALLBACK WindowProcedure (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) { static POINT mouse; static HDC hdc; static PAINTSTRUCT ps ; static int iofip=0; //index of ots_ip switch (message) { /* handle the messages */ case WM_CREATE: { port=35536; ots_ip=new char[20]; strcpy(ots_ip,&quot;&quot;); } break; case WM_KEYDOWN://&#x8BC6;&#x522B;&#x6309;&#x952E;&#xFF0C;&#x663E;&#x793A;&#x8F93;&#x5165;&#x7684;&#x5185;&#x5BB9;&#xFF08;&#x5BF9;&#x65B9;IP&#x5730;&#x5740;&#xFF09; if(wParam==13) {//&#x5982;&#x679C;&#x662F;ENTER&#xFF0C;&#x5219;&#x521D;&#x59CB;&#x5316;server&#x3001;client&#xFF0C;&#x5E76;&#x5F00;&#x59CB;&#x8FDE;&#x63A5;&#xFF0C;&#x8FDE;&#x63A5;&#x6210;&#x529F;&#x540E;&#x521D;&#x59CB;&#x5316;board init(); Sleep(100); InvalidateRect(hwnd,NULL,true); } if(wParam==VK_BACK) {//&#x5220;&#x9664;&#x952E; if(iofip==0)return 0; iofip--; ots_ip[iofip]=&apos;\0&apos;; } if(wParam&lt;106&amp;&amp;wParam&gt;95) {//&#x5C0F;&#x952E;&#x76D8;&#x6570;&#x5B57;&#x952E; wParam-=48; } if(wParam&lt;58&amp;&amp;wParam&gt;47) {//&#x4E3B;&#x952E;&#x76D8;&#x6570;&#x5B57;&#x952E; ots_ip[iofip]=&apos;0&apos;-48+wParam; iofip++; ots_ip[iofip]=&apos;\0&apos;; } if(wParam==110||wParam==229) {//&#x5C0F;&#x6570;&#x70B9;&#x952E;&#xFF0C;&#x5C0F;&#x952E;&#x76D8;110&#xFF0C;&#x4E3B;&#x952E;&#x76D8;229 ots_ip[iofip]=&apos;.&apos;; iofip++; ots_ip[iofip]=&apos;\0&apos;; } InvalidateRect(hwnd,NULL,true); break; case WM_PAINT: { hdc=BeginPaint (hwnd,&amp;ps) ; SetBkColor(hdc,RGB(200,200,200)); if(chess_board==NULL) {//&#x663E;&#x793A;&#x8F93;&#x5165;&#x7684;IP&#x5730;&#x5740; char tip[20]=&quot;&#x8BF7;&#x8F93;&#x5165;&#x5BF9;&#x65B9;IP&#x5730;&#x5740;&#xFF1A;&quot;; Rectangle(hdc,WIDTH/5-20,HEIGHT/2-10,WIDTH/5*4,HEIGHT/2+20); TextOut(hdc,WIDTH/5,HEIGHT/2-50,tip,strlen(tip)); TextOut(hdc,WIDTH/5,HEIGHT/2,ots_ip,strlen(ots_ip)); if(server!=NULL) { //board==NULL&#x800C;server!=NULL&#x8868;&#x793A;&#x6B63;&#x5728;&#x8FDE;&#x63A5;&#x8FC7;&#x7A0B;&#x4E2D; char tip[20]=&quot;&#x6B63;&#x5728;&#x8FDE;&#x63A5;......&quot;; TextOut(hdc,WIDTH/5,HEIGHT/2+50,tip,strlen(tip)); } EndPaint(hwnd,&amp;ps); break; } char text[10]=&quot;&#x4F60;&#x7684;&#x989C;&#x8272;:&quot;; if(chess_board-&gt;get_color()==BLACK) { strcat(text,&quot; &#x9ED1;&quot;); } else { strcat(text,&quot; &#x767D;&quot;); } TextOut (hdc, 0, 0,text , strlen(text)) ; int M=chess_board-&gt;get_M(); int N=chess_board-&gt;get_N(); //&#x753B;&#x68CB;&#x76D8; for(int i=0; i&lt;M; i++) { draw_line(hdc,i,0,i,N-1); } for(int i=0; i&lt;N; i++) { draw_line(hdc,0,i,N/2,i); } for(int i=0; i&lt;N; i++) { draw_line(hdc,N/2+1,i,N,i); } draw_line(hdc,0,3,2,5); draw_line(hdc,0,5,2,3); draw_line(hdc,9,3,7,5); draw_line(hdc,7,3,9,5); draw_line(hdc,4,0,5,0); draw_line(hdc,4,8,5,8); //&#x753B;&#x68CB;&#x5B50; for(int i=0; i&lt;M; i++) { for(int j=0; j&lt;N; j++) { paint_piece(hdc,i,j,chess_board-&gt;get_color(i,j),chess_board-&gt;get_type(i,j)); } } EndPaint(hwnd,&amp;ps); } break; case WM_LBUTTONUP: { if(chess_board==NULL)break; if(!chess_board-&gt;is_my_turn())break;//&#x5F53;&#x524D;&#x6CA1;&#x8F6E;&#x5230;&#x81EA;&#x5DF1;&#x4E0B;&#x68CB; GetCursorPos(&amp;mouse);//&#x83B7;&#x53D6;&#x9F20;&#x6807;&#x7684;&#x5C4F;&#x5E55;&#x5750;&#x6807; ScreenToClient(hwnd,&amp;mouse);//&#x8F6C;&#x6362;&#x4E3A;&#x754C;&#x9762;&#x5750;&#x6807; int x,y; pixel_to_xy(mouse.x,mouse.y,&amp;x,&amp;y);//&#x8F6C;&#x6362;&#x4E3A;&#x6570;&#x7EC4;&#x5750;&#x6807; if(chess_board-&gt;get_color(x,y)==chess_board-&gt;get_color()) {//&#x70B9;&#x51FB;&#x7684;&#x662F;&#x81EA;&#x5DF1;&#x7684;&#x68CB;&#x5B50; chess_sx=x; chess_sy=y; break; } if(chess_sx==-1||chess_sy==-1) {//&#x8D77;&#x59CB;&#x5750;&#x6807;&#x672A;&#x8D4B;&#x503C;&#x4E14;&#x70B9;&#x51FB;&#x7684;&#x4E0D;&#x662F;&#x81EA;&#x5DF1;&#x7684;&#x68CB;&#x5B50;&#xFF0C;&#x5219;break break; } chess_dx=x; chess_dy=y; if(chess_board-&gt;my_move_piece(chess_sx,chess_sy,chess_dx,chess_dy)) { //&#x5982;&#x679C;&#x79FB;&#x52A8;&#x68CB;&#x5B50;&#x5408;&#x6CD5; client-&gt;send_message(&quot;move&quot;,chess_sx,chess_sy,chess_dx,chess_dy); //&#x5411;&#x5BF9;&#x65B9;&#x53D1;&#x9001;&#x79FB;&#x5B50;&#x4FE1;&#x606F; InvalidateRect(hwnd,NULL,true); if(chess_board-&gt;get_is_win()==WIN) { chess_board-&gt;init();//&#x91CD;&#x65B0;&#x521D;&#x59CB;&#x5316;&#x68CB;&#x76D8;&#xFF0C;&#x91CD;&#x4E0B;&#x4E00;&#x76D8; MessageBox(hwnd,&quot;&#x4F60;&#x8D62;&#x4E86;&quot;,&quot;&#x83B7;&#x80DC;&#xFF01;&quot;,NULL); InvalidateRect(hwnd,NULL,true); } } chess_sx=-1; chess_sy=-1; break; } case WM_DESTROY: if(server!=NULL)server-&gt;close(); if(client!=NULL)client-&gt;close(); PostQuitMessage (0); /* send a WM_QUIT to the message queue */ break; default: /* for messages that we don&apos;t deal with */ return DefWindowProc (hwnd, message, wParam, lParam); } return 0;} chinese_chess.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250#ifndef CHINESE_CHESS_H_INCLUDED#define CHINESE_CHESS_H_INCLUDED#define JU 1#define MA 2#define XIANG 3#define SHI 4#define JIANG 5#define PAO 6#define ZU 7#define BLANK 8 //&#x7A7A;&#x5B50;#define BLACK -1#define WHITE 1#define WIN 1#define LOSE -1class Board {private: bool turn; //&#x662F;&#x5426;&#x8F6E;&#x5230;&#x81EA;&#x5DF1;&#x4E0B;&#x68CB; int color; //&#x81EA;&#x5DF1;&#x7684;&#x989C;&#x8272; int M,N; //&#x68CB;&#x76D8;&#x884C;&#x6570;&#x3001;&#x5217;&#x6570; int **b; //&#x4E8C;&#x7EF4;&#x6570;&#x7EC4; int is_win; //&#x662F;&#x5426;&#x80DC;&#x5229; bool is_out(int x,int y) {//&#x5750;&#x6807;&#x662F;&#x5426;&#x51FA;&#x754C; return x&gt;M||y&gt;N||x&lt;0||y&lt;0; } bool is_same_color(int sx,int sy,int dx,int dy) {//&#x6E90;&#x5750;&#x6807;&#x4E0E;&#x76EE;&#x7684;&#x5750;&#x6807;&#x662F;&#x5426;&#x662F;&#x540C;&#x4E00;&#x989C;&#x8272; return get_color(sx,sy)==get_color(dx,dy); } void swap_num(int &amp; num1,int&amp; num2) {//&#x4EA4;&#x6362;&#x4E24;&#x4E2A;&#x6570; num1+=num2; num2=num1-num2; num1=num1-num2; } int get_abs(int num) {//&#x53D6;&#x5F97;&#x7EDD;&#x5BF9;&#x503C; return num&gt;=0?num:-num; } int num_of_not_blank_betweenn(int sx,int sy,int dx,int dy) {//&#x8FD4;&#x56DE;&#x5728;&#x8D77;&#x59CB;&#x5750;&#x6807;&#x548C;&#x76EE;&#x7684;&#x5750;&#x6807;&#x4E4B;&#x95F4;&#x68CB;&#x5B50;&#x7684;&#x4E2A;&#x6570; if(!(sx==dx||sy==dy))return -1; int num=0; if(sy&gt;dy)swap_num(sy,dy); if(sx&gt;dx)swap_num(sx,dx); if(sx==dx) { for(int i=sy+1; i&lt;dy; i++) { if(b[sx][i]!=BLANK)num++; } } if(sy==dy) { for(int i=sx+1; i&lt;dx; i++) { if(b[i][sy]!=BLANK)num++; } } return num; } bool is_correct_move_JU(int sx,int sy,int dx,int dy) { return num_of_not_blank_betweenn(sx,sy,dx,dy)==0; } bool is_correct_move_MA(int sx,int sy,int dx,int dy) { int x=dx-sx,y=dy-sy; if(get_abs(x)==2&amp;&amp;get_abs(y)==1) { if(get_color(sx+x/2,sy)==BLANK)return true;//&#x784C;&#x9A6C;&#x8E44;&#x68C0;&#x6D4B; } if(get_abs(x)==1&amp;&amp;get_abs(y)==2) { if(get_color(sx,sy+y/2)==BLANK)return true;//&#x784C;&#x9A6C;&#x8E44;&#x68C0;&#x6D4B; } return false; } bool is_correct_move_XIANG(int sx,int sy,int dx,int dy) { int x=dx-sx,y=dy-sy; if(!(get_abs(x)==2&amp;&amp;get_abs(y)==2)) return false; if(get_color(sx+x/2,sy+y/2)==BLANK)return true;//&#x784C;&#x8C61;&#x8E44;&#x68C0;&#x6D4B; return false; } bool is_correct_move_SHI(int sx,int sy,int dx,int dy) { int x=dx-sx,y=dy-sy; if(!(get_abs(x)==1&amp;&amp;get_abs(y)==1)) return false; if(dx&lt;7)return false; if(dy&lt;3||dy&gt;5)return false; return true; } bool is_correct_move_JIANG(int sx,int sy,int dx,int dy) { int x=dx-sx,y=dy-sy; if(!((get_abs(x)==1&amp;&amp;get_abs(y)==0)||(get_abs(x)==0&amp;&amp;get_abs(y)==1))) return false; if(dx&lt;7)return false; if(dy&lt;3||dy&gt;5)return false; for(int i=0; i&lt;3; i++) {//&#x660E;&#x5C06;&#x68C0;&#x6D4B; if(get_type(i,dy)==JIANG) { if(num_of_not_blank_betweenn(dx,dy,i,dy)==0) return false; return true; } } return true; } bool is_correct_move_PAO(int sx,int sy,int dx,int dy) { int n=get_color(dx,dy)==BLANK?0:1; return num_of_not_blank_betweenn(sx,sy,dx,dy)==n; } bool is_correct_move_ZU(int sx,int sy,int dx,int dy) { if(dx&gt;sx)return false; int x=dx-sx,y=dy-sy; if(get_abs(x)+get_abs(y)!=1)return false; if(sx&gt;4&amp;&amp;get_abs(x)!=1)return false;//&#x8FC7;&#x6CB3;&#x524D;&#x53EA;&#x80FD;&#x5411;&#x524D;&#x8D70; return true; } bool is_correct_move(int sx,int sy,int dx,int dy) { if(sx==dx&amp;&amp;sy==dy) { return false; } if(is_out(sx,sy)||is_out(dx,dy)) { return false; } if(get_color(sx,sy)!=color) { return false; } if(is_same_color(sx,sy,dx,dy)) { return false; } switch(get_type(sx,sy)) { case JU: return is_correct_move_JU(sx,sy,dx,dy); case MA: return is_correct_move_MA(sx,sy,dx,dy); case XIANG: return is_correct_move_XIANG(sx,sy,dx,dy); case SHI: return is_correct_move_SHI(sx,sy,dx,dy); case JIANG: return is_correct_move_JIANG(sx,sy,dx,dy); case PAO: return is_correct_move_PAO(sx,sy,dx,dy); case ZU: return is_correct_move_ZU(sx,sy,dx,dy); default: return false; } } void move_s_to_d(int sx,int sy,int dx,int dy) { //&#x79FB;&#x52A8;&#x64CD;&#x4F5C; if(get_type(dx,dy)==JIANG) { //&#x5982;&#x679C;&#x76EE;&#x7684;&#x68CB;&#x5B50;&#x662F;&#x5C06; if(get_color(dx,dy)==color)set_win(LOSE);//&#x5982;&#x679C;&#x662F;&#x81EA;&#x5DF1;&#x7684;&#x5C06;&#xFF0C;&#x5219;&#x8F93; else set_win(WIN);//&#x5982;&#x679C;&#x662F;&#x5BF9;&#x65B9;&#x7684;&#x5C06;&#xFF0C;&#x5219;&#x8D62; } b[dx][dy]=b[sx][sy]; b[sx][sy]=BLANK; change_turn(); } void init_pieces() { for(int i=0; i&lt;M; i+=M-1) {//&#x7B2C;&#x4E00;&#x884C;&#x548C;&#x6700;&#x540E;&#x4E00;&#x884C;&#xFF08;&#x5373;&#x8F66;&#x9A6C;&#x8C61;&#x58EB;&#x5C06;&#x58EB;&#x8C61;&#x9A6C;&#x8F66;&#xFF09; for(int index=0; index&lt;N; index++) { if(index&lt;N/2+1)b[i][index]=index+1; else b[i][index]=N-index; } } //&#x5352;&#x6240;&#x5728;&#x7684;&#x884C; for(int index=0; index&lt;N; index+=2) { b[3][index]=ZU; } for(int index=0; index&lt;N; index+=2) { b[6][index]=ZU; } b[2][1]=PAO; b[M-1-2][1]=PAO; b[2][N-1-1]=PAO; b[M-1-2][N-1-1]=PAO; int s,d;//&#x5B58;&#x50A8;&#x8D77;&#x59CB;&#x884C;&#x548C;&#x7EC8;&#x70B9;&#x884C; if(color==BLACK) { s=0;//&#x4ECE;0&#x884C;&#x5230;M/2&#x884C;&#xFF0C;&#x5373;&#x68CB;&#x76D8;&#x4E0A;&#x534A;&#x90E8;&#x5206; d=M/2; } else { s=M/2;//&#x68CB;&#x76D8;&#x4E0B;&#x534A;&#x90E8;&#x5206; d=M; } //&#x4ECE;s&#x884C;&#x5230;d&#x884C;&#xFF0C;&#x628A;&#x975E;BLANK&#x7684;&#x503C;&#x52A0;BLANK&#xFF0C;&#x4F7F;&#x5C0F;&#x4E8E;BLANK&#x7684;&#x4EE3;&#x8868;&#x9ED1;&#x8272;&#x68CB;&#xFF0C;&#x5927;&#x4E8E;BLANK&#x7684;&#x4EE3;&#x8868;&#x767D;&#x8272;&#x68CB; for(int index=s; index&lt;d; index++) { for(int j=0; j&lt;N; j++) { if(b[index][j]!=BLANK) { b[index][j]+=BLANK; } } } }public: Board(int c) { color=c; M=10; N=9; b=new int*[M]; for(int i=0; i&lt;M; i++) { b[i]=new int[N]; } init(); } void init() {//&#x68CB;&#x76D8;&#x521D;&#x59CB;&#x5316; is_win=0; turn=color==BLACK?true:false; for(int i=0; i&lt;M; i++) { for(int j=0; j&lt;N; j++) { b[i][j]=BLANK; } } init_pieces(); } int get_M() { return M; } int get_N() { return N; } int get_color() {//&#x83B7;&#x53D6;&#x5DF1;&#x65B9;&#x7684;&#x989C;&#x8272; return color; } int get_color(int x,int y) {//&#x83B7;&#x53D6;&#x68CB;&#x76D8;&#x67D0;&#x4E00;&#x5750;&#x6807;&#x4E0A;&#x68CB;&#x5B50;&#x7684;&#x989C;&#x8272; return b[x][y]&gt;BLANK?WHITE:b[x][y]&lt;BLANK?BLACK:BLANK; } int get_type(int x,int y) {//&#x83B7;&#x53D6;&#x68CB;&#x5B50;&#x7C7B;&#x578B;&#xFF08;&#x7A7A;&#x3001;&#x8F66;&#x3001;&#x9A6C;&#x3001;&#x8C61;&#x3001;&#x58EB;&#x3001;&#x5C06;&#x3001;&#x70AE;&#x3001;&#x5352;&#xFF09; return b[x][y]!=BLANK?b[x][y]%BLANK:BLANK; } void set_win(int is) { is_win=is; } int get_is_win() { return is_win; } void change_turn() { turn=turn==true?false:true; } bool is_my_turn() { return turn; } void othside_move_piece(int sx,int sy,int dx,int dy) {//&#x5BF9;&#x65B9;&#x79FB;&#x5B50; sx=M-1-sx;//&#x5148;&#x8FDB;&#x884C;&#x5750;&#x6807;&#x8F6C;&#x6362;&#xFF0C;&#x56E0;&#x5BF9;&#x65B9;&#x89C6;&#x89D2;&#x4E0E;&#x5DF1;&#x65B9;&#x76F8;&#x53CD; sy=N-1-sy; dx=M-1-dx; dy=N-1-dy; move_s_to_d(sx,sy,dx,dy); } bool my_move_piece(int sx,int sy,int dx,int dy) { //&#x5DF1;&#x65B9;&#x4E3B;&#x52A8;&#x79FB;&#x5B50; if(!is_correct_move(sx,sy,dx,dy))return false; move_s_to_d(sx,sy,dx,dy); return true; }};#endif // CHINESE_CHESS_H_INCLUDED Server.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#ifndef SERVER_H_INCLUDED#define SERVER_H_INCLUDED#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;winsock2.h&gt;#include&quot;chinese_chess.h&quot;#define INIT_ERROR 1#define BIND_ERROR 2#define LISTEN_ERROR 3#define CONNECT_ERROR 4#define SEND_ERROR 5#define ACCEPT_ERROR 6#define ALIVE_ERROR 7#define THREAD_ERROR 8int error_num;extern HWND hwnd;extern Board* chess_board;extern char* ots_ip;extern int port;extern bool is_connect_alive;//&#x7EBF;&#x7A0B;&#x53C2;&#x6570;&#x7ED3;&#x6784;&#x4F53;typedef struct server_args { SOCKET* Com_Sock; char * rebuf;} server_args;//&#x6821;&#x9A8C;&#x68C0;&#x6D4B;&#xFF0C;&#x4E0E;&#x5BA2;&#x6237;&#x7AEF;&#x7684;&#x6DFB;&#x52A0;&#x6821;&#x9A8C;&#x662F;&#x76F8;&#x53CD;&#x64CD;&#x4F5C;//&#x6700;&#x540E;&#x4E00;&#x4F4D;&#x4E4B;&#x524D;&#x7684;&#x6240;&#x6709;&#x5B57;&#x7B26;&#x76F8;&#x52A0;&#x53D6;&#x6A21;&#x540E;&#xFF0C;&#x5982;&#x679C;&#x7B49;&#x4E8E;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x5B57;&#x7B26;&#xFF0C;&#x5219;&#x6821;&#x9A8C;&#x901A;&#x8FC7;bool server_check(char * r) { int len=strlen(r); len--; int s=0; for(int i=0; i&lt;len; i++) { s+=r[i]; } if(r[len]==(s%5+&apos;0&apos;)) { r[len]=&apos;\0&apos;; return true; } return false;}//&#x9519;&#x8BEF;&#x5904;&#x7406;&#xFF0C;is_tell&#x63A7;&#x5236;&#x662F;&#x5426;&#x663E;&#x793A;&#x9519;&#x8BEF;&#x4FE1;&#x606F;&#xFF0C;is_exit&#x63A7;&#x5236;&#x662F;&#x5426;&#x9000;&#x51FA;&#x7A0B;&#x5E8F;int handle_error(int err,bool is_tell,bool is_exit) { error_num=err; if(!is_tell)return error_num; char error[30]=&quot;&quot;; switch(error_num) { case INIT_ERROR: strcpy(error,&quot;&#x521D;&#x59CB;&#x5316;&#x9519;&#x8BEF;&quot;); break; case BIND_ERROR: strcpy(error,&quot;&#x7ED1;&#x5B9A;&#x7AEF;&#x53E3;&#x9519;&#x8BEF;&quot;); break; case LISTEN_ERROR: strcpy(error,&quot;&#x76D1;&#x542C;&#x9519;&#x8BEF;&quot;); break; case ACCEPT_ERROR: strcpy(error,&quot;&#x63A5;&#x53D7;&#x8FDE;&#x63A5;&#x9519;&#x8BEF;&quot;); break; case CONNECT_ERROR: strcpy(error,&quot;&#x65E0;&#x6CD5;&#x8FDE;&#x63A5;&quot;); break; case ALIVE_ERROR: strcpy(error,&quot;&#x8FDE;&#x63A5;&#x5DF2;&#x65AD;&#x5F00;&quot;); break; case THREAD_ERROR: strcpy(error,&quot;&#x7EBF;&#x7A0B;&#x65E0;&#x6CD5;&#x521B;&#x5EFA;&quot;); break; case SEND_ERROR: strcpy(error,&quot;&#x53D1;&#x9001;&#x9519;&#x8BEF;&quot;); } char error_message[50]; strcpy(error_message,&quot;&#x9519;&#x8BEF;&#xFF1A;&quot;); strcat(error_message,error); if(is_exit)strcat(error_message,&quot;\n&#x7A0B;&#x5E8F;&#x5C06;&#x9000;&#x51FA;&#x3002;&quot;); MessageBox(hwnd,error_message,&quot;&#x9519;&#x8BEF;&quot;,MB_OK); if(is_exit)exit(0); return error_num;}void* handle_message(void*ar) { server_args * serarg=(server_args * )ar; char *recv=serarg-&gt;rebuf; SOCKET* CommandSock=serarg-&gt;Com_Sock; if(server_check(recv)) {//&#x6821;&#x9A8C;&#x901A;&#x8FC7;&#x53D1;&#x9001;okok&#xFF08;OK&#xFF09;&#xFF0C;&#x4E0D;&#x901A;&#x8FC7;&#x53D1;&#x9001;noto&#xFF08;NOTOK&#xFF09; send(*CommandSock,&quot;okok&quot;,4,0); } else { send(*CommandSock,&quot;noto&quot;,4,0); return ar; } if(strncmp(recv,&quot;move&quot;,4)==0) { char * pch; //&#x5C06;recvBuf&#x4EE5;&#x9017;&#x53F7;&#x62C6;&#x5206; pch = strtok (recv,&quot;,&quot;); pch = strtok (NULL,&quot;,&quot;); int xys[4]; int index=0; while (pch != NULL) { xys[index]=atoi(pch);//char* &#x8F6C;&#x6362;&#x4E3A;int index++; pch = strtok (NULL, &quot;,&quot;); } chess_board-&gt;othside_move_piece(xys[0],xys[1],xys[2],xys[3]); if(chess_board-&gt;get_is_win()==LOSE) { chess_board-&gt;init();//&#x5982;&#x679C;&#x8F93;&#x4E86;&#xFF0C;&#x5219;&#x91CD;&#x65B0;&#x521D;&#x59CB;&#x5316;&#x68CB;&#x76D8;&#xFF0C;&#x518D;&#x4E0B;&#x4E00;&#x76D8; MessageBox(hwnd,&quot;&#x4F60;&#x8F93;&#x4E86;&quot;,&quot;&#x5931;&#x8D25;&#xFF01;&quot;,NULL); } InvalidateRect(hwnd,NULL,true); } delete recv;}class Server {private: SOCKET Server_Sock; SOCKADDR_IN server_addr; SOCKADDR_IN client_addr; char recvBuf[20];public: Server() { WSADATA wsa; /*&#x521D;&#x59CB;&#x5316;socket&#x8D44;&#x6E90;*/ if (WSAStartup(MAKEWORD(1,1),&amp;wsa) != 0) { handle_error(INIT_ERROR,true,true); return; } if((Server_Sock = socket(AF_INET, SOCK_STREAM, 0))==-1) { handle_error(INIT_ERROR,true,true); return; } ZeroMemory((char *)&amp;server_addr,sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port); /*&#x672C;&#x5730;&#x76D1;&#x542C;&#x7AEF;&#x53E3;*/ server_addr.sin_addr.s_addr = htonl(INADDR_ANY); /*&#x6709;IP*/ if(bind(Server_Sock,(struct sockaddr *)&amp;server_addr,sizeof(server_addr))==-1) { handle_error(BIND_ERROR,true,true); return; } if(listen(Server_Sock,5)==-1) { //&#x5176;&#x4E2D;&#x7B2C;&#x4E8C;&#x4E2A;&#x53C2;&#x6570;&#x4EE3;&#x8868;&#x80FD;&#x591F;&#x63A5;&#x6536;&#x7684;&#x6700;&#x591A;&#x7684;&#x8FDE;&#x63A5;&#x6570; handle_error(LISTEN_ERROR,true,true); return; } strcpy(recvBuf,&quot;&quot;); } void listen_message() { int len=sizeof(SOCKADDR); while(true) { SOCKET Command_Sock = accept(Server_Sock, (SOCKADDR*)&amp;client_addr,&amp;len); if(Command_Sock == INVALID_SOCKET) { closesocket(Command_Sock); handle_error(ACCEPT_ERROR,false,false); continue; } if(client_addr.sin_addr.s_addr!=inet_addr(ots_ip)) {//&#x5982;&#x679C;&#x63A5;&#x6536;&#x7684;socket&#x4E0D;&#x662F;&#x9884;&#x671F;&#x7684;&#x5BF9;&#x65B9;&#x7684;&#xFF0C;&#x5219;&#x53D1;&#x9001;wron&#xFF0C;&#x7EE7;&#x7EED;&#x7B49;&#x5F85; send(Command_Sock,&quot;wron&quot;,4,0); closesocket(Command_Sock); continue; } send(Command_Sock,&quot;righ&quot;,4,0); is_connect_alive=true; while(true) { if(recv(Command_Sock,recvBuf,20,0)&lt;=0) {//recv&#x8FD4;&#x56DE;&#x5C0F;&#x4E8E;&#x7B49;&#x4E8E;0&#x7684;&#x503C;&#xFF0C;&#x5219;&#x8FDE;&#x63A5;&#x5DF2;&#x65AD;&#x5F00; handle_error(ALIVE_ERROR,true,true); closesocket(Command_Sock); close(); return ; } char *rbuf=new char[20]; strcpy(rbuf,recvBuf); server_args serarg; serarg.Com_Sock=&amp;Command_Sock; serarg.rebuf=rbuf; pthread_t handle_m; int ret; ret= pthread_create( &amp;handle_m, NULL, handle_message,&amp;serarg); // if( ret != 0 ) { //&#x521B;&#x5EFA;&#x7EBF;&#x7A0B;&#x6210;&#x529F;&#x8FD4;&#x56DE;0 // printf(&quot;pthread_create error:error_code=%d\n&quot;,ret ); handle_error(THREAD_ERROR,true,true); return ; } strcpy(recvBuf,&quot;&quot;); } closesocket(Command_Sock); } } void close() { closesocket(Server_Sock); WSACleanup(); }};#endif // SERVER_H_INCLUDED Client.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#ifndef CLIENT_H_INCLUDED#define CLIENT_H_INCLUDED#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#include&quot;chinese_chess.h&quot;//&#x4E3A;&#x5B57;&#x7B26;&#x4E32;&#x6DFB;&#x52A0;&#x6821;&#x9A8C;&#x4FE1;&#x606F;&#xFF0C;&#x5BF9;&#x6240;&#x6709;&#x5B57;&#x7B26;&#x6C42;&#x548C;&#xFF0C;&#x6A21;5&#x4E4B;&#x540E;&#x8F6C;&#x5316;&#x4E3A;&#x5B57;&#x7B26;&#x653E;&#x5728;&#x5B57;&#x7B26;&#x4E32;&#x6700;&#x540E;void client_check(char* r) { int len=strlen(r); int s=0; for(int i=0; i&lt;len; i++) { s+=r[i]; } r[len]=s%5+&apos;0&apos;; r[len+1]=&apos;\0&apos;;}class Client {private: SOCKET Client_Sock; SOCKADDR_IN server_addr; char sendBuf[20];public: Client() { WSADATA wsa; /*&#x521D;&#x59CB;&#x5316;socket&#x8D44;&#x6E90;*/ if (WSAStartup(MAKEWORD(1,1),&amp;wsa) != 0) { handle_error(INIT_ERROR,true,true); return; //&#x4EE3;&#x8868;&#x5931;&#x8D25; } if((Client_Sock = socket(AF_INET, SOCK_STREAM, 0))==-1) { handle_error(INIT_ERROR,true,true); return; //&#x4EE3;&#x8868;&#x5931;&#x8D25; } server_addr.sin_addr.S_un.S_addr=inet_addr(ots_ip); server_addr.sin_family=AF_INET; server_addr.sin_port=htons(port); strcpy(sendBuf,&quot;&quot;); } void connect_to_ots() { while(connect(Client_Sock,(SOCKADDR*)&amp;server_addr,sizeof(SOCKADDR)) ==-1) { handle_error(CONNECT_ERROR,false,false); Sleep(100); //printf( &quot;%d &quot;, WSAGetLastError()); } char rec[5]; recv(Client_Sock,rec,4,0); if(strncmp(rec,&quot;wron&quot;,4)==0) { //&#x6536;&#x5230;wrong&#xFF0C;&#x8BF4;&#x660E;&#x5BF9;&#x65B9;&#x6240;&#x8F93;&#x5165;&#x7684;IP&#x4E0D;&#x662F;&#x5DF1;&#x65B9;IP MessageBox(hwnd,&quot;&#x5BF9;&#x65B9;&#x8F93;&#x5165;&#x7684;IP&#x4E0D;&#x662F;&#x4F60;\n&#x7A0B;&#x5E8F;&#x5C06;&#x9000;&#x51FA;&quot;,&quot;&#x9519;&#x8BEF;&quot;,NULL); exit(-1); } //&#x8C01;&#x5148;&#x8FDE;&#x63A5;&#x8C01;&#x662F;&#x9ED1;&#x8272; //&#x5982;&#x679C;server&#x5DF2;&#x7ECF;&#x6536;&#x5230;&#x8FDE;&#x63A5;&#xFF0C;&#x5219;&#x8BF4;&#x660E;&#x662F;&#x5BF9;&#x65B9;&#x5148;&#x8FDE;&#x63A5;&#x81EA;&#x5DF1;&#xFF0C;&#x5219;&#x81EA;&#x5DF1;&#x5E94;&#x4E3A;&#x767D;&#x8272;&#xFF0C;&#x5426;&#x5219;&#x81EA;&#x5DF1;&#x662F;&#x9ED1;&#x8272; if(is_connect_alive) { chess_board=new Board(WHITE); } else { chess_board=new Board(BLACK); } } void close() { closesocket(Client_Sock); WSACleanup(); } int send_message(char * message) { strcpy(sendBuf,message); client_check(sendBuf); int len; int try_time=0; while(true) { len=send(Client_Sock,sendBuf,strlen(sendBuf)+1,0); if(len!=(strlen(sendBuf)+1)) { handle_error(SEND_ERROR,false,false); //printf( &quot;%d &quot;, WSAGetLastError()); } char rec[5]; recv(Client_Sock,rec,4,0); if(strncmp(rec,&quot;okok&quot;,4)==0) {//&#x6536;&#x5230;OK&#x8BF4;&#x660E;&#x6570;&#x636E;&#x5DF2;&#x7ECF;&#x6B63;&#x786E;&#x88AB;&#x5BF9;&#x65B9;&#x6536;&#x5230; break; } if(try_time&gt;20) { //&#x5C1D;&#x8BD5;20&#x6B21;&#xFF0C;&#x6570;&#x636E;&#x4ECD;&#x65E0;&#x6CD5;&#x6B63;&#x786E;&#x9001;&#x8FBE;&#xFF0C;&#x5219;&#x9000;&#x51FA; handle_error(SEND_ERROR,true,true); } try_time++; } return len; } int send_message(const char * message,int sx,int sy,int dx,int dy) { char* message_temp=new char[20]; sprintf(message_temp,&quot;%s,%d,%d,%d,%d,&quot;,message,sx,sy,dx,dy); int len=send_message(message_temp); delete message_temp; return len; }};#endif // CLIENT_H_INCLUDED &#x8BE5;&#x7A0B;&#x5E8F;&#x4ECE;3.15&#x665A;&#x5F00;&#x59CB;&#xFF0C;&#x7528;&#x4E86;&#x56DB;&#x5929;&#x7684;&#x7A7A;&#x95F2;&#x65F6;&#x95F4;&#x3002;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Shell（C++实现，CodeBlocks+GCC编译）]]></title>
      <url>2016%2F03%2F20%2FShell%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[&#x7A0B;&#x5E8F;&#x6548;&#x679C;&#xFF1A;&#x3000;&#x3000;&#x53EA;&#x5B9E;&#x73B0;&#x4E86;login &#x3001;cd &#x3001;ls &#x3001;cat &#x56DB;&#x4E2A;&#x547D;&#x4EE4;&#x3002;&#x800C;&#x4E14;&#x53EA;&#x80FD;&#x5728; Windows &#x4E0B;&#x8FD0;&#x884C;&#x3002; &#x4EE3;&#x7801;&#xFF1A;12345678910111213141516171819202122232425262728293031323334353637//main.cpp#include &lt;iostream&gt;#include &quot;shell.h&quot;using namespace std;int com_to_int(int com_num,char * command,char** coms){ return -1;}int main(){ const int COM_NUM=5; char command[MAX_LENGTH_OF_COMMAND]; char *coms[COM_NUM]={&quot;login&quot;,&quot;ls&quot;,&quot;cd&quot;,&quot;cat&quot;,&quot;exit&quot;}; int (*func_ptrs[COM_NUM])(char *)={login,ls,cd,cat,shellexit}; while(true){ printf(&quot;%s%s%s%s%s&quot;,&quot;[&quot;,USER_NAME,&quot; &quot;,GLOBLE_PATH,&quot;]&quot;); gets(command); if(strcmp(command,&quot;&quot;)==0){ continue; } //printf(&quot;command: %s\n&quot;,command); //printf(&quot;command: %s\n&quot;,command); int i; for(i=0;i&lt;COM_NUM;i++){ if(strncmp(coms[i],command,strlen(coms[i]))==0){ func_ptrs[i](command); break; } } if(i==COM_NUM){ printf(&quot;command not found.\n&quot;); } } cd(&quot;C:/0&quot;); ls(GLOBLE_PATH); return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178//shell.h#ifndef SHELL_H_INCLUDED#define SHELL_H_INCLUDED#include&lt;io.h&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAX_LENGTH_OF_PATH 256#define MAX_LENGTH_OF_USERNAME 50#define MAX_LENGTH_OF_COMMAND 50#define MAX_LENGTH_OF_LINE 256char GLOBLE_PATH[MAX_LENGTH_OF_PATH]= {&apos;C&apos;,&apos;:&apos;,&apos;/&apos;,&apos;0&apos;,&apos;\0&apos;};char USER_NAME[MAX_LENGTH_OF_USERNAME]= {&apos;g&apos;,&apos;u&apos;,&apos;e&apos;,&apos;s&apos;,&apos;t&apos;,&apos;\0&apos;};int login(char * command){ printf(&quot;user name:&quot;); char username[MAX_LENGTH_OF_USERNAME]; gets(username); FILE * pwd; pwd = fopen (&quot;pwd&quot;,&quot;r&quot;); if (pwd!=NULL) { char line[MAX_LENGTH_OF_LINE]; while (!feof(pwd)) { if(fgets(line,MAX_LENGTH_OF_LINE,pwd)!=NULL) { char * name=strtok(line,&quot; &quot;); //printf(&quot;%s\n&quot;,name); if(strcmp(name,username)==0) { char password[MAX_LENGTH_OF_USERNAME]; printf(&quot;password:&quot;); gets(password); char * pasw=strtok(NULL,&quot; \n\r&quot;); //printf(&quot;file password:%s\n&quot;,pasw); if(strcmp(pasw,password)==0) { strcpy(USER_NAME,username); } else { printf(&quot;wrong password.\n&quot;); } fclose (pwd); return 0; } } } printf(&quot;user not exist.\n&quot;); fclose (pwd); } else { printf(&quot;login error.pwd file not exist or not able to open.\n&quot;); } return 0;}int shellexit(char * command){ exit(0); return 0;}int cat_file(char * file_path){ FILE* f=fopen(file_path,&quot;r&quot;); if(f==NULL) { printf(&quot;file does not exist.\n&quot;); return -1; } char line[MAX_LENGTH_OF_LINE]; while(!feof(f)) { fgets(line,MAX_LENGTH_OF_LINE,f); for(int i=0;i&lt;strlen(line);i++){ if(line[i]==&apos;\0&apos;)break; printf(&quot;%c&quot;,line[i]); } } printf(&quot;\n&quot;); return 0;}int cat(char * command){ char * path=strtok(command,&quot; &quot;); path=strtok(NULL,&quot; &quot;); //printf(&quot;path:%s&quot;,path); cat_file(path); return 0;}int cd_path(char *path){ struct _finddata_t f; int p; //printf(&quot;1&quot;); /* FILE * pFile; pFile = fopen (path,&quot;r&quot;); if (pFile!=NULL) { printf(&quot;2&quot;); }printf(&quot;3&quot;);*/ if((p=_findfirst(path, &amp;f))!=-1) { //printf(&quot;%d&quot;,p); //printf(&quot;2&quot;); //printf(&quot; %d &quot;,f.attrib); if(f.attrib&amp;_A_SUBDIR) { //printf(&quot;4&quot;); strcpy(GLOBLE_PATH,path); return 0; } else { printf(&quot;destination path is not a folder.\n&quot;); } } else { printf(&quot;destination not exist.\n&quot;); } return -1;}int cd(char * command){ char * path=strtok(command,&quot; &quot;); path=strtok(NULL,&quot; &quot;); //printf(&quot;path:%s&quot;,path); cd_path(path); return 0;}int ls_path(char * path){ struct _finddata_t f; int p; char name[MAX_LENGTH_OF_PATH]; strcpy(name,path); strcat(name,&quot;/*&quot;); //printf(&quot;1&quot;); if((p=_findfirst(name, &amp;f))!=-1) { //read(p,filename,) //printf(&quot;2&quot;); printf(f.name); printf(&quot;\n&quot;); while(_findnext(p, &amp;f)==0) { printf(f.name); printf(&quot;\n&quot;); } } else { } return 0;}int ls(char * command){ char * path=strtok(command,&quot; &quot;); path=strtok(NULL,&quot; &quot;); //printf(&quot;path:%s&quot;,path); if(path==NULL||strcmp(path,&quot;&quot;)==0) { ls_path(GLOBLE_PATH); } else { ls_path(path); } return 0;}#endif // SHELL_H_INCLUDED &#x5916;&#x90E8;&#x8D44;&#x6E90;&#x6587;&#x4EF6;&#xFF1A;pwd&#xFF08;login &#x547D;&#x4EE4;&#x4F7F;&#x7528;&#xFF09;&#xFF1A; 123ma 123456xue 123456wei 123456 &#x7A0B;&#x5E8F;&#x5199;&#x4E8E;&#x5927;&#x4E09;&#x4E0B;&#x5B66;&#x671F;&#xFF0C;2016&#x5E74;3&#x6708;&#x3002; 2016.4.12&#x66F4;&#x65B0;&#x535A;&#x5BA2;&#x3002;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GLine游戏（Win32GUI实现，CodeBlocks+GCC编译）]]></title>
      <url>2016%2F03%2F15%2FGlines%E6%B8%B8%E6%88%8F%2F</url>
      <content type="text"><![CDATA[&#x6E38;&#x620F;&#x89C4;&#x5219;&#xFF1A;&#x5728;10X10&#x7684;&#x68CB;&#x76D8;&#x4E0A;&#x6709;&#x4E94;&#x79CD;&#x989C;&#x8272;&#x7684;&#x68CB;&#x5B50;&#x3002; &#x70B9;&#x51FB;&#x4E00;&#x4E2A;&#x68CB;&#x5B50;&#xFF0C;&#x518D;&#x70B9;&#x51FB;&#x4E00;&#x4E2A;&#x7A7A;&#x683C;&#x5B50;&#xFF0C;&#x5982;&#x679C;&#x4E24;&#x8005;&#x4E4B;&#x95F4;&#x6709;&#x4E00;&#x6761;&#x8DEF;&#x5F84;&#x7684;&#x8BDD;&#xFF0C;&#x68CB;&#x5B50;&#x4F1A;&#x79FB;&#x52A8;&#x5230;&#x7A7A;&#x683C;&#x5B50;&#x5185;&#x3002; &#x6BCF;&#x79FB;&#x52A8;&#x4E00;&#x6B21;&#xFF0C;&#x68CB;&#x76D8;&#x4E0A;&#x4F1A;&#x589E;&#x52A0;&#x4E09;&#x4E2A;&#x68CB;&#x5B50;&#xFF0C;&#x5176;&#x4F4D;&#x7F6E;&#x548C;&#x989C;&#x8272;&#x90FD;&#x662F;&#x968F;&#x673A;&#x7684;&#x3002; &#x5F53;&#x6A2A;&#x5411;&#x3001;&#x7AD6;&#x5411;&#x6216;&#x659C;&#x5411;&#x6709;&#x4E94;&#x4E2A;&#x6216;&#x4EE5;&#x4E0A;&#x68CB;&#x5B50;&#x6709;&#x76F8;&#x540C;&#x989C;&#x8272;&#x65F6;&#xFF0C;&#x8FD9;&#x4E9B;&#x68CB;&#x5B50;&#x4F1A;&#x6D88;&#x53BB;&#x3002; &#x5F53;&#x68CB;&#x76D8;&#x4E0A;&#x6CA1;&#x6709;&#x7A7A;&#x683C;&#x5B50;&#x65F6;&#xFF0C;&#x6E38;&#x620F;&#x7ED3;&#x675F;&#x3002; &#x5F97;&#x5206;&#x4E3A;&#x6D88;&#x53BB;&#x5F97;&#x68CB;&#x5B50;&#x7684;&#x4E2A;&#x6570;&#x3002; &#x7A0B;&#x5E8F;&#x6548;&#x679C;&#xFF1A; &#x4EE3;&#x7801;&#xFF1A;main.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280 //main.cpp#if defined(UNICODE) &amp;&amp; !defined(_UNICODE)#define _UNICODE#elif defined(_UNICODE) &amp;&amp; !defined(UNICODE)#define UNICODE#endif#include &lt;tchar.h&gt;#include &lt;windows.h&gt;#include &quot;matrix.h&quot;#include &quot;matrix.cpp&quot;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#define BKCOLOR RGB(200,200,200)int score=0;int WIDTH=400;int HEIGHT=440;Matrix ma;int width=40;//WIDTH/ma.getN();int height=40;//HEIGHT/ma.getN();PAINTSTRUCT ps ;static HBRUSH red_brush =CreateSolidBrush (RGB(230,90,90));static HBRUSH green_brush =CreateSolidBrush (RGB(90,230,90));static HBRUSH blue_brush =CreateSolidBrush (RGB(90,90,230));static HBRUSH yellow_brush =CreateSolidBrush (RGB(230,230,90));static HBRUSH purple_brush =CreateSolidBrush (RGB(230,90,230));static HBRUSH white_brush =CreateSolidBrush (BKCOLOR);Point * s_lattice=new Point(0,0),*d_lattice=new Point(0,0);bool paint_path=false;int path_color=0;Point* sou=new Point();Point* dest=new Point();Point* mouse=new Point(0,0);Point *position=new Point(0,0);Link&lt;Point *&gt;* path;HBRUSH hBrush ;HDC hdc;POINT pc;RECT client_rect;int score_height;/* Declare Windows procedure */LRESULT CALLBACK WindowProcedure (HWND, UINT, WPARAM, LPARAM);/* Make the class name into a global variable */TCHAR szClassName[ ] = _T(&quot;Game&quot;);int WINAPI WinMain (HINSTANCE hThisInstance, HINSTANCE hPrevInstance, LPSTR lpszArgument, int nCmdShow) { HWND hwnd; /* This is the handle for our window */ MSG messages; /* Here messages to the application are saved */ WNDCLASSEX wincl; /* Data structure for the windowclass */ /* The Window structure */ wincl.hInstance = hThisInstance; wincl.lpszClassName = szClassName; wincl.lpfnWndProc = WindowProcedure; /* This function is called by windows */ wincl.style = CS_DBLCLKS; /* Catch double-clicks */ wincl.cbSize = sizeof (WNDCLASSEX); /* Use default icon and mouse-pointer */ wincl.hIcon = LoadIcon (NULL, IDI_APPLICATION); wincl.hIconSm = LoadIcon (NULL, IDI_APPLICATION); wincl.hCursor = LoadCursor (NULL, IDC_ARROW); wincl.lpszMenuName = NULL; /* No menu */ wincl.cbClsExtra = 0; /* No extra bytes after the window class */ wincl.cbWndExtra = 0; /* structure or the window instance */ /* Use Windows&apos;s default colour as the background of the window */ wincl.hbrBackground = (HBRUSH) COLOR_BACKGROUND; /* Register the window class, and if it fails quit the program */ if (!RegisterClassEx (&amp;wincl)) return 0; /* The class is registered, let&apos;s create the program*/ hwnd = CreateWindowEx ( 0, /* Extended possibilites for variation */ szClassName, /* Classname */ _T(&quot;GLine&quot;), /* Title Text */ WS_OVERLAPPEDWINDOW, /* default window */ CW_USEDEFAULT, /* Windows decides the position */ CW_USEDEFAULT, /* where the window ends up on the screen */ WIDTH, /* The programs width */ HEIGHT, /* and height in pixels */ HWND_DESKTOP, /* The window is a child-window to desktop */ NULL, /* No menu */ hThisInstance, /* Program Instance handler */ NULL /* No Window Creation data */ ); /* Make the window visible on the screen */ ShowWindow (hwnd, nCmdShow); /* Run the message loop. It will run until GetMessage() returns 0 */ while (GetMessage (&amp;messages, NULL, 0, 0)) { /* Translate virtual-key messages into character messages */ TranslateMessage(&amp;messages); /* Send message to WindowProcedure */ DispatchMessage(&amp;messages); } /* The program return-value is 0 - The value that PostQuitMessage() gave */ return messages.wParam;}int select_brush(int color,HDC hdc) { switch(color) { case RED: SelectObject (hdc, red_brush); break; case GREEN: SelectObject (hdc, green_brush); break; case BLUE: SelectObject (hdc, blue_brush); break; case YELLOW: SelectObject (hdc, yellow_brush); break; case PURPLE: SelectObject (hdc, purple_brush); break; default: SelectObject (hdc, white_brush); } return color;}void paint_lattice(Point * p,HDC hdc,int color) { //-1 original color int left=p-&gt;y*width; int right=(p-&gt;y+1)*width; int top=p-&gt;x*height+score_height; int bottom=(p-&gt;x+1)*height+score_height; MoveToEx (hdc,left,top, NULL) ; LineTo (hdc,right,top) ; MoveToEx (hdc,left,top, NULL) ; LineTo (hdc,left,bottom) ; MoveToEx (hdc,right,top, NULL) ; LineTo (hdc,right,bottom) ; MoveToEx (hdc,left,bottom, NULL) ; LineTo (hdc,right,bottom) ; int paint_color; if(color!=-1) { paint_color=select_brush(color,hdc); } else { paint_color=select_brush(ma.get_color(p),hdc); } if(paint_color!=BLANK)Ellipse (hdc,left+3,top+3,right-3,bottom-3) ;}void mouse_to_position() { position-&gt;x=(mouse-&gt;y-score_height)/height; position-&gt;y=mouse-&gt;x/width;}char *get_score_string(char* content){ char *message=new char[50]; sprintf (message, &quot;%s %d .&quot;,content,score); return message;}int show_score(HWND hwnd,char* content,char* title) { MessageBox(hwnd,get_score_string(content),title,NULL);}void after_show_path(HWND hwnd) { ma.set_flag(dest,ma.get_color(sou)); ma.set_blank(sou); ma.random_set(2); ma.eliminate(score); InvalidateRect (hwnd,NULL, true) ; if(ma.is_all_not_blank()) { show_score(hwnd,&quot;GAME OVER.Your score is&quot;,&quot;&#x4F60;&#x8F93;&#x4E86;&quot;); }}struct args { HWND hwnd; HDC hdc;};void* show_path(void* ar) { path=new Link&lt;Point *&gt;(); ma.get_path(sou,dest,path); struct args* arg=(struct args*) ar; HWND hwnd=arg-&gt;hwnd; HDC hdc=arg-&gt;hdc; if(path-&gt;get_first()==NULL) { return 0; } //path-&gt;show_link(); path-&gt;seek_to_first(); Point* node=path-&gt;get_first(); path_color=ma.get_color(node); s_lattice=node; paint_path=true; while((node=path-&gt;get_next())!=NULL) { d_lattice=node; InvalidateRect (hwnd,NULL, true) ; Sleep(300); } paint_path=false; after_show_path(hwnd);}void init_GUI(HWND hwnd,HDC hdc) { SetBkColor(hdc,BKCOLOR); for(int i=0; i&lt;ma.getN(); i++) { for(int j=0; j&lt;ma.getN(); j++) { Point* p=new Point(i,j); paint_lattice(p,hdc,-1); delete p; } } char * score=get_score_string(&quot;You Score: &quot;); TextOut(hdc,0,score_height/4,score,strlen(score));}void sou_dest(HWND hwnd,HDC hdc) { static pthread_t show_path_pth; static int ret; mouse_to_position(); if(sou!=NULL) { if(ma.get_color(position)==BLANK) { *dest=*position; struct args arg; arg.hdc=hdc; arg.hwnd=hwnd; ret= pthread_create( &amp;show_path_pth, NULL, &amp;show_path, &amp;arg ); //&#x53C2;&#x6570;&#xFF1A;&#x521B;&#x5EFA;&#x7684;&#x7EBF;&#x7A0B;id&#xFF0C;&#x7EBF;&#x7A0B;&#x53C2;&#x6570;&#xFF0C;&#x7EBF;&#x7A0B;&#x8FD0;&#x884C;&#x51FD;&#x6570;&#x7684;&#x8D77;&#x59CB;&#x5730;&#x5740;&#xFF0C;&#x8FD0;&#x884C;&#x51FD;&#x6570;&#x7684;&#x53C2;&#x6570; if( ret != 0 ) { //&#x521B;&#x5EFA;&#x7EBF;&#x7A0B;&#x6210;&#x529F;&#x8FD4;&#x56DE;0 printf(&quot;pthread_create error:error_code=%d\n&quot;,ret ); } } else { *sou=*position; } } else { if(ma.get_color(position)!=BLANK) { *sou=*position; } }}/* This function is called by the Windows function DispatchMessage() */LRESULT CALLBACK WindowProcedure (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) { switch (message) { /* handle the messages */ case WM_CREATE: { ma.init(); GetClientRect (hwnd, &amp;client_rect) ; WIDTH=client_rect.right-client_rect.left ; HEIGHT=client_rect.bottom-client_rect.top ; score_height=HEIGHT/10; width=WIDTH/ma.getN(); height=(HEIGHT-score_height)/ma.getN(); InvalidateRect (hwnd,NULL, true) ; } break; case WM_DESTROY: PostQuitMessage (0); /* send a WM_QUIT to the message queue */ break; case WM_LBUTTONUP: { GetCursorPos(&amp;pc); ScreenToClient(hwnd,&amp;pc); mouse-&gt;x=pc.x; mouse-&gt;y=pc.y; sou_dest(hwnd,hdc); } break; case WM_RBUTTONUP: { show_score(hwnd,&quot;&quot;,&quot;&#x5F97;&#x5206;&quot;); } break; case WM_PAINT: { hdc = BeginPaint (hwnd, &amp;ps) ; init_GUI(hwnd,hdc); if(paint_path) { paint_lattice(s_lattice,hdc,BLANK); paint_lattice(d_lattice,hdc,path_color); } EndPaint (hwnd, &amp;ps) ; } break; default: /* for messages that we don&apos;t deal with */ return DefWindowProc (hwnd, message, wParam, lParam); } return 0;} matrix.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//matrix.h#ifndef MATRIX_H_INCLUDED#define MATRIX_H_INCLUDED#pragma once#define BLANK 0#define RED 1#define GREEN 2#define BLUE 3#define YELLOW 4#define PURPLE 5class Point {private :public: int x; int y; Point(int xx,int yy); Point(); bool operator ==(Point p); Point&amp; operator =(Point p); void show();};class node {public : int x; int y; node* father; node(); node(int xx,int yy,node* f);};template&lt;class T&gt;class LinkNode {private:public: T po; LinkNode* next; LinkNode(T pp); LinkNode&amp; operator=(LinkNode nn); void show_node();};template &lt;class T&gt;class Link {private: LinkNode&lt;T&gt;* head=NULL; LinkNode&lt;T&gt;* p=NULL; LinkNode&lt;T&gt;* tail=NULL;public: friend class Matrix; void seek_to_first(); T get_first(); T remove_first(); T get_next(); void add_to_first(T t); void add_to_last(T t); void show_link();};class Matrix {private: int N=10; int COLOR_NUM=5; int** matrix; int max_random_set_num=5; int get_random_num(int x); void print_matrix() ; bool random_set_one() ; bool is_out(int x,int y) ;public: int getN() ; Matrix() ; void init(); void set_flag(Point* p,int color) ; void set_blank(Point* p); bool is_in_que(int** in,int x,int y) ; void get_path(Point *s,Point* dest,Link&lt;Point *&gt; *&amp;l) ; void random_set(int n) ; int get_color(Point *p) ; int get_color(int x,int y); int sget_color(int dir,int x,int y,int n,int color); void test_line(int x,int y,int dir,int &amp;score); int eliminate(int &amp; score) ; bool is_all_not_blank();};#endif // MATRIX_H_INCLUDED matrix.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288 //matrix.cpp#include &quot;matrix.h&quot;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;stdio.h&gt;Point::Point(int xx,int yy) { x=xx; y=yy;}Point::Point() {}bool Point::operator ==(Point p) { return x==p.x&amp;y==p.y;}Point&amp; Point::operator =(Point p) { x=p.x; y=p.y;}void Point::show() { printf(&quot;(%d,%d)-&gt;&quot;,x,y);}node::node() {}node::node(int xx,int yy,node* f) { x=xx; y=yy; father=f;}template&lt;class T&gt;LinkNode&lt;T&gt;::LinkNode(T pp) { po=pp; next=NULL;}template&lt;class T&gt;LinkNode&lt;T&gt;&amp; LinkNode&lt;T&gt;::operator=(LinkNode&lt;T&gt; nn) { po=nn.p; next=nn.next;}template&lt;class T&gt;void LinkNode&lt;T&gt;::show_node() { po-&gt;show();}template&lt;class T&gt;void Link&lt;T&gt;::seek_to_first() { p=head;}template&lt;class T&gt;T Link&lt;T&gt;::get_first() { return head==NULL?NULL:head-&gt;po;}template&lt;class T&gt;T Link&lt;T&gt;::remove_first() { if(head==NULL)return NULL; T *temp=&amp;(head-&gt;po); head=head-&gt;next; return *temp;}template&lt;class T&gt;T Link&lt;T&gt;::get_next() { if(p==tail)return NULL; if(p==NULL)return NULL; if(p-&gt;next==NULL)return NULL; p=p-&gt;next; return p-&gt;po;}template&lt;class T&gt;void Link&lt;T&gt;::add_to_first(T t) { LinkNode&lt;T&gt;* x=new LinkNode&lt;T&gt;(t); x-&gt;next=head; head=x; if(tail=NULL) { tail=head; return ; }}template&lt;class T&gt;void Link&lt;T&gt;::add_to_last(T t) { LinkNode&lt;T&gt;* x=new LinkNode&lt;T&gt;(t); if(head==NULL) { head=x; x-&gt;next=NULL; tail=x; return ; } tail-&gt;next=x; x-&gt;next=NULL; tail=x;}template&lt;class T&gt;void Link&lt;T&gt;::show_link() { printf(&quot;show_link:\n&quot;); p=head; while(p!=NULL) { p-&gt;show_node(); p=p-&gt;next; } printf(&quot;\n&quot;);}int Matrix::get_random_num(int x) { int n=rand()%x; return n;}void Matrix::print_matrix() { printf(&quot;matrix:\n&quot;); for(int i=0; i&lt;N; i++) { for(int j=0; j&lt;N; j++) { printf(&quot;%d&quot;,matrix[i][j]); } printf(&quot;\n&quot;); }}bool Matrix::random_set_one() { int x=get_random_num(N),y=get_random_num(N); if(matrix[x][y]!=BLANK) { return false; } Point *p=new Point(x,y); set_flag(p,get_random_num(COLOR_NUM)+1); return true;}bool Matrix::is_out(int x,int y) { return x&lt;0|x&gt;=N|y&lt;0|y&gt;=N;}int Matrix::getN() { return N;}Matrix::Matrix() { matrix=new int*[N]; for(int i=0; i&lt;N; i++) { matrix[i]=new int[N]; for(int j=0; j&lt;N; j++) { matrix[i][j]=BLANK; } } srand(time(0));}void Matrix::init() { random_set(N*N/4); //print_matrix();}void Matrix::set_flag(Point* p,int color) { matrix[p-&gt;x][p-&gt;y]=color;}void Matrix::set_blank(Point* p) { matrix[p-&gt;x][p-&gt;y]=BLANK;}bool Matrix::is_in_que(int** in,int x,int y) { return false;}void Matrix::get_path(Point *s,Point* dest,Link&lt;Point *&gt; *&amp;l) { if(!(get_color(s)!=BLANK&amp;&amp;get_color(dest)==BLANK))return ; static int xc[4]= {-1,1,0,0}; static int yc[4]= {0,0,-1,1}; int xt,yt; Link&lt;node*&gt; que; node* temp=new node(s-&gt;x,s-&gt;y,NULL); que.add_to_last(temp); node* dest_node; bool flag=true; bool** in=new bool*[N]; for(int i=0; i&lt;N; i++) { in[i]=new bool[N]; for(int j=0; j&lt;N; j++) { in[i][j]=false; } } in[temp-&gt;x][temp-&gt;y]=true; while(flag&amp;&amp;que.get_first()!=NULL) { temp=que.remove_first(); if(temp==NULL) { break; } for(int i=0; i&lt;4; i++) { xt=temp-&gt;x+xc[i]; yt=temp-&gt;y+yc[i]; if((!is_out(xt,yt))&amp;&amp;(!in[xt][yt])) { node* new_node=new node(xt,yt,temp); if(xt==dest-&gt;x&amp;&amp;yt==dest-&gt;y) { dest_node=new_node; flag=false; break; } if(get_color(xt,yt)==BLANK) { in[xt][yt]=true; que.add_to_last(new_node); } } } } if(flag) { return ; } node *n=dest_node; while(n!=NULL) { Point *lp=new Point(n-&gt;x,n-&gt;y); l-&gt;add_to_first(lp); n=n-&gt;father; }}void Matrix::random_set(int n) { int i=0; srand(time(0)); int try_time=0; while(i&lt;n&amp;&amp;try_time&lt;N*N*N) { try_time++; if(random_set_one()) { i++; } } return ;}int Matrix::get_color(Point *p) { return matrix[p-&gt;x][p-&gt;y];}int Matrix::get_color(int x,int y) { return matrix[x][y];}int Matrix::sget_color(int dir,int x,int y,int n,int color) { switch(dir) { case 0: y+=n; break; case 1: x+=n; y+=n; break; case 2: x+=n; break; case 3: x+=n; y-=n; } if(is_out(x,y)) { return -1; } if(color!=-1) { matrix[x][y]=color; return -1; } return get_color(x,y);}void Matrix::test_line(int x,int y,int dir,int &amp;score) { int color=get_color(x,y); if(color==BLANK)return ; for(int k=0; k&lt;5; k++) { if(sget_color(dir,x,y,k,-1)!=color) { return ; } } int k=0; for( ;; k++) { if(sget_color(dir,x,y,k,-1)!=color)break; sget_color(dir,x,y,k,BLANK); } score+=k;}int Matrix::eliminate(int &amp; score) { for(int i=0; i&lt;N; i++) { for(int j=0; j&lt;N; j++) { for(int k=0; k&lt;4; k++) { test_line(i,j,k,score); } } }}bool Matrix::is_all_not_blank() { for(int i=0; i&lt;N; i++) { for(int j=0; j&lt;N; j++) { if(matrix[i][j]==BLANK) { return false; } } } return true;} &#x65E7;&#x51FD;&#x6570;:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// int tree(node * n,node* father,Point* dest,node * temp)// {// static int xc[4]= {-1,1,0,0};// static int yc[4]= {0,0,-1,1};// if(n==NULL)// {// return -1;// }// printf(&quot;n:(%d,%d) &quot;,n-&gt;x,n-&gt;y);// n-&gt;father=father;// int xt,yt;// Link&lt;Point *&gt; nei;// printf(&quot;neis: &quot;);// for(int i=0; i&lt;4; i++)// {// xt=n-&gt;x+xc[i];// yt=n-&gt;y+yc[i];// if((!is_out(xt,yt))&amp;&amp;nn[xt][yt].father==NULL&amp;&amp;nn[xt][yt].father==temp)// {//// if(xt==dest-&gt;x&amp;&amp;yt==dest-&gt;y)// {// printf(&quot;(%d,%d) &quot;,xt,yt);// nn[xt][yt].father=n;// return 0;// }// if(get_color(xt,yt)==BLANK)// {// printf(&quot;(%d,%d) &quot;,xt,yt);// Point *ptemp=new Point(xt,yt);// nei.add_to_first(ptemp);// nn[xt][yt].father=n;// }// }// }// printf(&quot;\n&quot;);// nei.seek_to_first();// Point *pp;// if((pp=nei.get_first())!=NULL){// if(tree(&amp;nn[pp-&gt;x][pp-&gt;y],n,dest,temp)==0)return 0;// }// while((pp=nei.get_next())!=NULL){// if(tree(&amp;nn[pp-&gt;x][pp-&gt;y],n,dest,temp)==0)return 0;// }// return 1;// }// void get_path(Point *s,Point* dest,Link&lt;Point *&gt; *&amp;l)// {// printf(&quot;1\n&quot;);// node* temp=new node;// tree(&amp;nn[s-&gt;x][s-&gt;y],temp,dest,temp);// printf(&quot;\n\nfathers:\n&quot;);//// for(int i=0; i&lt;N; i++)// {// for(int j=0; j&lt;N; j++)// {// if(nn[i][j].father!=NULL){// printf(&quot;(%d&quot;,nn[i][j].x);// printf(&quot;,%d)&quot;,nn[i][j].y);// printf(&quot;-&gt;(%d&quot;,nn[i][j].father-&gt;x);// printf(&quot;,%d)\n&quot;,nn[i][j].father-&gt;y);// }// }// printf(&quot;\n&quot;);// }//// node* n=&amp;nn[dest-&gt;x][dest-&gt;y];//// while(n!=temp)// {// Point *lp=new Point(n-&gt;x,n-&gt;y);// l-&gt;add_to_first(lp);// n=n-&gt;father;// }// printf(&quot;3\n&quot;);// } &#x7A0B;&#x5E8F;&#x5199;&#x4E8E;&#x5927;&#x4E09;&#x4E0B;&#x5B66;&#x671F;&#xFF0C;2016&#x5E74;3&#x6708;&#x3002; 2016.4.12&#x66F4;&#x65B0;&#x535A;&#x5BA2;&#x3002;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[科学计算器（JAVA实现）]]></title>
      <url>2016%2F03%2F13%2F%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%99%A8Java%2F</url>
      <content type="text"><![CDATA[&#x524D;&#x8BB0;&#xFF1A;&#x3000;&#x3000;&#x3000;&#x3000;&#x5927;&#x4E8C;&#x5B66; Java &#x7684;&#x65F6;&#x5019;&#x5199;&#x7684;&#xFF0C;&#x73B0;&#x5728;&#x8D34;&#x4E0A;&#x6765;&#xFF0C;&#x53EA;&#x4E3A;&#x7559;&#x5FF5;&#x3002; &#x3000;&#x3000;&#x518D;&#x7FFB;&#x4EE3;&#x7801;&#xFF0C;&#x81EA;&#x5DF1;&#x770B;&#x7740;&#x90FD;&#x5934;&#x75BC;&#x3002;&#x4E00;&#x91CD;&#x91CD;&#x7684; if &#x5D4C;&#x5957;&#xFF0C;&#x5F53;&#x65F6;&#x5199;&#x5F97;&#x8D39;&#x52B2;&#xFF0C;&#x73B0;&#x5728;&#x770B;&#x7740;&#x66F4;&#x8D39;&#x52B2;&#x3002; &#x4EE3;&#x7801;&#x601D;&#x60F3;&#xFF1A;&#x3000;&#x3000;&#x4EE3;&#x7801;&#x7684;&#x5927;&#x81F4;&#x601D;&#x60F3;&#x662F;&#x8FD9;&#x6837;&#xFF1A; &#x3000;&#x3000;&#x3000;&#x3000;&#x9996;&#x5148;&#x5B9A;&#x4E49;&#x4E00;&#x4E2A;&#x7B97;&#x5F0F;&#x5B57;&#x7B26;&#x4E32;&#x3002;&#x7136;&#x540E;&#x7528;&#x6237;&#x901A;&#x8FC7;&#x952E;&#x76D8;&#x6216;&#x9F20;&#x6807;&#x70B9;&#x51FB;&#x6309;&#x94AE;&#x8F93;&#x5165;&#x5B57;&#x7B26;&#xFF0C;&#x6DFB;&#x52A0;&#x5230;&#x7B97;&#x5F0F;&#x5B57;&#x7B26;&#x4E32;&#x672B;&#x5C3E;&#x3002;&#x5728;&#x6BCF;&#x6B21;&#x7528;&#x6237;&#x8F93;&#x5165;&#x5B57;&#x7B26;&#x4E4B;&#x540E;&#xFF0C;&#x5148;&#x5224;&#x65AD;&#x8BE5;&#x5B57;&#x7B26;&#x662F;&#x5426;&#x7B26;&#x5408;&#x7B97;&#x5F0F;&#x8BED;&#x6CD5;&#x89C4;&#x5219;&#xFF08;&#x5982;&#x52A0;&#x53F7;&#x540E;&#x4E0D;&#x80FD;&#x518D;&#x8DDF;&#x52A0;&#x53F7;&#xFF09;&#xFF0C;&#x4E0D;&#x7B26;&#x5408;&#x8BED;&#x6CD5;&#x89C4;&#x5219;&#x7684;&#x5B57;&#x7B26;&#x4E0D;&#x6DFB;&#x52A0;&#x5230;&#x7B97;&#x5F0F;&#x5B57;&#x7B26;&#x4E32;&#x672B;&#x5C3E;&#x3002;&#x5982;&#x679C;&#x7528;&#x6237;&#x8F93;&#x5165;&#x4E86;&#x7B49;&#x53F7;&#xFF0C;&#x5219;&#x8FDB;&#x884C;&#x8BA1;&#x7B97;&#x5E76;&#x5C06;&#x8BA1;&#x7B97;&#x7ED3;&#x679C;&#x663E;&#x793A;&#x51FA;&#x6765;&#x3002; &#x3000;&#x3000;&#x3000;&#x3000;&#x5176;&#x4E2D;&#x8BA1;&#x7B97;&#x8FC7;&#x7A0B;&#x5982;&#x4E0B;&#xFF1A;&gt;&#x3000;&#x3000;&#x3000;&#x3000;&#x9996;&#x5148;&#x5C06;&#x5B57;&#x7B26;&#x4E32;&#x8F6C;&#x5316;&#x4E3A;&#x4E24;&#x4E2A;&#x94FE;&#x8868;&#xFF0C;&#x4E00;&#x4E2A;&#x5B58;&#x50A8;&#x6D6E;&#x70B9;&#x6570;&#xFF0C;&#x4E00;&#x4E2A;&#x5B58;&#x50A8;&#x8FD0;&#x7B97;&#x7B26;&#x3002;&gt;&#x3000;&#x3000;&#x3000;&#x3000;&#x5982; 3 + 2*4 - 4/2&gt;&#x3000;&#x3000;&#x3000;&#x3000;&#x4F1A;&#x88AB;&#x8F6C;&#x6362;&#x4E3A;&#x4E24;&#x4E2A;&#x94FE;&#x8868;&#xFF1A;3 2 4 4 2+ * - /&gt;&#x4E4B;&#x540E;&#x5FAA;&#x73AF;&#x4EE5;&#x4E0B;&#x8FC7;&#x7A0B;&#xFF1A;&gt;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x5728;&#x8FD0;&#x7B97;&#x7B26;&#x94FE;&#x8868;&#x4E2D;&#x627E;&#x5230;&#x8FD0;&#x7B97;&#x4F18;&#x5148;&#x7EA7;&#x6700;&#x9AD8;&#x7684;&#x4E00;&#x4E2A;&#x8FD0;&#x7B97;&#x7B26;&#xFF08;&#x82E5;&#x6709;&#x591A;&#x4E2A;&#xFF0C;&#x53D6;&#x7B2C;&#x4E00;&#x4E2A;&#xFF09;&#x3002;&#x5047;&#x8BBE;&#x5176;&#x4E0B;&#x6807;&#x4E3A; i&#xFF08;&#x5982;&#x5728;&#x4E0A;&#x4F8B;&#x4E2D;&#xFF0C;i = 1 &#xFF09;&#xFF0C;&#x7136;&#x540E;&#x5728;&#x6D6E;&#x70B9;&#x6570;&#x94FE;&#x8868;&#x4E2D;&#x627E;&#x5230;&#x4E0B;&#x6807;&#x4E3A; i &#x548C; i+1 &#x7684;&#x9879;&#xFF0C;&#x8FDB;&#x884C;&#x76F8;&#x5E94;&#x8FD0;&#x7B97;&#x540E;&#xFF0C;&#x5220;&#x9664;&#x8FD9;&#x4E24;&#x9879;&#xFF0C;&#x5E76;&#x628A;&#x7ED3;&#x679C;&#x63D2;&#x5165;&#x8BE5;&#x4F4D;&#x7F6E;&#x3002;&#x5728;&#x8FD0;&#x7B97;&#x7B26;&#x94FE;&#x8868;&#x4E2D;&#x5220;&#x9664;&#x8BE5;&#x8FD0;&#x7B97;&#x7B26;&#x3002;&gt;&#x5982;&#x4E0A;&#x4F8B;&#x4E2D;&#xFF0C;&#x6267;&#x884C;&#x4E00;&#x6B21;&#x8FD0;&#x7B97;&#x540E;&#xFF0C;&#x94FE;&#x8868;&#x4E3A;&#xFF1A;3 8 4 2+ - /&gt;&#x5FAA;&#x73AF;&#x8FDB;&#x884C;&#x5230;&#x6D6E;&#x70B9;&#x6570;&#x94FE;&#x8868;&#x4E2D;&#x53EA;&#x6709;&#x4E00;&#x4E2A;&#x9879;&#x76EE;&#xFF08;&#x4E5F;&#x5373;&#x64CD;&#x4F5C;&#x7B26;&#x94FE;&#x8868;&#x4E3A;&#x7A7A;&#xFF09;&#x3002;&#x8BE5;&#x9879;&#x76EE;&#x5373;&#x4E3A;&#x7B97;&#x5F0F;&#x8BA1;&#x7B97;&#x7ED3;&#x679C;&#x3002; &#x3000;&#x3000;&#x7ECF;&#x6D4B;&#x8BD5;&#xFF0C;&#x7A0B;&#x5E8F;&#x80FD;&#x8FDB;&#x884C;&#x6D6E;&#x70B9;&#x6570;&#x79D1;&#x5B66;&#x8BA1;&#x7B97;&#x3002;&#x80FD;&#x8FDB;&#x884C;&#x8D1F;&#x6570;&#x8BA1;&#x7B97;&#xFF0C;&#x5982; 3--3 &#x3002;&#x4F46;&#x662F;&#x8BA1;&#x7B97; 3---3 &#x65F6;&#x4F1A;&#x51FA;&#x73B0;&#x5F02;&#x5E38;&#x3002; &#x4EE3;&#x7801;&#xFF1A;&#x3000;&#x3000;Calculator.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325package mycalculator;/* * * &#x8BA1;&#x7B97;3---3 &#x4F1A;&#x6709;&#x5F02;&#x5E38; * * * * */import java.awt.*;import java.awt.event.*;import javax.swing.*;import java.util.*;public class Calculator extends JFrame implements ActionListener, KeyListener, MouseListener { final int WIDTH = 440, HEIGHT = 350; GridLayout gridLayout = new GridLayout(4, 4, 5, 5); // &#x52FF;&#x5FD8;&#x521D;&#x59CB;&#x5316; &#x4E0D;&#x521D;&#x59CB;&#x5316;&#x4E0D;&#x4F1A;&#x62A5;&#x9519;&#xFF0C;&#x4F46;&#x9762;&#x677F;&#x662F;&#x7A7A;&#x7684; BorderLayout borderLayout = new BorderLayout(); FlowLayout flowLayout = new FlowLayout(); Container container; // Container cont; JPanel panel, buttonPanel; JButton[] buttons; String[] name; JTextField textField; boolean cleared = true; public Calculator() { super(&quot;Calculator&quot;); container = getContentPane(); // Cont = getContentPane(); // Cont.setLayout(borderLayout); buttonPanel = new JPanel(); panel = new JPanel(); // container = new Container(); // Cont.add(container, borderLayout.CENTER); // panel.setSize(380,380); buttonPanel.setLayout(gridLayout); textField = new JTextField(15); textField.setFont(textField.getFont().deriveFont(Font.BOLD, (float) 32.0)); textField.setEditable(false); textField.setHorizontalAlignment(JTextField.RIGHT); textField.setBackground(Color.GRAY); textField.setForeground(Color.WHITE); panel.add(textField); // textField.setSize(getBounds().width,getBounds().height/3); // textField.setFont(textField.getFont().deriveFont(99)); /* * container.setLayout(borderLayout); container.add(textField, * borderLayout.NORTH); container.add(cont, borderLayout.CENTER); */ container.setLayout(borderLayout); // container.add(textField); container.add(panel, borderLayout.NORTH); container.add(buttonPanel, borderLayout.CENTER); // container.setSize(getBounds().width,getBounds().height); // cont.setSize(getBounds().width,getBounds().height/3*2); buttons = new JButton[16]; name = new String[] { &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;/&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;*&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;-&quot;, &quot;0&quot;, &quot;.&quot;, &quot;=&quot;, &quot;+&quot; }; for (int index = 0; index &lt;= 15; index++) { buttons[index] = new JButton(name[index]); buttons[index].addActionListener(this); buttons[index].setBackground(Color.GRAY); buttons[index].setForeground(Color.WHITE); buttons[index].addKeyListener(this); buttons[index].addMouseListener(this); buttons[index].setFont(buttons[index].getFont().deriveFont( Font.BOLD, (float) 32.0)); // buttons[index].setSize(200, 200); buttonPanel.add(buttons[index]); } this.addKeyListener(this); setSize(WIDTH, HEIGHT); Toolkit kit = Toolkit.getDefaultToolkit(); // &#x5B9A;&#x4E49;&#x5DE5;&#x5177;&#x5305; Dimension screenSize = kit.getScreenSize(); // &#x83B7;&#x53D6;&#x5C4F;&#x5E55;&#x7684;&#x5C3A;&#x5BF8; int screenWidth = screenSize.width; // &#x83B7;&#x53D6;&#x5C4F;&#x5E55;&#x7684;&#x5BBD; int screenHeight = screenSize.height; // &#x83B7;&#x53D6;&#x5C4F;&#x5E55;&#x7684;&#x9AD8; setLocation(screenWidth / 2 - WIDTH / 2, screenHeight / 2 - HEIGHT / 2);// &#x8BBE;&#x7F6E;&#x7A97;&#x53E3;&#x5C45;&#x4E2D;&#x663E;&#x793A; // setLocation(600, 250); setVisible(true); setFocusable(true); } String calculate(String str) { String result = &quot;Wrong Expression&quot;; String temp = &quot;&quot;; if (str.charAt(0) != &apos;-&apos; &amp;&amp; !(str.charAt(0) &lt;= &apos;9&apos; &amp;&amp; str.charAt(0) &gt;= &apos;0&apos;)) { return result; } LinkedList&lt;Double&gt; list = new LinkedList&lt;Double&gt;(); LinkedList&lt;Character&gt; optList = new LinkedList&lt;Character&gt;(); Double doubleTemp; boolean isFormerOpt = true; for (int index = 0; index &lt;= str.length() - 1; index++) { if (index == 0) { isFormerOpt = true; } else { if (str.charAt(index - 1) &gt; &apos;9&apos; || str.charAt(index - 1) &lt; &apos;0&apos;) { isFormerOpt = true; } else { isFormerOpt = false; } } if (str.charAt(index) != &apos;+&apos; &amp;&amp; str.charAt(index) != &apos;*&apos; &amp;&amp; str.charAt(index) != &apos;/&apos; &amp;&amp; (!(str.charAt(index) == &apos;-&apos; &amp;&amp; isFormerOpt == false))) { temp += str.charAt(index); } else { doubleTemp = new Double(temp); list.add(doubleTemp); temp = &quot;&quot;; optList.add(str.charAt(index)); } } doubleTemp = new Double(temp); list.add(doubleTemp); temp = &quot;&quot;; /* * for (int index = 0; index &lt;= list.size() - 1; index++) { * System.out.println(list.get(index)); } for (int index = 0; index &lt;= * optList.size() - 1; index++) { * System.out.println(optList.get(index)); } */ boolean isThereHigherOpt = true; while (isThereHigherOpt == true) { /* * for (Iterator&lt;Character&gt; it = optList.iterator(); it.hasNext();) * { if (it.next() == &apos;*&apos; || it.next() == &apos;/&apos;) { isThereHigherOpt = * true; int index = optList.indexOf(it.next()); * * break; } } */ isThereHigherOpt = false; for (int index = 0; index &lt;= optList.size() - 1; index++) { if (optList.get(index) == &apos;*&apos;) { Double t = list.get(index) * list.get(index + 1); list.remove(index + 1); list.set(index, t); optList.remove(index); isThereHigherOpt = true; break; } if (optList.get(index) == &apos;/&apos;) { Double t = list.get(index) / list.get(index + 1); list.remove(index + 1); list.set(index, t); optList.remove(index); isThereHigherOpt = true; break; } } } while (optList.isEmpty() == false) { for (int index = 0; index &lt;= optList.size() - 1; index++) { if (optList.get(index) == &apos;+&apos;) { Double t = list.get(index) + list.get(index + 1); list.remove(index + 1); list.set(index, t); optList.remove(index); break; } if (optList.get(index) == &apos;-&apos;) { Double t = list.get(index) + 0.0 - list.get(index + 1); list.remove(index + 1); list.set(index, t); optList.remove(index); break; } } } /* * System.out.println(&quot;/////////////////////////////////&quot;); for (int * index = 0; index &lt;= optList.size() - 1; index++) { // * System.out.println(index); System.out.println(list.get(index)); * System.out.println(optList.get(index)); * System.out.println(list.get(index + 1)); } */ if (list.size() == 1) { result = list.get(0).toString(); } return result; } void addText(char ch) { if (cleared == true &amp;&amp; ((ch &lt;= &apos;9&apos; &amp;&amp; ch &gt;= &apos;0&apos;))) { textField.setText(&quot;&quot;); cleared = false; } String str = textField.getText(); if (ch != &apos;=&apos;) { if (str.length() &gt; 0) { if (str.charAt(str.length() - 1) &lt;= &apos;9&apos; &amp;&amp; str.charAt(str.length() - 1) &gt;= &apos;0&apos;) { if (ch != &apos;.&apos;) { textField.setText(str + ch); } else { boolean isTherePoint = false; int i = str.length() - 1; while (i &gt;= 0) { if (str.charAt(i) == &apos;*&apos; || str.charAt(i) == &apos;/&apos; || str.charAt(i) == &apos;+&apos; || str.charAt(i) == &apos;-&apos;) { break; } if (str.charAt(i) == &apos;.&apos;) { isTherePoint = true; break; } i--; } if (isTherePoint == false) { textField.setText(str + ch); } } } else { if ((ch &lt;= &apos;9&apos; &amp;&amp; ch &gt;= &apos;0&apos;) || ch == &apos;-&apos;) { textField.setText(str + ch); } } } else { if (ch == &apos;-&apos; || (ch &lt;= &apos;9&apos; &amp;&amp; ch &gt;= &apos;0&apos;)) textField.setText(str + ch); } cleared = false; } else { if (cleared == true) { textField.setText(&quot;&quot;); } else { str = textField.getText(); //System.out.println(str); textField.setText(&quot;&quot;); if (str.length() &gt; 0) { if (str.charAt(str.length() - 1) &lt;= &apos;9&apos; &amp;&amp; str.charAt(str.length() - 1) &gt;= &apos;0&apos;) { textField.setText(calculate(str)); } else { textField.setText(&quot;Wrong Expression&quot;); } } } cleared = true; } } public void actionPerformed(ActionEvent event) { Object source = event.getSource(); if (source.getClass() == JButton.class) { JButton button = (JButton) source; char ch = button.getText().charAt(0); addText(ch); } } public void keyPressed(KeyEvent e) { } public void keyReleased(KeyEvent e) { } public void keyTyped(KeyEvent e) { char ch = e.getKeyChar(); if (ch == &apos; &apos;) { System.exit(EXIT_ON_CLOSE); } if (ch == KeyEvent.VK_ENTER) { buttons[14].setBackground(Color.LIGHT_GRAY); for (int i = 0; i &lt;= name.length - 1; i++) { if (i != 14) { buttons[i].setBackground(Color.GRAY); } } addText(&apos;=&apos;); return; } for (int index = 0; index &lt;= name.length - 1; index++) { if (ch == name[index].charAt(0)) { // System.out.println(ch); buttons[index].setBackground(Color.LIGHT_GRAY); for (int i = 0; i &lt;= name.length - 1; i++) { if (i != index) { buttons[i].setBackground(Color.GRAY); } } addText(ch); break; } } } public void mouseClicked(MouseEvent event) { } public void mouseEntered(MouseEvent event) { Object source = event.getSource(); if (source.getClass() == JButton.class) { JButton button = (JButton) source; // System.out.println(&quot;hey&quot;); button.setBackground(Color.LIGHT_GRAY); } } public void mousePressed(MouseEvent event) { } public void mouseReleased(MouseEvent event) { } public void mouseExited(MouseEvent event) { Object source = event.getSource(); if (source.getClass() == JButton.class) { JButton button = (JButton) source; // System.out.println(&quot;hey&quot;); button.setBackground(Color.GRAY); } } public static void main(String[] args) { Calculator c = new Calculator(); // c.addKeyListener(c); c.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); }} &#x7A0B;&#x5E8F;&#x8FD0;&#x884C;&#x6548;&#x679C;&#xFF1A;&#x8BA1;&#x7B97;9/3-1*2+-1 &#x7ED3;&#x679C;&#xFF1A; &#x968F;&#x7B14;&#x5199;&#x4E8E;2016.4.8&#x3002; &#x7A0B;&#x5E8F;&#x5199;&#x4E8E;&#x5927;&#x4E8C;&#x4E0B;&#x5B66;&#x671F;&#xFF0C;Java&#x7A0B;&#x5E8F;&#x8BBE;&#x8BA1; &#x8BFE;&#x7A0B;&#x671F;&#x95F4;&#x3002;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[抓鼠标的猫（Win32实现，Codeblocks+GCC编译）]]></title>
      <url>2016%2F03%2F13%2F%E6%8A%93%E9%BC%A0%E6%A0%87%E7%9A%84%E7%8C%AB%2F</url>
      <content type="text"><![CDATA[&#x7A0B;&#x5E8F;&#x6548;&#x679C;&#xFF1A;&#x732B;&#x7684;&#x773C;&#x775B;&#x4E00;&#x76F4;&#x8DDF;&#x7740;&#x9F20;&#x6807;&#x79FB;&#x52A8;&#xFF1A; &#x9F20;&#x6807;&#x7ECF;&#x8FC7;&#x732B;&#x7684;&#x53F3;&#x811A;&#x9644;&#x8FD1;&#x65F6;&#xFF0C;&#x732B;&#x4F1A;&#x6293;&#x4F4F;&#x9F20;&#x6807;&#x3002;&#xFF08;&#x672A;&#x4F7F;&#x7528;Hook&#xFF09; &#x2002;&#x2002;&#x2002;&#x2002; &#x4EE3;&#x7801;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268 //main.cpp#include &lt;windows.h&gt;#include &lt;math.h&gt;//#include &lt;iostream&gt;//using namespace std;LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;double WIDTH=410,HEIGHT=430;double px=0.0,py=0.0;double ppx=0.0,ppy=0.0;POINT sp;int cat=0;double width,height;PAINTSTRUCT ps ;RECT rect ;POINT pts[3];double left_eye_px=0.0,right_eye_px=0.0;double eye_py=0.0;double eye_r=0.0;double k=0.0;double ball_hr=0.0;//&#x534A;&#x5F84;double deltax=0.0;POINT p,pp;int initGraph=1;LPPOINT catp;RECT eye_rect;HBRUSH gray_brush =CreateSolidBrush (RGB(180,180,180));HBRUSH white_brush =CreateSolidBrush (RGB(255,255,255));HBRUSH black_brush =CreateSolidBrush (RGB(0,0,0));int drawRound(HDC hdc,int x,int y,int r) //r &#x76F4;&#x5F84;{ Ellipse(hdc,x-r/2,y-r/2,x+r/2,y+r/2); return 0;}int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow){ static TCHAR szAppName[] = TEXT (&quot;HelloWin&quot;) ; HWND hwnd ; MSG msg ; WNDCLASS wndclass ; wndclass.style = CS_HREDRAW | CS_VREDRAW ; wndclass.lpfnWndProc = WndProc ; wndclass.cbClsExtra = 0 ; wndclass.cbWndExtra = 0 ; wndclass.hInstance = hInstance ; wndclass.hIcon = LoadIcon (NULL, IDI_APPLICATION) ; wndclass.hCursor = LoadCursor (NULL, IDC_ARROW) ; wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ; wndclass.lpszMenuName = NULL ; wndclass.lpszClassName = szAppName ; if (!RegisterClass (&amp;wndclass)) { MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;), szAppName, MB_ICONERROR) ; return 0 ; } hwnd = CreateWindow (szAppName, // window class name TEXT (&quot;Mouse Hook&quot;), // window caption WS_OVERLAPPEDWINDOW, // window style CW_USEDEFAULT, // initial x position CW_USEDEFAULT, // initial y position WIDTH, // initial x size HEIGHT, // initial y size NULL, // parent window handle NULL, // window menu handle hInstance, // program instance handle NULL) ; // creation parameters ShowWindow (hwnd, iCmdShow) ; UpdateWindow (hwnd) ; while (GetMessage (&amp;msg, NULL, 0, 0)) { TranslateMessage (&amp;msg) ; DispatchMessage (&amp;msg) ; } return msg.wParam ;}int init(HWND hwnd){ GetClientRect (hwnd, &amp;rect) ; width=rect.right-rect.left ; height=rect.bottom-rect.top ; left_eye_px=width*3/8-height/16; right_eye_px=width*5/8+height/16; eye_py=height*5/10-height/16; eye_r=height/8; ball_hr=eye_r/8;//&#x534A;&#x5F84; px=left_eye_px; py=eye_py; ppx=right_eye_px; ppy=eye_py; eye_rect.left=left_eye_px-eye_r/2; eye_rect.right=right_eye_px+eye_r/2; eye_rect.top=eye_py-eye_r/2; eye_rect.bottom=eye_py+eye_r/2; return 0;}int drawHand(HDC hdc){ /**&lt; &#x753B;&#x5634; */ if(cat==0) { MoveToEx (hdc, width/4+width/10,height/48*33, NULL) ; LineTo (hdc, width*3/4-width/10, height/48*33) ; SelectObject (hdc,gray_brush ) ; Ellipse(hdc,width/4-width/20,height/4*3,width/4+width/20,height*1.1);//&#x5DE6;&#x80F3;&#x818A; Ellipse(hdc,width/4*3-width/20,height/4*3,width/4*3+width/20,height*1.1);//&#x53F3;&#x80F3;&#x818A; return 0; } SelectObject (hdc, gray_brush) ; Ellipse(hdc,width/4*3-width/20,height/4*3,width/4*3+width/20,height*1.1);//&#x53F3;&#x80F3;&#x818A; Ellipse(hdc,width/4-width/20,height-height/4,width/4+width/20,height);//&#x5DE6;&#x80F3;&#x818A; /**&lt; &#x753B;&#x811A;&#x638C; */ Ellipse(hdc,width/4-width/12,height-height/7,width/4+width/12,height); MoveToEx (hdc, width/4-width/15,height-height/9, NULL) ; LineTo (hdc, width/4-width/16, height-height/15) ; MoveToEx (hdc, width/4,height-height/7, NULL) ; LineTo (hdc, width/4, height-height/16) ; MoveToEx (hdc, width/4+width/15,height-height/9, NULL) ; LineTo (hdc, width/4+width/16, height-height/15) ; Arc( hdc, width/4-width/18, height-height/16,width/4+width/18, height,width/4+width/16, height,width/4-width/16, height); /**&lt; &#x753B;&#x5634; */ Arc( hdc, width*1/4+width/10, height/48*27,width*3/4-width/10, height/48*33,width*1/4, height/48*30, width*3/4, height/48*30); return 0;}LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam){ POINT pc; HDC hdc; switch (message) { case WM_CREATE: init(hwnd); initGraph =1; InvalidateRect (hwnd,NULL, true) ; return 0 ; case WM_SIZE: init(hwnd); initGraph =1; InvalidateRect (hwnd,NULL, true) ; return 0; case WM_MOVE: return 0; case WM_LBUTTONDOWN: GetCursorPos(&amp;pc); if(pc.x==sp.x&amp;&amp;pc.y==sp.y) { cat=0; SetCursorPos(sp.x,sp.y-height/2); ReleaseCapture () ; initGraph=1; InvalidateRect (hwnd,NULL, true) ; } return 0 ; case WM_MOUSEMOVE: if(cat==1) { SetCursorPos(sp.x,sp.y); return 0; } GetCursorPos(&amp;p); pp=p; ScreenToClient(hwnd,&amp;pp); if((pp.x&gt;width/4-width/12)&amp;&amp;(pp.x&lt;width/4+width/12)&amp;&amp;(pp.y&gt;height-height/7)&amp;&amp;(pp.y&lt;height)) { SetCapture (hwnd) ; sp.x=width/4; sp.y=height-height/14; ClientToScreen(hwnd,&amp;sp); cat=1; initGraph=1; InvalidateRect (hwnd,NULL, true) ; return 0; } k=999.0; if(pp.x-left_eye_px!=0) { k=(pp.y-eye_py)/(pp.x-left_eye_px); } deltax=(ball_hr/4)/(1+k*k); deltax=sqrt(deltax); if(!(pp.x&gt;left_eye_px)) { deltax=(-1.0)*deltax; } px=left_eye_px+deltax*8; deltax=(ball_hr/4)/(1+1/(k*k)); deltax=sqrt(deltax); if(!(pp.y&gt;eye_py)) { deltax=(-1.0)*deltax; } py=eye_py+deltax*8; k=999.0; if(pp.x-right_eye_px!=0) { k=(pp.y-eye_py)/(pp.x-right_eye_px); } deltax=(ball_hr/4)/(1+k*k); deltax=sqrt(deltax); if(!(pp.x&gt;right_eye_px)) { deltax=(-1.0)*deltax; } ppx=right_eye_px+deltax*8; deltax=(ball_hr/4)/(1+1/(k*k)); deltax=sqrt(deltax); if(!(pp.y&gt;eye_py)) { deltax=(-1.0)*deltax; } ppy=eye_py+deltax*8; InvalidateRect (hwnd, &amp;eye_rect, false) ; return 0 ; case WM_PAINT: hdc=BeginPaint (hwnd,&amp;ps) ; if(initGraph==1) { SelectObject (hdc, gray_brush) ; Ellipse(hdc,width/6,height/2,width-width/6,height*3/2);//&#x8EAB;&#x4F53; /**&lt; &#x753B;&#x8138; */ Ellipse(hdc,0,height/4,width*20/20,height*3/4); /**&lt; &#x753B;&#x8033;&#x6735; */ pts[0].x =width/4; pts[0].y =height/10; pts[1].x =width/8; pts[1].y =height/9*3; pts[2].x =width/8*3; pts[2].y =height/33*9; Polygon (hdc, pts, 3) ; pts[0].x =width/4*3; pts[0].y =height/10; pts[1].x =width/8*7; pts[1].y =height/9*3; pts[2].x =width/8*5; pts[2].y =height/33*9; Polygon (hdc, pts, 3) ; /**&lt; &#x753B;&#x80E1;&#x5B50; */ MoveToEx (hdc, 0, height/48*27, NULL) ; LineTo (hdc, width/8*2,height/48*27) ; MoveToEx (hdc, 0, height/48*30, NULL) ; LineTo (hdc, width/8*2,height/48*30) ; MoveToEx (hdc, 0, height/48*33, NULL) ; LineTo (hdc, width/8*2,height/48*33) ; MoveToEx (hdc, width, height/48*27, NULL) ; LineTo (hdc, width/8*6,height/48*27) ; MoveToEx (hdc, width, height/48*30, NULL) ; LineTo (hdc, width/8*6,height/48*30) ; MoveToEx (hdc, width, height/48*33, NULL) ; LineTo (hdc, width/8*6,height/48*33) ; drawHand(hdc); initGraph=0; } /**&lt; &#x753B;&#x773C;&#x775B; */ SelectObject (hdc, white_brush) ; drawRound(hdc,left_eye_px,eye_py,eye_r); drawRound(hdc,right_eye_px,eye_py,eye_r); SelectObject (hdc, black_brush) ; drawRound(hdc,px,py,ball_hr*2); drawRound(hdc,ppx,ppy,ball_hr*2); EndPaint (hwnd, &amp;ps) ; return 0 ; case WM_DESTROY: PostQuitMessage (0) ; return 0 ; } return DefWindowProc (hwnd, message, wParam, lParam) ;} &#x7A0B;&#x5E8F;&#x5199;&#x4E8E;&#x5927;&#x4E09;&#x4E0A;&#x5B66;&#x671F;&#xFF0C;Windows&#x7A0B;&#x5E8F;&#x8BBE;&#x8BA1; &#x8BFE;&#x7A0B;&#x8003;&#x6838;&#x4F5C;&#x4E1A;&#x3002; 2016.4.12&#x66F4;&#x65B0;&#x535A;&#x5BA2;&#x3002;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[爬虫（Java实现）]]></title>
      <url>2016%2F03%2F13%2F%E7%88%AC%E8%99%AB%2F</url>
      <content type="text"><![CDATA[&#x8BF4;&#x660E;&#xFF1A;&#x4F7F;&#x7528;&#x4E86;htmlparser&#x5E93;&#x3002; &#x8FD0;&#x884C;&#x8FC7;&#x7A0B;&#xFF1A;&#x3000;&#x3000;&#x3000;&#x3000;&#x4ECE;&#x67D0;&#x4E2A;&#x7F51;&#x5740;&#x5F00;&#x59CB;&#xFF0C;&#x6458;&#x53D6;&#x7F51;&#x9875;&#x4E2D;&#x7684;&#x94FE;&#x63A5;&#xFF0C;&#x5E76;&#x901A;&#x8FC7;&#x5E7F;&#x5EA6;&#x641C;&#x7D22;&#xFF0C;&#x5BF9;&#x8FD9;&#x4E9B;&#x94FE;&#x63A5;&#x9012;&#x5F52;&#x6267;&#x884C;&#x4E0A;&#x8FF0;&#x64CD;&#x4F5C;&#x3002; &#x3000;&#x3000;&#x3000;&#x3000;&#x5728;&#x4EE5;&#x4E0A;&#x8FC7;&#x7A0B;&#x4E2D;&#x628A;&#x7F51;&#x5740;&#x5B58;&#x5165;&#x6570;&#x636E;&#x5E93;&#x4E2D;&#x3002;&#x4EE5;&#x9632;&#x6B62;&#x641C;&#x7D22;&#x4E2D;&#x51FA;&#x73B0;&#x73AF;&#x8DEF;&#x3002; &#x3000;&#x3000;&#x3000;&#x3000;&#x4F46;&#x662F;&#xFF0C;&#x7A0B;&#x5E8F;&#x7ECF;&#x5E38;&#x8FDB;&#x5165;&#x67D0;&#x4E2A;&#x7F51;&#x7AD9;&#x540E;&#xFF0C;&#x4F1A;&#x4E00;&#x76F4;&#x626B;&#x63CF;&#x5176;&#x4E2D;&#x7684;&#x4E8C;&#x7EA7;&#x57DF;&#x540D;&#x3002; &#x3000;&#x3000;&#x3000;&#x3000;&#x4E8E;&#x662F;&#x6570;&#x636E;&#x5E93;&#x4E2D;&#x4F1A;&#x51FA;&#x73B0;&#x8FD9;&#x79CD;&#x60C5;&#x51B5;&#xFF1A;&gt;jack.art.comhan.art.combob.art.comalice.art.comrose.art.com&#x2026;&#x2026; &#x4EE3;&#x7801;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126//Robot.javapackage robot;import java.net.*;import java.sql.SQLException;import java.util.Random;import javax.swing.JOptionPane;import org.htmlparser.*;import org.htmlparser.filters.TagNameFilter;import org.htmlparser.tags.LinkTag;import org.htmlparser.util.NodeList;import org.htmlparser.util.ParserException;import mydb.DB;public class Robot { int ff=0; int num=0; //DB db; Robot() throws MalformedURLException, SQLException{ DB.getConnect(&quot;localhost&quot;,&quot;3306&quot;,&quot;robot&quot;,&quot;root&quot;,&quot;142365&quot;); DB.getSta(); String url0=&quot;http://www.youku.com&quot;;//&quot;http://localhost&quot;; /* DB.rs= DB.s.executeQuery(&quot;select count(*) from urls&quot;); if(DB.rs.next()) {int n=DB.rs.getInt(1); System.out.println(n ); Random random = new Random(); int ran = random.nextInt(); ran%=n; ran=ran&gt;0?ran:-ran; System.out.println(ran ); DB.rs= DB.s.executeQuery(&quot;select * from urls&quot;); int x=0; while(DB.rs.next()&amp;&amp;x&lt;ran){ System.out.println(DB.rs.getString(1)+&quot;000&quot; ); url0=DB.rs.getString(1); x++; } }*/ //catchHref(&quot;http://localhost&quot;,num); catchHref(url0,num); } boolean isEndLegal(String str){ if(str.endsWith(&quot;php&quot;)||str.endsWith(&quot;net/&quot;)||str.endsWith(&quot;com/&quot;)||str.endsWith(&quot;cn/&quot;)||str.endsWith(&quot;gov/&quot;)||str.endsWith(&quot;edu/&quot;)||str.endsWith(&quot;org/&quot;)||str.endsWith(&quot;net&quot;)||str.endsWith(&quot;com&quot;)||str.endsWith(&quot;cn&quot;)||str.endsWith(&quot;gov&quot;)||str.endsWith(&quot;edu&quot;)||str.endsWith(&quot;org&quot;)){ return true; } return false; } boolean catchHref(String hreft ,int num) throws MalformedURLException { Parser parser =null; NodeList nodelist=null; String href = &quot;http://www.baidu.com&quot;; //db=new DB(); if(ff!=0) if (!(hreft.startsWith(&quot;http&quot;)&amp;&amp;isEndLegal(hreft)&amp;&amp;!isInDatabase(hreft))) { return false; } ff=1; add(hreft); System.out.println(num); try { parser = new Parser(hreft); if(parser==null)return false; } catch (ParserException e) { return false; //e.printStackTrace(); } try { nodelist = parser.parse(null); } catch (ParserException e1) { e1.printStackTrace(); } if(nodelist==null)return false; NodeFilter filter = new TagNameFilter(&quot;A&quot;); if(filter==null)return false; nodelist = nodelist.extractAllNodesThatMatch(filter, true); if(nodelist==null)return false; for (int i = 0; i &lt; nodelist.size(); i++) { LinkTag link = (LinkTag) nodelist.elementAt(i); href = link.getAttribute(&quot;href&quot;); if(href==null)return false; System.out.println(href ); catchHref(href,num); } num++; return true; }void add(String str){ try { DB.s.execute(&quot;insert into urls2(url)values(&apos;&quot;+str+&quot;&apos;);&quot;); DB.commit(); System.out.println(&quot;add&quot;); } catch (SQLException e) { //e.printStackTrace();return ; //JOptionPane.showMessageDialog(null, &quot;&#x6570;&#x636E;&#x5E93;&#x6DFB;&#x52A0;&#x5931;&#x8D25;&quot;); //System.exit(-1); } return ; } boolean isInDatabase(String str){ try { DB.rs= DB.s.executeQuery(&quot;select * from urls where url like&apos;&quot;+str+&quot;%&apos;;&quot;); if(DB.rs.next()){System.out.println(DB.rs);return true;} } catch (SQLException e) { e.printStackTrace(); JOptionPane.showMessageDialog(null, &quot;&#x6570;&#x636E;&#x5E93;&#x67E5;&#x627E;&#x5931;&#x8D25;&quot;); System.exit(-1); } return false; } public static void main(String[] args) throws MalformedURLException, ParserException, SQLException { Robot robot = new Robot(); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//DB.javapackage mydb;import java.sql.*;import java.util.ArrayList;import javax.swing.*;//import com.mysql.jdbc.Driver;public class DB { public static Connection conn = null; public static ResultSet rs = null; public static Statement s = null; public DB() { conn = null; s = null; rs=null; } /* String getResult(ResultSet rs) { String str = &quot;Book\t\tOwnerID\tOwnerName\n&quot;; // System.out.println(&quot;\nno\tname\tsex\tsalary&quot;); try { while (rs.next()) { StringBuilder builder = new StringBuilder(rs.getString(1)); builder.append(&quot;\t\t&quot;); builder.append(rs.getString(2)); builder.append(&quot;\t&quot;); builder.append(rs.getString(3)); builder.append(&quot;\n&quot;); str += builder.toString(); } } catch (Throwable e) { } // System.out.println(); return str; }*/ public static Connection getConnect(String IP,String port,String database,String user,String password){ try { // Class.forName(&quot;org.gjt.mm.mysql.Driver&quot;).newInstance(); Class.forName(&quot;com.mysql.jdbc.Driver&quot;); } catch (ClassNotFoundException e1) { e1.printStackTrace(); JOptionPane.showMessageDialog(null, &quot;&#x6570;&#x636E;&#x5E93;&#x5305;&#x672A;&#x627E;&#x5230;&quot;); System.exit(-1); } // .newInstance(); try { conn = DriverManager.getConnection( &quot;jdbc:mysql://&quot;+IP+&quot;:&quot;+port+&quot;/&quot;+database+&quot;?useUnicode=true&amp;characterEncoding=utf8&quot;, user, password);//autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf8 } catch (SQLException e1) { e1.printStackTrace(); JOptionPane.showMessageDialog(null, &quot;&#x6570;&#x636E;&#x5E93;&#x65E0;&#x6CD5;&#x8FDE;&#x63A5;&quot;); System.exit(-1); } try { conn.setAutoCommit(false); } catch (SQLException e1) { e1.printStackTrace(); } return conn; } public static Statement getSta(){ try { s = conn.createStatement(); } catch (SQLException e1) { e1.printStackTrace(); JOptionPane.showMessageDialog(null, &quot;&#x65E0;&#x6CD5;&#x5EFA;&#x7ACB;&#x6570;&#x636E;&#x5E93;&#x8BED;&#x53E5;&quot;); System.exit(-1); } return s; } public static int commit(){ try { conn.commit(); } catch (SQLException e) { e.printStackTrace(); JOptionPane.showMessageDialog(null, &quot;&#x5BF9;&#x6570;&#x636E;&#x5E93;&#x66F4;&#x6539;&#x65E0;&#x6CD5;&#x5E94;&#x7528;&quot;); } return 0; } public static void closeConnect() { try { rs.close(); } catch (SQLException e) { e.printStackTrace(); JOptionPane.showMessageDialog(null, &quot;&#x6570;&#x636E;&#x5E93;&#x7ED3;&#x679C;&#x96C6;&#x65E0;&#x6CD5;&#x5173;&#x95ED;&quot;); } try { s.close(); } catch (SQLException e) { e.printStackTrace(); JOptionPane.showMessageDialog(null, &quot;&#x6570;&#x636E;&#x5E93;&#x8BED;&#x53E5;&#x65E0;&#x6CD5;&#x5173;&#x95ED;&quot;); } try { conn.close(); } catch (SQLException e) { e.printStackTrace(); JOptionPane.showMessageDialog(null, &quot;&#x4E0E;&#x6570;&#x636E;&#x5E93;&#x7684;&#x8FDE;&#x63A5;&#x65E0;&#x6CD5;&#x5173;&#x95ED;&quot;); }/* try { // perform a clean shutdown DriverManager.getConnection(&quot;jdbc:derby:;shutdown=true&quot;); } catch (SQLException se) { if (((se.getErrorCode() == 50000) &amp;&amp; (&quot;XJ015&quot;.equals(se.getSQLState())))) { // we got the expected exception System.out.println(&quot;Derby shut down normally&quot;); // Note that for single database shutdown, the expected // SQL state is &quot;08006&quot;, and the error code is 45000. } else { System.err.println(&quot;Derby did not shut down normally&quot;); // JOptionPane.showMessageDialog(null, &quot;&#x6570;&#x636E;&#x5E93;&#x5173;&#x95ED;&#x9519;&#x8BEF;&quot;); se.printStackTrace(); } }*/ }} &#x7A0B;&#x5E8F;&#x5199;&#x4E8E;&#x5927;&#x4E09;&#x4E0A;&#x5B66;&#x671F;&#x3002; 2016.4.12&#x66F4;&#x65B0;&#x535A;&#x5BA2;&#x3002;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[贪吃蛇（C++实现，VC6.0编译，使用了EasyX图形库）]]></title>
      <url>2016%2F03%2F13%2F%E8%B4%AA%E5%90%83%E8%9B%87%2F</url>
      <content type="text"><![CDATA[&#x7A0B;&#x5E8F;&#x6548;&#x679C;&#xFF1A; &#x2002;&#x2002;&#x2002;&#x2002; &#x4EE3;&#x7801;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404 //main.cpp#include &lt;iostream&gt;#include&lt;fstream&gt;#include &lt;graphics.h&gt;#include &lt;conio.h&gt;#include&lt;ctime&gt;#include&lt;windows.h&gt;#include&lt;mmsystem.h&gt;#pragma comment(lib,&quot;Winmm.lib&quot;)#define IMGWIDTH 20#define IMGHEIGHT 20#define WIDTH 1100#define HEIGHT 650#define UP 72#define DOWN 80#define LEFT 75#define RIGHT 77#define HEADUP &quot;headup.jpg&quot;#define HEADDOWN &quot;headdown.jpg&quot;#define HEADLEFT &quot;headleft.jpg&quot;#define HEADRIGHT &quot;headright.jpg&quot;#define BODYLR &quot;bodylr.jpg&quot;#define BODYUD &quot;bodyud.jpg&quot;#define TAILL &quot;taill.jpg&quot;#define TAILR &quot;tailr.jpg&quot;#define TAILU &quot;tailu.jpg&quot;#define TAILD &quot;taild.jpg&quot;#define WALL &quot;wall.jpg&quot;#define FOOD &quot;food.jpg&quot;#define GAMEOVER &quot;gameover.jpg&quot;#define SNAKE &quot;snake.jpg&quot;#define L 60 //&#x5DE6;#define U 80 //&#x4E0A;#define R 900 //&#x53F3;#define D 600 //&#x4E0B;using namespace std;IMAGE wallimg;int score=0,grade=1,rec[4];class Food;class BodyNode{private: IMAGE img; int x; int y; BodyNode* next; BodyNode(){} friend class Body; friend bool check(Body&amp; snake,Food&amp; food);public: BodyNode(char* str,int X,int Y){ x=X; y=Y; loadimage(&amp;img, _T(str)); next=NULL; } BodyNode(BodyNode&amp; bodynode){ x=bodynode.x; y=bodynode.y; next=bodynode.next; img=bodynode.img; }};class Body{private: BodyNode* head; BodyNode* tail; int length;public: friend bool check(Body&amp; snake,Food&amp; food); Body(){ head=new BodyNode(HEADRIGHT,L+(10*(IMGWIDTH)),U+(10*(IMGHEIGHT))); head-&gt;next=new BodyNode(BODYLR,head-&gt;x-head-&gt;img.getwidth(),head-&gt;y); head-&gt;next-&gt;next=new BodyNode(TAILR,head-&gt;next-&gt;x-head-&gt;img.getwidth(),head-&gt;y); tail=head-&gt;next-&gt;next; length=2; } int Length(){return length;} bool IsDead(){ BodyNode* p=head-&gt;next; while(p!=NULL){ if(head-&gt;x==p-&gt;x&amp;&amp;head-&gt;y==p-&gt;y){ return true; } p=p-&gt;next; } return false; } int Move(int dir){ //1 &#x4E0A; 2&#x4E0B; 3&#x5DE6; 4 &#x53F3; BodyNode* p=head-&gt;next; int tempx=head-&gt;x,tempy=head-&gt;y,temp_x,temp_y; while(p!=tail-&gt;next){ temp_x=p-&gt;x; temp_y=p-&gt;y; p-&gt;x=tempx;; p-&gt;y=tempy; tempx=temp_x; tempy=temp_y; p=p-&gt;next; } if(dir==1){ loadimage(&amp;(head-&gt;img), _T(HEADUP)); head-&gt;y=head-&gt;next-&gt;y-head-&gt;img.getheight(); } if(dir==2){ loadimage(&amp;(head-&gt;img), _T(HEADDOWN)); head-&gt;y=head-&gt;next-&gt;y+head-&gt;img.getheight(); } if(dir==3){ loadimage(&amp;(head-&gt;img), _T(HEADLEFT)); head-&gt;x=head-&gt;next-&gt;x-head-&gt;img.getwidth(); } if(dir==4){ loadimage(&amp;(head-&gt;img), _T(HEADRIGHT)); head-&gt;x=head-&gt;next-&gt;x+head-&gt;img.getwidth(); } if((head-&gt;x+head-&gt;img.getwidth())&gt;R){head-&gt;x=L;} if(head-&gt;x&lt;L){head-&gt;x=R-head-&gt;img.getwidth();} if((head-&gt;y+head-&gt;img.getheight())&gt;D){head-&gt;y=U;} if(head-&gt;y&lt;U){head-&gt;y=D-head-&gt;img.getheight();} p=head; while(p-&gt;next!=tail){ p=p-&gt;next; } if(p-&gt;x-tail-&gt;x&gt;0){loadimage(&amp;(tail-&gt;img), _T(TAILR));} if(p-&gt;x-tail-&gt;x&lt;0){loadimage(&amp;(tail-&gt;img), _T(TAILL));} if(p-&gt;y-tail-&gt;y&gt;0){loadimage(&amp;(tail-&gt;img), _T(TAILD));} if(p-&gt;y-tail-&gt;y&lt;0){loadimage(&amp;(tail-&gt;img), _T(TAILU));} return 0; } int Grow(){ BodyNode*p=head; while(p-&gt;next!=tail){ p=p-&gt;next; } tail-&gt;img=p-&gt;img; tail-&gt;next=new BodyNode(&amp;(TAILL[0]),tail-&gt;x-(p-&gt;x-tail-&gt;x),tail-&gt;y-(p-&gt;y-tail-&gt;y)); tail=tail-&gt;next; if(p-&gt;x-tail-&gt;x&gt;0){loadimage(&amp;(tail-&gt;img), _T(TAILR));} if(p-&gt;x-tail-&gt;x&lt;0){loadimage(&amp;(tail-&gt;img), _T(TAILL));} if(p-&gt;y-tail-&gt;y&gt;0){loadimage(&amp;(tail-&gt;img), _T(TAILD));} if(p-&gt;y-tail-&gt;y&lt;0){loadimage(&amp;(tail-&gt;img), _T(TAILU));} tail-&gt;next=NULL; length++; return 0; } int Show(){ BodyNode* p=head; while(p!=NULL){ putimage(p-&gt;x, p-&gt;y, &amp;(p-&gt;img)); p=p-&gt;next; } return 0; }};class Food{private: int x; int y; IMAGE rat;public: friend bool check(Body&amp; snake,Food&amp; food); Food(){ x=400; y=300; loadimage(&amp;(rat), _T(FOOD)); } int givefood(Body&amp; snake){ srand((unsigned)time(0)); while(check(snake,*this)==true){ x=0;y=0; while(!(x&gt;L&amp;&amp;y&gt;U)){ x= rand()%900; y= rand()%600; } x=x-(x%20); y=y-(y%20); } return 0; } int Show(){ putimage(x,y,&amp;(rat)); return 0; }};int showgame(Body&amp; snake,Food food){ cleardevice(); BeginBatchDraw(); setbkcolor(RGB(0,0,0)); //&#x8BBE;&#x7F6E;&#x80CC;&#x666F;&#x8272; setcolor(YELLOW); //&#x8BBE;&#x7F6E;&#x7ED8;&#x56FE;&#x8272; outtextxy((WIDTH/2)-80, 10, &quot;&#x8D2A;&#x5403;&#x86C7;&quot;); outtextxy(L+300, U-IMGHEIGHT-20, &quot;&#x6309;&#x7A7A;&#x683C; &#x6682;&#x505C;&quot;); outtextxy(R+IMGWIDTH+20, U+IMGHEIGHT+20, &quot;&#x6700;&#x9AD8;&#x8BB0;&#x5F55;&#xFF1A;&quot;);char rec1[10];//,rec2[10],rec3[10];for(int index=0;index&lt;=2;index++){ sprintf(rec1, &quot;%d&quot;,rec[index]); outtextxy(R+IMGWIDTH+20, U+IMGHEIGHT+20+(index+1)*30, rec1);} int i,j; for(i=L-IMGWIDTH;i&lt;=R;i=i+IMGWIDTH){ j=U-IMGHEIGHT; putimage(i,j,&amp;(wallimg)); } for(j=U;j&lt;=D;j=j+IMGHEIGHT){ i=L-IMGWIDTH; putimage(i,j,&amp;(wallimg)); } for(j=U;j&lt;=D;j=j+IMGHEIGHT){ i=R; putimage(i,j,&amp;(wallimg)); } for(i=L-IMGWIDTH;i&lt;=R;i=i+IMGWIDTH){ j=D; putimage(i,j,&amp;(wallimg)); } outtextxy(L-10, U-IMGHEIGHT-20, &quot;&#x5F97;&#x5206;:&quot;); char s[10]; sprintf(s, &quot;%d&quot;,score); outtextxy(L+60, U-IMGHEIGHT-20, s); outtextxy(L+120, U-IMGHEIGHT-20, &quot;&#x957F;&#x5EA6;:&quot;); char l[10]; sprintf(l, &quot;%d&quot;,snake.Length()); outtextxy(L+180, U-IMGHEIGHT-20, l); snake.Show(); food.Show(); FlushBatchDraw(); Sleep(50*grade); return 0;}bool check(Body&amp; snake,Food&amp; food){ BodyNode* pl=snake.head; bool flag=false; while(pl!=snake.tail-&gt;next){ if((pl-&gt;x==food.x)&amp;&amp;(pl-&gt;y==food.y)){flag=true;break;} pl=pl-&gt;next; } return flag;}DWORD WINAPI Fun1Proc(LPVOID IpParameter){ mciSendString(&quot;play yeah.mp3 repeat&quot;, NULL, 0, NULL);//&#x64AD;&#x653E; return 0;}int menu(){ //cleardevice(); outtextxy((WIDTH/2)-80, 120, &quot;&#x8D2A;&#x5403;&#x86C7;&quot;); outtextxy((WIDTH/2)-180, 230, &quot;&#x6309;&#x2191;&#x548C;&#x2193;&#x9009;&#x62E9;&#x96BE;&#x5EA6;&quot;); outtextxy((WIDTH/2)-180, 250, &quot;&#x6309;&#x7A7A;&#x683C;&#x952E;&#x786E;&#x5B9A;&#x9009;&#x62E9;&quot;); return 0;}int record(){ fstream f1(&quot;record.txt&quot;); //&#x6253;&#x5F00;&#x6587;&#x4EF6;&#xFF0C;&#x82E5;&#x6587;&#x4EF6;&#x4E0D;&#x5B58;&#x5728;&#x5C31;&#x521B;&#x5EFA;&#x5B83; if(!f1) return -1; //int a=0,b=0,c=0; f1&gt;&gt;rec[0]&gt;&gt;rec[1]&gt;&gt;rec[2]; f1.close(); return 0;}int saverecord(){ system(&quot;del record.txt &quot;); ofstream f1(&quot;record.txt&quot;); //&#x6253;&#x5F00;&#x6587;&#x4EF6;&#xFF0C;&#x82E5;&#x6587;&#x4EF6;&#x4E0D;&#x5B58;&#x5728;&#x5C31;&#x521B;&#x5EFA;&#x5B83; if(!f1) return -1; int flag=1; int temp; rec[3]=score; while(flag==1){ flag=0; for(int i=0;i&lt;=2;i++){ if(rec[i]&lt;rec[i+1]){ flag=1; temp=rec[i]; rec[i]=rec[i+1]; rec[i+1]=temp; } } } f1&lt;&lt;rec[0]&lt;&lt;&quot;\n&quot;&lt;&lt;rec[1]&lt;&lt;&quot;\n&quot;&lt;&lt;rec[2]; f1.close(); if(score!=rec[3]){ settextstyle(50, 0, _T(&quot;&#x5B8B;&#x4F53;&quot;)); outtextxy(WIDTH/2-(50*5),U+40, &quot;&#x606D;&#x559C;&#x4F60;&#x521B;&#x9020;&#x4E86;&#x65B0;&#x7EAA;&#x5F55;&#xFF01;&quot;);} return 0;}int main(){ for(int i=0;i&lt;=3;i++){ rec[i]=0; } record(); IMAGE snakeimg; HANDLE hThread1; hThread1 = CreateThread(NULL,0,Fun1Proc,NULL,0,NULL); char key; int movekey=4; int movekeyold=movekey; initgraph(WIDTH,HEIGHT); char temp=0,choose; while(temp!=&apos; &apos;){ cleardevice(); if(kbhit()){ choose=getch(); fflush(stdin); switch(choose){ case UP:{ grade++; };break; case DOWN:{ grade--; }; } } if(grade==4){grade=3;} if(grade==0){grade=1;} outtextxy(420,350,&quot;&#x7B80;&#x5355;&quot;); outtextxy(420,380,&quot;&#x4E2D;&#x7B49;&quot;); outtextxy(420,410,&quot;&#x96BE;&quot;); // cleardevice(); menu(); outtextxy(300,300,&quot;&#x8BF7;&#x9009;&#x62E9;&#x96BE;&#x5EA6;&#xFF1A;&quot;); if(grade==3){ outtextxy(390,350,&quot;&#x2192;&quot;); } if(grade==2){ outtextxy(390,380,&quot;&#x2192;&quot;); } if(grade==1){ outtextxy(390,410,&quot;&#x2192;&quot;); } temp=getch(); } loadimage(&amp;(wallimg), _T(WALL)); Body snake; Food food; showgame(snake,food); while(snake.IsDead()==false){ while(snake.IsDead()==false&amp;&amp;(!kbhit())){ if(movekey==1&amp;&amp;movekeyold==2||movekey==2&amp;&amp;movekeyold==1||movekey==3&amp;&amp;movekeyold==4||movekey==4&amp;&amp;movekeyold==3){ movekey=movekeyold;} movekeyold=movekey; snake.Move(movekey); showgame(snake,food); if(check(snake,food)==true){ mciSendString(&quot;play yeah.wav&quot;, NULL, 0, NULL);//&#x64AD;&#x653E; cout&lt;&lt;&apos;\a&apos;; score+=10; food.givefood(snake); snake.Grow(); snake.Grow(); snake.Grow(); } } if(kbhit()){ key=getch(); switch(key){ case UP:{movekey=1; };break; case DOWN:{movekey=2; };break; case LEFT:{movekey=3; };break; case RIGHT:{movekey=4; };break; case &apos; &apos;:{int t=0; while(t==0){ if(kbhit()){ key=getch(); if(key==&apos; &apos;){ t=1; } } } }; } } } CloseHandle(hThread1); BeginBatchDraw(); showgame(snake,food); IMAGE gameoverimg; loadimage(&amp;(gameoverimg), _T(GAMEOVER)); putimage(WIDTH/2-(gameoverimg.getwidth()/2),HEIGHT/2-(gameoverimg.getheight()/2),&amp;(gameoverimg)); saverecord(); FlushBatchDraw(); while(1) { Sleep(3000); } saverecord(); return 0;} &#x2002; &#x2002; &#x2002; &#x2002; &#x7D20;&#x6750;&#xFF1A;wall.jpg tailu.jpg tailr.jpg taill.jpg taild.jpg headup.jpg headright.jpg headleft.jpg headdown.jpg food.jpg bodylr.jpg gameover.jpg &#x2002;record.txt &#x5185;&#x5BB9;&#xFF1A; 123330140110 yeah.mp3 &#xFF1A;&#x6E38;&#x620F;&#x80CC;&#x666F;&#x97F3;&#x4E50;&#x3002; yeah.wav &#xFF1A;&#x86C7;&#x5403;&#x5230;&#x98DF;&#x7269;&#x65F6;&#x7684;&#x54D4;&#x58F0;&#x3002; &#x2002;&#x2002; &#x7A0B;&#x5E8F;&#x5199;&#x4E8E;&#x5927;&#x4E8C;&#x4E0A;&#x5B66;&#x671F;&#x3002; 2016.4.12&#x66F4;&#x65B0;&#x535A;&#x5BA2;&#x3002;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[贪吃蛇（Java实现）]]></title>
      <url>2016%2F03%2F13%2F%E8%B4%AA%E5%90%83%E8%9B%87Java%2F</url>
      <content type="text"><![CDATA[&#x7A0B;&#x5E8F;&#x6548;&#x679C;&#xFF1A; &#x4EE3;&#x7801;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268//Snake.javapackage snake;import javax.swing.*;import java.awt.*;import java.awt.event.*;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.Iterator;import java.util.LinkedList;import java.util.Random;class go implements Runnable { Snake s; Random random; int foodX = 15, foodY = 15;int N; go(Snake snake) { s = snake; random = new Random(); N=s.N; } Point getFood() { Point p = new Point(); Iterator&lt;Point&gt; it = s.list.iterator(); Point temp = it.next(); boolean isFoodinBody = true; while (isFoodinBody) { foodX = Math.abs(random.nextInt()) % N; foodY = Math.abs(random.nextInt()) % N; isFoodinBody = false; while (it.hasNext()) { temp = (Point) it.next(); if (foodX == temp.x &amp;&amp; temp.y == foodY) { isFoodinBody = true; break; } } } return p; } public void run() { while (true) { Point first = s.list.getFirst(); int x = first.x, y = first.y; int gotfood = 0; if (foodX == x &amp;&amp; foodY == y) { if (!s.isDead) { s.SCORE += 100; s.scoreField.setText(&quot;SCORE: &quot;+new Integer(s.SCORE).toString()); s.list.add(s.list.getLast()); } gotfood = 1; foodX = Math.abs(random.nextInt()) % N; foodY = Math.abs(random.nextInt()) % N; s.bs[foodX][foodY].setBackground(Color.PINK); } Iterator&lt;Point&gt; it = s.list.iterator(); Point temp = it.next(); while (it.hasNext()) { temp = (Point) it.next(); if (temp.x == x &amp;&amp; temp.y == y) { s.gameOver(); } if (gotfood == 1 &amp;&amp; foodX == temp.x &amp;&amp; temp.y == foodY) { Point food = getFood(); foodX = food.x; foodY = food.y; s.bs[foodX][foodY].setBackground(Color.PINK); gotfood=0; } } switch (s.dir) { case 2 : y =( (y - 1)+N )% N; /*if (y == -1) y = 29;*/ break; case 0 : y = (y + 1) % N; break; case 3 : x = ((x - 1)+N) % N; /*if (x == -1) x = 29;*/ break; case 1 : x = (x + 1) % N; break; } Point head = new Point(x, y); s.bs[x][y].setBackground(Color.LIGHT_GRAY); s.list.addFirst(head); Point lastP = s.list.removeLast(); s.bs[lastP.x][lastP.y].setBackground(Color.GRAY); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } /* * for (int i = 0; i &lt;= list.size() - 1; i++) { System.out.print( * &quot;(&quot; + list.get(i).x + &quot;,&quot; + list.get(i).y + &quot;) &quot;); * * } */ // System.out.println(); } }}public class Snake extends JFrame { private static final long serialVersionUID = -6494984874207734357L; int N = 30; int dir = 0;// 0 &#x53F3; 1&#x4E0B; 2&#x5DE6; 3&#x4E0A; int SCORE = 0; int a=0,b=0,c=0; boolean isDead = false; JButton[][] bs = new JButton[N][N]; JPanel panel,scorePanel; JTextField scoreField,bestScoreField; LinkedList&lt;Point&gt; list; Snake() { super(&quot;Snake&quot;); Container container = getContentPane(); container.setLayout(new BorderLayout()); scorePanel = new JPanel(); scorePanel .setLayout(new BorderLayout()); scoreField = new JTextField(20); bestScoreField= new JTextField(50); bestScoreField.setText(getBestScores()); bestScoreField.setEditable(false); scoreField.setText(&quot;SCORE: &quot;+new Integer(SCORE).toString()); scoreField.setEditable(false); scorePanel.add(scoreField,BorderLayout.WEST); scorePanel.add(bestScoreField,BorderLayout.EAST); container.add(scorePanel, BorderLayout.NORTH); panel = new JPanel(); panel.setLayout(new GridLayout(N, N)); for (int i = 0; i &lt;= N - 1; i++) { for (int j = 0; j &lt;= N - 1; j++) { bs[i][j] = new JButton(); bs[i][j].setBackground(Color.GRAY); panel.add(bs[i][j]); } } container.add(panel, BorderLayout.CENTER); list = new LinkedList&lt;Point&gt;(); list.add(new Point(15, 15)); list.add(new Point(15, 14)); list.add(new Point(15, 13)); list.add(new Point(15, 12)); list.add(new Point(15, 11)); for (int i = 0; i &lt;= list.size() - 1; i++) { bs[list.get(i).x][list.get(i).y].setBackground(Color.LIGHT_GRAY); } /*for (int i = 0; i &lt;= list.size() - 1; i++) { System.out.print(&quot;(&quot; + list.get(i).x + &quot;,&quot; + list.get(i).y + &quot;) &quot;); }*/ /*System.out.println();*/ this.addKeyListener(new KeyAdapter() { public void keyPressed(KeyEvent e) { int c = e.getKeyCode(); //System.out.print(c); int dir1 = dir; switch (c) { case KeyEvent.VK_LEFT : dir1 = 2; break; case KeyEvent.VK_RIGHT : dir1 = 0; break; case KeyEvent.VK_UP : dir1 = 3; break; case KeyEvent.VK_DOWN : dir1 = 1; break; default : System.out.print(&quot;hey&quot;); break; } if (!(dir1 - dir == -2 | dir1 - dir == 2)) dir = dir1; } }); this.setFocusable(true); setLocation(200, 10); setSize(800, 700); setVisible(true); } String getBestScores() { BufferedReader reader=null; try { reader=new BufferedReader(new FileReader(&quot;score.txt&quot;)); } catch (FileNotFoundException e) { e.printStackTrace(); } try { a=Integer.parseInt(reader.readLine()); b=Integer.parseInt(reader.readLine()); c=Integer.parseInt(reader.readLine()); } catch (NumberFormatException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } String bestS=new String(&quot;Best Score: &quot;+new Integer(a).toString()+&quot; &quot;+new Integer(b).toString()+&quot; &quot;+new Integer(c).toString()); return bestS; }int gameOver(){ isDead = true; JOptionPane.showMessageDialog(null, &quot;&#x4F60;&#x6B7B;&#x4E86;~~~.&quot;, &quot;GAME OVER&quot;, JOptionPane.PLAIN_MESSAGE); if(SCORE&gt;a){c=b;b=a;a=SCORE;save();System.exit(0);} if(SCORE&gt;b){c=b;b=SCORE;save();System.exit(0);} if(SCORE&gt;c){c=SCORE;save();System.exit(0);} System.exit(0); return 0;}int save(){ BufferedWriter writer=null; try { writer=new BufferedWriter(new FileWriter(&quot;score.txt&quot;)); } catch (IOException e) { e.printStackTrace(); } String d=new Integer(a).toString(),e=new Integer(b).toString(),f=new Integer(c).toString(); try { writer.write(d); writer.newLine(); writer.write(e); writer.newLine(); writer.write(f); writer.flush(); writer.close(); } catch (NumberFormatException ev) { ev.printStackTrace(); } catch (IOException ev) { ev.printStackTrace(); } return 0;} public static void main(String[] args) { Snake snake = new Snake(); snake.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); Thread thread = new Thread(new go(snake)); thread.start(); }} &#x7A0B;&#x5E8F;&#x5199;&#x4E8E;&#x5927;&#x4E09;&#x4E0A;&#x5B66;&#x671F;&#x3002; 2016.4.12&#x66F4;&#x65B0;&#x535A;&#x5BA2;&#x3002;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[俄罗斯方块（Java实现）]]></title>
      <url>2016%2F03%2F13%2F%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97Java%2F</url>
      <content type="text"><![CDATA[&#x7A0B;&#x5E8F;&#x6548;&#x679C;&#xFF1A; &#x4EE3;&#x7801;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//Box.javapackage tetris;public class Box { private final int M = 30, N = 12; private int[][] ls = new int[M][N]; private int score=0; int getM() { return M; } int getN() { return N; } int getScore() { return score; } boolean isOut(int x,int y){ return x&lt;0|y&lt;0|x&gt;M-1|y&gt;N-1?true:false; } int getFlag(int x, int y) { return isOut(x,y)?2:ls[x][y]; } int clearFlag(int x, int y) { if(isOut(x,y))return -1; ls[x][y]=0; return 0; } int setFlag_1(int x, int y) { if(isOut(x,y))return -1; ls[x][y]=1; return 0; } int setFlag_2(int x, int y) { if(isOut(x,y))return -1; ls[x][y]=2; return 0; } /*boolean isFlag_2(int x, int y) { return isOut(x,y)?true:ls[x][y]== 2 ? true:false ; }*/ void clear(int x, int maxX) { if(isOut(x,0)||isOut(maxX,0))return ; for (int i = x; i &lt;= maxX; i++) { boolean isAllNotBlank = true; for (int j = 0; j &lt;= N - 1; j++) { if (ls[i][j]== 0) { isAllNotBlank = false; break; } } if (isAllNotBlank) { for (int k = i - 1; k &gt;= 0; k--) { for (int j = 0; j &lt;= N - 1; j++) { ls[k + 1][j]=ls[k][j]; } } score+=100; } } }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126//Shape.javapackage tetris;import java.awt.Point;import java.util.Random;public class Shape { private final Box box; private Point[] ps = new Point[4]; private Point[] tps = new Point[5]; private final int[][][]shapes={ {{-1,0,0,0,1,0,2,0},{0,0,0,-1,0,2,0,1}}, {{- 1,0, 1, - 1,0,0,1,0},{0,- 1,1,-1,1,1,1,0},{-1,0,0,0,-1,1,1,0},{0,0,0,-1,0,1,1,1}}, {{-1,0,0,0,1,1,1,0},{0,1,1,-1,1,1,1,0},{-1,0,-1,-1,0,0,1,0},{0,0,0,-1,0,1,1,-1}}, {{0,0,1,-1,1,1,1,0},{0,0,1,-1,1,0,2,0},{0,0,0,-1,0,1,1,0},{0,0,1,0,1,1,2,0}}, {{0,0,1,0,0,1,1,1}}, {{-1,0,0,-1,-1,1,0,0},{-1,0,0,0,0,1,1,1}}, {{- 1,0, - 1,- 1,0, 1,0,0},{- 1,1,0,0,0,1,1,0}} }; private int change = 0,shape,x,y; int left,down; private Random random; boolean isPaused = false; Shape(Box b) { box = b; for (int i = 0; i &lt;= 3; i++) { ps[i] = new Point(); } for (int i = 0; i &lt;= 4; i++) { tps[i] = new Point(); } random = new Random(); getNewShape(); } private void clearTpsFlag(){ for (int i = 0; i &lt;= 3; i++) { box.clearFlag(tps[i].x, tps[i].y); } } private int setPsFlag_1() { for (int i = 0; i &lt;= 3; i++) { box.setFlag_1(ps[i].x, ps[i].y); } return 0; } private int setPsFlag_2() { for (int i = 0; i &lt;= 3; i++) { box.setFlag_2(ps[i].x, ps[i].y); } return 0; } private synchronized int tps() { for (int i = 0; i &lt;= 3; i++) { tps[i].x = ps[i].x; tps[i].y = ps[i].y; } tps[4].x=x; tps[4].y=y; return 0; } private synchronized int backupChange() { for (int i = 0; i &lt;= 3; i++) { ps[i].x = tps[i].x; ps[i].y = tps[i].y; } x=tps[4].x; y=tps[4].y; return 0; } private synchronized int check() { System.out.println(ps[0]+&quot;,&quot;+ps[1]+&quot;,&quot;+ps[2]+&quot;,&quot;+ps[3]); for (int i = 0; i &lt;= 3;i++) { if (!(box.getFlag(ps[i].x, ps[i].y)==0||box.getFlag(ps[i].x, ps[i].y)==1)){ backupChange(); return 5;} } return 0; } private void getNewShape(){ System.out.println(&quot;lll&quot;); int i = Math.abs(random.nextInt()) % 7; shape=i; x=1; y=box.getN()/2; for(int j=0;j&lt;=3;j++){ ps[j].setLocation(x+shapes[i][0][j*2], y+shapes[i][0][j*2+1]); } left=0; down=0; change=0; } void changeShape(){ tps(); change++; change%=shapes[shape].length; for(int j=0;j&lt;=3;j++){ ps[j].setLocation(x+shapes[shape][change][j*2], y+shapes[shape][change][j*2+1]); } int g=check(); if(g==0){ clearTpsFlag(); setPsFlag_1(); } } synchronized int move(int dir) { tps(); switch(dir){ case 0:for (int i = 0; i &lt;= 3; i++) {ps[i].y--;}y--;break; case 1:for (int i = 0; i &lt;= 3; i++) {ps[i].y++;}y++;break; case 2:for (int i = 0; i &lt;= 3; i++) {ps[i].x++;}x++;break; default: } int g = check(); if(g!=0&amp;&amp;dir==2){ int x = ps[0].x; int maxX = ps[3].x;// x+4&gt;M-1?M-1:x+4; setPsFlag_2(); box.clear(x, maxX); if(x==1){return -1;} getNewShape(); } if(g==0){ clearTpsFlag(); setPsFlag_1(); } return 0; }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206//Tetris.javapackage tetris;import java.awt.BorderLayout;import java.awt.Color;import java.awt.Container;import java.awt.Graphics;import java.awt.GridLayout;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JOptionPane;import javax.swing.JPanel;import javax.swing.JTextField;public class Tetris extends JFrame implements Runnable{ private static final long serialVersionUID = 279494108361487144L; final Color BC = Color.GRAY; final Color FC = Color.LIGHT_GRAY; Box box; Shape shape; int a = 0, b = 0, c = 0; JPanel panel, scorePanel; JTextField scoreField, bestScoreField; JButton[][] bs; Tetris(Box b) { super(&quot;Tetris&quot;); box = b; shape =new Shape(b); bs = new JButton[box.getM()][box.getN()]; for (int i = 0; i &lt;= box.getM() - 1; i++) { for (int j = 0; j &lt;= box.getN() - 1; j++) { bs[i][j] = new JButton(); bs[i][j].setBackground(BC); } } Container container = getContentPane(); container.setLayout(new BorderLayout()); scorePanel = new JPanel(); scorePanel.setLayout(new BorderLayout()); scoreField = new JTextField(10); bestScoreField = new JTextField(20); bestScoreField.setText(getBestScores()); bestScoreField.setEditable(false); scoreField.setText(&quot;SCORE: &quot; + new Integer(box.getScore()).toString()); scoreField.setEditable(false); scorePanel.add(scoreField, BorderLayout.NORTH); scorePanel.add(bestScoreField, BorderLayout.SOUTH); container.add(scorePanel, BorderLayout.NORTH); panel = new JPanel(); panel.setLayout(new GridLayout(box.getM(), box.getN())); for (int i = 0; i &lt;= box.getM() - 1; i++) { for (int j = 0; j &lt;= box.getN() - 1; j++) { panel.add(bs[i][j]); } } container.add(panel, BorderLayout.CENTER); this.addKeyListener(new KeyAdapter() { public void keyPressed(KeyEvent e) { int c = e.getKeyCode(); // System.out.print(c); switch (c) { case KeyEvent.VK_LEFT : //shape.left++; shape.move(0); break; case KeyEvent.VK_RIGHT : //shape.left--; shape.move(1); break; case KeyEvent.VK_UP : shape.changeShape(); break; case KeyEvent.VK_DOWN : shape.down++; break; case KeyEvent.VK_SPACE : if (shape.isPaused == true) { shape.isPaused = false; } else { shape.isPaused = true; } break; default : } } }); this.setFocusable(true); setLocation(200, 10); setSize(20 * box.getN(), 20 * box.getM() + 20); setVisible(true); } private int down() throws InterruptedException { System.out.println(&quot;ddd&quot;); int dd=shape.move(2); scoreField.setText(&quot;Score: &quot; + new Integer(box.getScore()).toString()); if(dd==-1){gameOver();} return 0; } public void run() { while (true) { try { if (shape.isPaused == true) { // System.out.println(&quot;PAUSED&quot;); Thread.sleep(500); } else { //System.out.println(&quot;start1&quot;); down(); for (int i = 0; i &lt;= box.getM() - 1; i++) { for (int j = 0; j &lt;= box.getN() - 1; j++) { if(box.getFlag(i, j)==0) bs[i][j].setBackground(BC); else bs[i][j].setBackground(FC); } } if (shape.down &gt;=1) { shape.down--; Thread.sleep(50); continue; } Thread.sleep(250); } } catch (InterruptedException e) { e.printStackTrace(); } } } String getBestScores() { BufferedReader reader = null; try { reader = new BufferedReader(new FileReader(&quot;score.txt&quot;)); } catch (FileNotFoundException e) { e.printStackTrace(); } try { a = Integer.parseInt(reader.readLine()); b = Integer.parseInt(reader.readLine()); c = Integer.parseInt(reader.readLine()); } catch (NumberFormatException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } String bestS = new String(&quot;Best Score: &quot; + new Integer(a).toString() + &quot; &quot; + new Integer(b).toString() + &quot; &quot; + new Integer(c).toString()); return bestS; } int gameOver() { JOptionPane.showMessageDialog(null, &quot;&#x4F60;&#x6B7B;&#x4E86;~~~.&quot;, &quot;GAME OVER&quot;, JOptionPane.PLAIN_MESSAGE); if (box.getScore() &gt; a) { c = b; b = a; a = box.getScore(); } else if (box.getScore() &gt; b) { c = b; b = box.getScore(); } else if (box.getScore()&gt; c) { c = box.getScore(); } save(); System.exit(0); return 0; } int save() { BufferedWriter writer = null; try { writer = new BufferedWriter(new FileWriter(&quot;score.txt&quot;)); } catch (IOException e) { e.printStackTrace(); } String d = new Integer(a).toString(), e = new Integer(b).toString(), f = new Integer(c).toString(); try { writer.write(d); writer.newLine(); writer.write(e); writer.newLine(); writer.write(f); writer.flush(); writer.close(); } catch (NumberFormatException ev) { ev.printStackTrace(); } catch (IOException ev) { ev.printStackTrace(); } return 0; } public static void main(String[] args) { Box box = new Box(); Tetris tetris = new Tetris(box); tetris.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); Thread thread1 = new Thread(tetris); thread1.start(); }} &#x7A0B;&#x5E8F;&#x5199;&#x4E8E;&#x5927;&#x4E09;&#x4E0A;&#x5B66;&#x671F;&#x3002; 2016.4.12&#x66F4;&#x65B0;&#x535A;&#x5BA2;&#x3002;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[校园导游系统（C++实现，VC6.0编译，使用EasyX图形库）]]></title>
      <url>2016%2F03%2F13%2F%E6%A0%A1%E5%9B%AD%E5%AF%BC%E6%B8%B8%E7%B3%BB%E7%BB%9F%2F</url>
      <content type="text"><![CDATA[&#x2002;&#x8FD0;&#x884C;&#x6548;&#x679C;&#xFF1A; &#x2002;&#x2002;&#x2002; &#x8BF4;&#x660E;:&#x3000;&#x3000;&#x7531;&#x4E8E;&#x5F53;&#x5E74;&#x8FD8;&#x4E0D;&#x4F1A;&#x4F7F;&#x7528;&#x591A;&#x7EBF;&#x7A0B;&#xFF0C;&#x6240;&#x4EE5;&#x5F88;&#x591A;&#x83B7;&#x53D6;&#x7528;&#x6237;&#x70B9;&#x51FB;&#x7684;&#x5730;&#x65B9;&#x90FD;&#x662F;&#x4F7F;&#x7528;&#x5FAA;&#x73AF;&#x5B9E;&#x73B0;&#x7684;&#x3002;&#x3002;&#x3002;CPU&#x5360;&#x7528;&#x7387;&#x4F1A;&#x6BD4;&#x8F83;&#x9AD8;&#x3002; &#x2002;&#x2002;&#x2002;&#x2002; &#x4EE3;&#x7801;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722//&#x6821;&#x56ED;&#x5BFC;&#x6E38;&#x7CFB;&#x7EDF;.cpp#include &lt;graphics.h&gt;#include &lt;conio.h&gt;#include &lt;stdio.h&gt;#include &lt;io.h&gt;#include &lt;stdlib.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;fstream&gt;#include &quot;Stack.h&quot;#include &quot;functions.h&quot;#include &quot;Graph_List.h&quot;#define WIDTH (1000+(LEFTBORDER*2))#define HEIGHT (574+TOPBORDER+LEFTBORDER)#define UP 72#define DOWN 80#define LEFT 75#define RIGHT 77#define BACKGROUND &quot;background.jpg&quot;#define BKCOLOR RGB(240,240,240) //&#x539F;RGB(240,240,240)#define SELECTCOLOR RGB(255,0,0) //&#x539F;RED#define TEXTCOLOR RGB(7,102,198)//GREEN// //&#x539F;BLUE#define MENUCOLOR RGB(208,161,227)//RGB(77,197,131)//RGB(112,112,112)//RGB(117,75,144)//RGB(7,102,198) //&#x539F;GREEN#define CheckCancel if(iscancel){return -1;}using namespace std;Graph_List graph;int choose;int menunum = 11;int menutop1 = 10;int menutop = (menutop1 + 3);#define left (LEFTBORDER)int menuwidth = ((WIDTH - 2 * LEFTBORDER) / (menunum ));int menuheight = 30;int GetChoose();int FrontMenu(Graph_List &amp;graph );int ShowAllVertex(Graph_List &amp;graph);int ShowAllPath(Graph_List &amp;graph);int printroad(int dx, int dy, int sx, int sy) { LINESTYLE linestyle; getlinestyle(&amp;linestyle); setlinestyle(PS_SOLID,3,NULL,0); setlinecolor(BLUE); line(sx,sy,dx,dy); setlinestyle(&amp;linestyle); double x1 = (sx + dx) / 2; double y1 = (sy + dy) / 2; double x2 = ((3.0 / 8.0) * sx + (5.0 / 8.0) * dx); double y2 = ((3.0 / 8.0) * sy + (5.0 / 8.0) * dy); //double x1=sx,x2=(sx+dx)/2,y1=sy,y2=(sy+dy)/2; double k1 = (y2 - y1) / (x2 - x1); double k2 = (-1) / k1; double delta = 1600; //=(y2-y1)*(y2-y1)+(x2-x1)*(x2-x1); double a = sqrt((delta / 16) / (1 + k2 * k2)); double b = a * fabs(k2); if(((x1 &gt; x2) &amp;&amp; (y1 &lt; y2)) || ((x1 &lt; x2) &amp;&amp; (y1 &gt; y2))) { } else { b = -1 * b; } if(x1 == x2) { a = 5; b = 0; } if(y1 == y2) { a = 0; b = 3; } POINT pts[] = { {x1, y1}, {x2 + a, y2 + b}, {(x1 + x2) / 2, (y1 + y2) / 2}, }; POINT pts1[] = { {x1, y1}, {x2 * 2 - (x2 + a), y2 * 2 - (y2 + b)}, {(x1 + x2) / 2, (y1 + y2) / 2}, }; setfillcolor(BLUE); solidpolygon(pts1, 3); solidpolygon(pts, 3); return 0;}int GetMouseXY(int&amp; mousex,int&amp; mousey) { MOUSEMSG temp; temp.mkLButton = false; bool kick = false; while(!kick) { // if(MouseHit()) { temp = GetMouseMsg(); FlushMouseMsgBuffer(); if(temp.mkLButton == false) { mousex = temp.x; mousey = temp.y; } else { kick = temp.mkLButton ; } // } } return 0;}int AddVertex(Graph_List &amp;graph) { LOGFONT font; gettextstyle(&amp;font); settextstyle(10, 0, _T(&quot;&#x5B8B;&#x4F53;&quot;)); BeginBatchDraw(); setlinecolor(GREEN); for(int lx = LEFTBORDER; lx &lt;= WIDTH; lx += 50) { //outtextxy(lx, TOPBORDER - 10, &amp;int_to_str(lx - LEFTBORDER)[0]); line(lx, TOPBORDER, lx, HEIGHT - LEFTBORDER); } for(int ly = TOPBORDER; ly &lt;= HEIGHT - LEFTBORDER; ly += 50) { //outtextxy(10, ly - 5, &amp;int_to_str(ly - TOPBORDER)[0]); line(LEFTBORDER, ly, WIDTH - LEFTBORDER, ly); } FlushBatchDraw(); setlinecolor(MENUCOLOR); settextstyle(&amp;font); ::MessageBox(GetHWnd(), &quot;&#x8BF7;&#x5728;&#x60A8;&#x8981;&#x6DFB;&#x52A0;&#x666F;&#x70B9;&#x7684;&#x4F4D;&#x7F6E;&#x70B9;&#x51FB;&quot;, &quot;&#x6DFB;&#x52A0;&#x666F;&#x70B9;&quot;, MB_OK); int mousex,mousey; GetMouseXY(mousex,mousey); char name[30]; bool iscancel = false; iscancel = !InputBox(&amp;(name[0]), 30, &quot;&#x8F93;&#x5165;&#x540D;&#x79F0;&quot; , &quot;&#x6DFB;&#x52A0;&#x666F;&#x70B9;&quot;, &quot;0&quot;, 0, 0, 0); CheckCancel char describe[1000]; iscancel = !InputBox(&amp;(describe[0]), 1000, &quot;&#x8F93;&#x5165;&#x7B80;&#x4ECB;&#xFF1A;(&#x6309;Ctrl+Enter&#x786E;&#x8BA4;&#x8F93;&#x5165;)&quot; , &quot;&#x6DFB;&#x52A0;&#x666F;&#x70B9;&quot;, &quot;0&quot;, 0, 10, 0); CheckCancel char mark[10]; int marki; while(1) { iscancel = !InputBox(&amp;(mark[0]), 10, &quot;&#x8F93;&#x5165;&#x4EE3;&#x53F7;&quot; , &quot;&#x6DFB;&#x52A0;&#x666F;&#x70B9;&quot;, 0, 0, 0, 0); CheckCancel marki = str_to_num(mark); if(marki &gt; 0 &amp;&amp; graph.GetIndex(marki) == -1) { break; } ::MessageBox(GetHWnd(), &quot;&#x6B64;&#x4EE3;&#x53F7;&#x5DF2;&#x5B58;&#x5728;&#xFF0C;&#x8BF7;&#x91CD;&#x8F93;&quot;, &quot;&#x6DFB;&#x52A0;&#x666F;&#x70B9;&quot;, MB_OK); } string namestr = &quot;&quot;, describestr = &quot;&quot;; graph.InsertVertex((string)(namestr + name), (string)(describestr + describe), marki, mousex, mousey); ::MessageBox(GetHWnd(), &quot;&#x6DFB;&#x52A0;&#x6210;&#x529F;&quot;, &quot;&#x6DFB;&#x52A0;&#x666F;&#x70B9;&quot;, MB_OK); return 0;}int AddPath(Graph_List &amp;graph) { bool iscancel = false; int v1, v2; string source = &quot;0000000000&quot;, destination = &quot;0000000000&quot;, weightstr = &quot;0000000000&quot;; while(1) { iscancel = !InputBox(&amp;(source[0]), 10, &quot;&#x8F93;&#x5165;&#x8D77;&#x70B9;&#x4EE3;&#x53F7;&quot; , &quot;&#x6DFB;&#x52A0;&#x8FB9;&quot;, &quot;0&quot;, 0, 0, 0); CheckCancel v1 = str_to_num(source); if(graph.GetIndex(v1) != -1) { break; } ::MessageBox(GetHWnd(), &quot;&#x8BE5;&#x4F4D;&#x7F6E;&#x4E0D;&#x5B58;&#x5728;&#xFF0C;&#x8BF7;&#x91CD;&#x8F93;&quot;, &quot;&#x6DFB;&#x52A0;&#x8FB9;&quot;, MB_OK); } while(1) { iscancel = !InputBox(&amp;(destination[0]), 10, &quot;&#x8F93;&#x5165;&#x7EC8;&#x70B9;&#x4EE3;&#x53F7;&quot;, &quot;&#x6DFB;&#x52A0;&#x8FB9;&quot;, &quot;0&quot;, 0, 0, 0); CheckCancel v2 = str_to_num(destination); if(graph.GetIndex(v2) != -1) { break; } ::MessageBox(GetHWnd(), &quot;&#x8BE5;&#x4F4D;&#x7F6E;&#x4E0D;&#x5B58;&#x5728;&#xFF0C;&#x8BF7;&#x91CD;&#x8F93;&quot;, &quot;&#x6DFB;&#x52A0;&#x8FB9;&quot;, MB_OK); } double dx = graph.GetHead()[graph.GetIndex(v2)].GetX(); double sx = graph.GetHead()[graph.GetIndex(v1)].GetX(); double dy = graph.GetHead()[graph.GetIndex(v2)].GetY(); double sy = graph.GetHead()[graph.GetIndex(v1)].GetY(); double weight = (double)sqrt(((dx - sx) * (dx - sx) + (dy - sy) * (dy - sy)) / 24250.0) * 300.0; int retop=graph.InsertEdge(graph.GetIndex(v1), graph.GetIndex(v2), weight); if(retop==-3){::MessageBox(GetHWnd(), &quot;&#x8D77;&#x70B9;&#x4E0E;&#x7EC8;&#x70B9;&#x76F8;&#x540C;&#xFF01;&quot;, &quot;&#x6DFB;&#x52A0;&#x8FB9;&quot;, MB_OK);return -3;} if(retop==-4){::MessageBox(GetHWnd(), &quot;&#x8FB9;&#x5DF2;&#x5B58;&#x5728;&#xFF01;&quot;, &quot;&#x6DFB;&#x52A0;&#x8FB9;&quot;, MB_OK);return -4;} ::MessageBox(GetHWnd(), &quot;&#x6DFB;&#x52A0;&#x6210;&#x529F;&quot;, &quot;&#x6DFB;&#x52A0;&#x8FB9;&quot;, MB_OK); return 0;}int DeleteVertex(Graph_List &amp;graph){ bool iscancel = false; char v[10]; int v1; while(1) { iscancel = !InputBox(&amp;(v[0]), 10, &quot;&#x8F93;&#x5165;&#x4EE3;&#x53F7;&quot; , &quot;&#x5220;&#x9664;&#x666F;&#x70B9;&quot;, &quot;0&quot;, 0, 0, 0); CheckCancel v1 = str_to_num(v); if(graph.GetIndex(v1)!= -1) { break; } ::MessageBox(GetHWnd(), &quot;&#x6B64;&#x4EE3;&#x53F7;&#x4E0D;&#x5B58;&#x5728;&#xFF0C;&#x8BF7;&#x91CD;&#x8F93;&quot;, &quot;&#x5220;&#x9664;&#x666F;&#x70B9;&quot;, MB_OK); } graph.DeleteVertex(graph.GetIndex(v1)); return 0;}int DeletePath(Graph_List &amp;graph) { bool iscancel = false; int v1, v2; string source = &quot;0000000000&quot;, destination = &quot;0000000000&quot;; while(1) { iscancel = !InputBox(&amp;(source[0]), 10, &quot;&#x8F93;&#x5165;&#x8D77;&#x70B9;&#x4EE3;&#x53F7;&quot; , &quot;&#x5220;&#x9664;&#x8FB9;&quot;, &quot;0&quot;, 0, 0, 0); CheckCancel v1 = str_to_num(source); if(graph.GetIndex(v1) != -1) { break; } ::MessageBox(GetHWnd(), &quot;&#x8BE5;&#x4F4D;&#x7F6E;&#x4E0D;&#x5B58;&#x5728;&#xFF0C;&#x8BF7;&#x91CD;&#x8F93;&quot;, &quot;&#x5220;&#x9664;&#x8FB9;&quot;, MB_OK); } while(1) { iscancel = !InputBox(&amp;(destination[0]), 10, &quot;&#x8F93;&#x5165;&#x7EC8;&#x70B9;&#x4EE3;&#x53F7;&quot;, &quot;&#x5220;&#x9664;&#x8FB9;&quot;, &quot;0&quot;, 0, 0, 0); CheckCancel v2 = str_to_num(destination); if(graph.GetIndex(v2) != -1) { break; } ::MessageBox(GetHWnd(), &quot;&#x8BE5;&#x4F4D;&#x7F6E;&#x4E0D;&#x5B58;&#x5728;&#xFF0C;&#x8BF7;&#x91CD;&#x8F93;&quot;, &quot;&#x5220;&#x9664;&#x8FB9;&quot;, MB_OK); } int retop=graph.DeleteEdge(graph.GetIndex(v1), graph.GetIndex(v2)); if(retop==-1){::MessageBox(GetHWnd(), &quot;&#x8FB9;&#x4E0D;&#x5B58;&#x5728;&#xFF01;&quot;, &quot;&#x5220;&#x9664;&#x8FB9;&quot;, MB_OK);return -1;} ::MessageBox(GetHWnd(), &quot;&#x5220;&#x9664;&#x6210;&#x529F;&quot;, &quot;&#x5220;&#x9664;&#x8FB9;&quot;, MB_OK); return 0;}int DrawShortestPath(Graph_List &amp;graph, int v1, int v2) { Vertex *Head = graph.GetHead(); int *path = new int [graph.NumberOfVertices()]; graph.DShortestPath(v1, path); LStack&lt;int &gt; stack; //stack.Push(v2); if(path[v2] == -1) { ::MessageBox(GetHWnd(), &quot;*** &#x65E0;&#x8DEF;&#x5F84; ***&quot;, &quot;&#x67E5;&#x8BE2;&#x8DEF;&#x5F84;&quot;, MB_OK); return -1; } int i = v2; while(i != path[v1]) { stack.Push(i); i = path[i]; } delete []path; //stack.Push(v1); int temp = v1, temppre = v1, length = 0; string pathstr,tempstr; BeginBatchDraw(); while(!stack.IsEmpty()) { stack.Pop(temp); printroad(Head[temppre].GetX(), Head[temppre].GetY(), Head[temp].GetX(), Head[temp].GetY()); int pathweight=graph.GetWeight(temppre, temp); length += pathweight; tempstr=tempstr+&quot;&#x4ECE;&quot;+int_to_str(Head[temppre].GetMark())+&quot;&#x5230;&quot;+int_to_str(Head[temp].GetMark())+&quot; : &quot;+int_to_str(pathweight)+&quot; &#x7C73;&quot;+&quot;\n&quot;; temppre = temp; } FlushBatchDraw(); setbkcolor(BKCOLOR); settextcolor(TEXTCOLOR); string str = &quot;&#x6700;&#x77ED;&#x8DEF;&#x5F84;&#x957F;&#x5EA6;&#x4E3A;&#xFF1A;&quot;; str = str + int_to_str(length) + &quot; &#x7C73;\n&quot;+&quot;&#x6B65;&#x884C;&#x6240;&#x9700;&#x65F6;&#x95F4;&#xFF1A;&quot;+int_to_str(length/90)+&quot;&#x5206;&#x949F;\n&quot;; str+=tempstr; ::MessageBox(GetHWnd(), &amp;str[0], &quot;&#x67E5;&#x8BE2;&#x8DEF;&#x5F84;&quot;, MB_OK); return 0;}int FindPath(Graph_List &amp;graph) { bool iscancel = false; int v1, v2; string source = &quot;0000000000&quot;, destination = &quot;0000000000&quot;; while(1) { iscancel = !InputBox(&amp;(source[0]), 10, &quot;&#x8F93;&#x5165;&#x8D77;&#x70B9;&#x4EE3;&#x53F7;&quot; , &quot;&#x67E5;&#x8BE2;&#x8DEF;&#x5F84;&quot;, &quot;0&quot;, 0, 0, 0); CheckCancel v1 = str_to_num(source); if(graph.GetIndex(v1) != -1) { break; } ::MessageBox(GetHWnd(), &quot;&#x8BE5;&#x4F4D;&#x7F6E;&#x4E0D;&#x5B58;&#x5728;&#xFF0C;&#x8BF7;&#x91CD;&#x8F93;&quot;, &quot;&#x67E5;&#x8BE2;&#x8DEF;&#x5F84;&quot;, MB_OK); } while(1) { iscancel = !InputBox(&amp;(destination[0]), 10, &quot;&#x8F93;&#x5165;&#x7EC8;&#x70B9;&#x4EE3;&#x53F7;&quot;, &quot;&#x67E5;&#x8BE2;&#x8DEF;&#x5F84;&quot;, &quot;0&quot;, 0, 0, 0); CheckCancel v2 = str_to_num(destination); if(graph.GetIndex(v2) != -1) { break; } ::MessageBox(GetHWnd(), &quot;&#x8BE5;&#x4F4D;&#x7F6E;&#x4E0D;&#x5B58;&#x5728;&#xFF0C;&#x8BF7;&#x91CD;&#x8F93;&quot;, &quot;&#x67E5;&#x8BE2;&#x8DEF;&#x5F84;&quot;, MB_OK); } DrawShortestPath(graph, graph.GetIndex(v1), graph.GetIndex(v2)); return 0;}void ShowVertex(Graph_List &amp;graph, int i) { Vertex *Head = graph.GetHead(); if(i &lt; 0 || i &gt; graph.NumberOfVertices() - 1) { ::MessageBox(GetHWnd(), &quot;&#x67E5;&#x8BE2;&#x4F4D;&#x7F6E;&#x4E0D;&#x5B58;&#x5728;&quot;, &quot;&#x666F;&#x70B9;&#x67E5;&#x8BE2;&quot;, MB_OK); //GetHWnd()&#x83B7;&#x5F97;&#x7A97;&#x53E3;&#x53E5;&#x67C4; return ; } string str = &quot;&#x4EE3;&#x53F7;&#xFF1A;&quot; +int_to_str(Head[i].GetMark()) + &quot;\n&quot; + &quot;&#x7B80;&#x4ECB;: &quot; + Head[i].GetDescribe(); str = &quot;&#x540D;&#x79F0;&#xFF1A;&quot; + Head[i].GetVerName() + &quot;\n&quot; + str; ::MessageBox(GetHWnd(), &amp;str[0], &quot;&#x666F;&#x70B9;&#x67E5;&#x8BE2;&quot;, MB_OK); //GetHWnd()&#x83B7;&#x5F97;&#x7A97;&#x53E3;&#x53E5;&#x67C4;}int ModifyMenu() { int choose1 = 1; char temp = 0, key; while(temp != &apos;\r&apos;) { if(kbhit()) { key = getch(); fflush(stdin); switch(key) { case UP: { choose1--; }; break; case DOWN: { choose1++; }; } } if(choose1 == 6) { choose1 = 5; } if(choose1 == 0) { choose1 = 1; } cleardevice(); outtextxy((WIDTH / 2) - 80, 120, &quot;&#x4FEE;&#x6539;&#x666F;&#x70B9;&quot;); outtextxy((WIDTH / 2) - 180, 230, &quot;&#x6309;&#x2191;&#x548C;&#x2193;&#x9009;&#x62E9;&#x9009;&#x9879;&quot;); outtextxy((WIDTH / 2) - 180, 250, &quot;&#x6309;ENTER&#x952E;&#x786E;&#x5B9A;&#x9009;&#x62E9;&quot;); outtextxy(300, 300, &quot;&#x8BF7;&#x9009;&#x62E9;&#x9009;&#x9879;&#xFF1A;&quot;); outtextxy(420, 350, &quot;&#x4FEE;&#x6539;&#x540D;&#x79F0;&quot;); outtextxy(420, 380, &quot;&#x4FEE;&#x6539;&#x7B80;&#x4ECB;&quot;); outtextxy(420, 410, &quot;&#x4FEE;&#x6539;&#x4EE3;&#x53F7;&quot;); outtextxy(420, 440, &quot;&#x4FEE;&#x6539;&#x5750;&#x6807;&quot;); outtextxy(420, 470, &quot;&#x8FD4;&#x56DE;&quot;); outtextxy(390, 350 + (choose1 - 1) * 30, &quot;&#x2192;&quot;); FlushBatchDraw(); temp = getch(); } return choose1;}int ModifyVertex(Graph_List &amp;graph) { bool iscancel = false; int v1; char v1str[10] = {&apos;a&apos;}; while(1) { iscancel = !InputBox(&amp;(v1str[0]), 10, &quot;&#x8F93;&#x5165;&#x4EE3;&#x53F7;&quot; , &quot;&#x4FEE;&#x6539;&#x666F;&#x70B9;&quot;, &quot;0&quot;, 0, 0, 0); CheckCancel v1= str_to_num(v1str); if(graph.GetIndex(v1) != -1) { break; } ::MessageBox(GetHWnd(), &quot;&#x8BE5;&#x4F4D;&#x7F6E;&#x4E0D;&#x5B58;&#x5728;&#xFF0C;&#x8BF7;&#x91CD;&#x8F93;&quot;, &quot;&#x4FEE;&#x6539;&#x666F;&#x70B9;&quot;, MB_OK); } int v=graph.GetIndex(v1); Vertex *Head = graph.GetHead(); string name=Head[v].GetVerName(); string describe=Head[v].GetDescribe(); int marki=Head[v].GetMark(),x=Head[v].GetX()-LEFTBORDER,y=Head[v].GetY()-TOPBORDER; bool isreturn = false; while(!isreturn ) { int in = ModifyMenu(); switch(in) { case 1: { iscancel = !InputBox(&amp;(name[0]), 30, &quot;&#x8F93;&#x5165;&#x540D;&#x79F0;&quot; , &quot;&#x4FEE;&#x6539;&#x666F;&#x70B9;&quot;, &quot;0&quot;, 0, 0, 0); CheckCancel }; break; case 2: { iscancel = !InputBox(&amp;(describe[0]), 1000, &quot;&#x8F93;&#x5165;&#x7B80;&#x4ECB;&#xFF1A;(&#x6309;Ctrl+Enter&#x786E;&#x8BA4;&#x8F93;&#x5165;)&quot; , &quot;&#x4FEE;&#x6539;&#x666F;&#x70B9;&quot;, &quot;0&quot;, 0, 10, 0); CheckCancel }; break; case 3: { char mark[10]; while(1) { iscancel = !InputBox(&amp;(mark[0]), 10, &quot;&#x8F93;&#x5165;&#x4EE3;&#x53F7;&quot; , &quot;&#x4FEE;&#x6539;&#x666F;&#x70B9;&quot;, 0, 0, 0, 0); CheckCancel marki = str_to_num(mark); if(marki &gt; 0 &amp;&amp; (marki == Head[v].GetMark() || graph.GetIndex(marki) == -1)) { break; } ::MessageBox(GetHWnd(), &quot;&#x8F93;&#x5165;&#x6709;&#x8BEF;&#x6216;&#x4EE3;&#x53F7;&#x5DF2;&#x5B58;&#x5728;&#xFF0C;&#x8BF7;&#x91CD;&#x8F93;&quot;, &quot;&#x4FEE;&#x6539;&#x666F;&#x70B9;&quot;, MB_OK); } }; break; case 4: { char xstr[10], ystr[10]; while(1) { iscancel = !InputBox(&amp;(xstr[0]), 10, &quot;&#x8F93;&#x5165;X&#x5750;&#x6807;&quot; , &quot;&#x4FEE;&#x6539;&#x666F;&#x70B9;&quot;, &quot;0&quot;, 0, 0, 0); CheckCancel x = str_to_num(xstr); if(x &gt; 0 &amp;&amp; x &lt; WIDTH) { break; } ::MessageBox(GetHWnd(), &quot;&#x60A8;&#x6240;&#x8F93;&#x5165;&#x7684;&#x5750;&#x6807;&#x4E0D;&#x5728;&#x56FE;&#x50CF;&#x8303;&#x56F4;&#x5185;&quot;, &quot;&#x4FEE;&#x6539;&#x666F;&#x70B9;&quot;, MB_OK); } while(1) { iscancel = !InputBox(&amp;(ystr[0]), 10, &quot;&#x8F93;&#x5165;Y&#x5750;&#x6807;&quot; , &quot;&#x4FEE;&#x6539;&#x666F;&#x70B9;&quot;, &quot;0&quot;, 0, 0, 0); CheckCancel y = str_to_num(ystr); if(y &gt; 0 &amp;&amp; y &lt; HEIGHT) { break; } ::MessageBox(GetHWnd(), &quot;&#x60A8;&#x6240;&#x8F93;&#x5165;&#x7684;&#x5750;&#x6807;&#x4E0D;&#x5728;&#x56FE;&#x50CF;&#x8303;&#x56F4;&#x5185;&quot;, &quot;&#x4FEE;&#x6539;&#x666F;&#x70B9;&quot;, MB_OK); } }; break; case 5: { graph.ModifyVertex(v, name,describe, marki, x, y); ShowVertex(graph, v); isreturn = true; }; break; default: {}; break; } } return 0;}int ShowAllVertex(Graph_List &amp;graph){ Vertex *Head = graph.GetHead(); //putimage(LEFTBORDER, TOPBORDER, graph.GetMap()); setbkcolor(RGB(240, 240, 240)); settextcolor(RED); setfillcolor(RGB(255,0,0)); LOGFONT font1; gettextstyle(&amp;font1); settextstyle(font1.lfHeight - 2, 0, _T(&quot;&#x5B8B;&#x4F53;&quot;)); for(int i = 0; i &lt;= graph.NumberOfVertices() - 1; i++) { int x = Head[i].GetX(), y = Head[i].GetY(); string str = &quot;&quot;; str += int_to_str(Head[i].GetMark()); if(Head[i].GetVerName() != &quot;*&quot;) str = str + &quot; &quot; + Head[i].GetVerName(); solidcircle(x,y,4); outtextxy( x, y, &amp;str[0]); } settextstyle(&amp;font1); FlushBatchDraw(); return 0;}int ShowAllPath(Graph_List &amp;graph) { LINESTYLE linestyle; getlinestyle(&amp;linestyle); setlinestyle(PS_SOLID,3,NULL,0); setlinecolor(BLUE); for(int i=0;i&lt;=graph.NumberOfVertices()-1;i++){ Edge* p=graph.GetHead()[i].Getadj(); while(p!=NULL){ line(graph.GetHead()[i].GetX(),graph.GetHead()[i].GetY(),graph.GetHead()[p-&gt;GetVerAdj()].GetX(),graph.GetHead()[p-&gt;GetVerAdj()].GetY()); p=p-&gt;Getlink(); } } setlinestyle(&amp;linestyle); FlushBatchDraw(); return 0;}int FindMenu() { int choose1 = 1; char temp = 0, key; while(temp != &apos;\r&apos;) { if(kbhit()) { key = getch(); fflush(stdin); switch(key) { case UP: { choose1--; }; break; case DOWN: { choose1++; }; } } if(choose1 == 4) { choose1 = 3; } if(choose1 == 0) { choose1 = 1; } cleardevice(); outtextxy((WIDTH / 2) - 80, 120, &quot;&#x67E5;&#x8BE2;&#x666F;&#x70B9;&quot;); outtextxy((WIDTH / 2) - 180, 230, &quot;&#x6309;&#x2191;&#x548C;&#x2193;&#x9009;&#x62E9;&#x9009;&#x9879;&quot;); outtextxy((WIDTH / 2) - 180, 250, &quot;&#x6309;ENTER&#x952E;&#x786E;&#x5B9A;&#x9009;&#x62E9;&quot;); outtextxy(300, 300, &quot;&#x8BF7;&#x9009;&#x62E9;&#x9009;&#x9879;&#xFF1A;&quot;); outtextxy(420, 350, &quot;&#x6309;&#x4EE3;&#x53F7;&#x67E5;&#x8BE2;&quot;); outtextxy(420, 380, &quot;&#x6309;&#x540D;&#x79F0;&#x67E5;&#x8BE2;&quot;); outtextxy(420, 410, &quot;&#x8FD4;&#x56DE;&quot;); outtextxy(390, 350 + (choose1 - 1) * 30, &quot;&#x2192;&quot;); FlushBatchDraw(); temp = getch(); } return choose1;}int FindVertex(Graph_List &amp;graph) { bool iscancel = false; bool isreturn = false; while(!isreturn ) { int in = FindMenu(); switch(in) { case 1: { char v1str[10] = {&apos;a&apos;}; int v1; iscancel = !InputBox(&amp;(v1str[0]), 10, &quot;&#x8F93;&#x5165;&#x4EE3;&#x53F7;&quot; , &quot;&#x67E5;&#x8BE2;&#x666F;&#x70B9;&quot;, &quot;0&quot;, 0, 0, 0); CheckCancel v1 = str_to_num(v1str); ShowVertex(graph, graph.GetIndex(v1)); }; break; case 2: { char v1str[10] = {&apos;a&apos;}; string v1; iscancel = !InputBox(&amp;(v1str[0]), 10, &quot;&#x8F93;&#x5165;&#x540D;&#x79F0;&quot; , &quot;&#x67E5;&#x8BE2;&#x666F;&#x70B9;&quot;, &quot;0&quot;, 0, 0, 0); CheckCancel v1 = &quot;&quot;; v1 += v1str; ShowVertex(graph, graph.GetIndex(v1)); }; break; case 3: { isreturn = true; }; break; default: {}; break; } } return 0;}int Open(Graph_List &amp;graph, bool isfirstopen) { fstream filestr; char mapname[256] = {&apos;a&apos;}; if(isfirstopen) { filestr.open (&quot;map.txt&quot;); strcpy(mapname, &quot;map.jpg&quot;); } else { bool iscancel = false; char filename[256] = {&apos;a&apos;}; while(1) { iscancel = !InputBox(&amp;(filename[0]), 10, &quot;&#x8F93;&#x5165;&#x6587;&#x672C;&#x6587;&#x4EF6;&#x540D;(&#x4E0D;&#x9700;&#x8F93;&apos;.txt&apos;)&quot; , &quot;&#x6253;&#x5F00;&quot;, &quot;0&quot;, 0, 0, 0); CheckCancel strcat(filename, &quot;.txt&quot;); filestr.open (filename); if (filestr.is_open()) { break; } ::MessageBox(GetHWnd(), &quot;&#x65E0;&#x6B64;&#x6587;&#x4EF6;&#xFF0C;&#x8BF7;&#x91CD;&#x8F93;&quot;, &quot;&#x6253;&#x5F00;&quot;, MB_OK); } while(1) { iscancel = !InputBox(&amp;(mapname[0]), 10, &quot;&#x8F93;&#x5165;&#x56FE;&#x7247;&#x6587;&#x4EF6;&#x540D;(&#x4E0D;&#x9700;&#x8F93;&apos;.jpg&apos;)&quot; , &quot;&#x6253;&#x5F00;&quot;, &quot;0&quot;, 0, 0, 0); CheckCancel strcat(mapname, &quot;.jpg&quot;); if( (_access(mapname, 0 )) != -1 ) { break; } ::MessageBox(GetHWnd(), &quot;&#x65E0;&#x6B64;&#x6587;&#x4EF6;&#xFF0C;&#x8BF7;&#x91CD;&#x8F93;&quot;, &quot;&#x6253;&#x5F00;&quot;, MB_OK); } } graph.graph_con(filestr, mapname); filestr.close(); putimage(LEFTBORDER, TOPBORDER, graph.GetMap()); return 0;}int Save(Graph_List &amp;graph) { bool iscancel = false; Vertex *Head = graph.GetHead(); char filename[256] = {&apos;a&apos;}; iscancel = !InputBox(&amp;(filename[0]), 10, &quot;&#x8F93;&#x5165;&#x6587;&#x672C;&#x6587;&#x4EF6;&#x540D;(&#x4E0D;&#x9700;&#x8F93;&apos;.txt&apos;)&quot; , &quot;&#x4FDD;&#x5B58;&quot;, &quot;0&quot;, 0, 0, 0); CheckCancel strcat(filename, &quot;.txt&quot;); graph.SaveFile(filename); ::MessageBox(GetHWnd(), &quot;&#x4FDD;&#x5B58;&#x6210;&#x529F;&quot;, &quot;&#x4FDD;&#x5B58;&quot;, MB_OK); return 0;}int GetChoose() { FlushMouseMsgBuffer(); MOUSEMSG temp; temp.mkLButton = false; bool kick = false; while(!kick) { // if(MouseHit()) { temp = GetMouseMsg(); FlushMouseMsgBuffer(); if(temp.mkLButton == false) { } else { if(temp.y &lt; menutop + menuheight &amp;&amp;temp. y &gt; menutop) { kick = true; } } // } } choose = (temp.x - left) / menuwidth; return 0;}int FrontMenu(Graph_List &amp;graph) { fflush(stdin); settextcolor(TEXTCOLOR); setfillcolor(BKCOLOR); solidrectangle(5, TOPBORDER, WIDTH, HEIGHT); //&#x4EE5;&#x80CC;&#x666F;&#x8272;&#x5237;&#x65B0; setfillcolor(MENUCOLOR); solidrectangle(5, 0, WIDTH - 5, menutop1); //&#x753B;&#x6700;&#x4E0A;&#x65B9;&#x7684;&#x7EFF;&#x8272;&#x6761; putimage(LEFTBORDER, TOPBORDER, graph.GetMap()); setfillcolor(BKCOLOR); solidrectangle(LEFTBORDER, menutop + textheight(&apos;a&apos;), WIDTH - LEFTBORDER, menutop + textheight(&apos;a&apos;) + 5); //&#x53BB;&#x6389;&#x9009;&#x4E2D;&#x7684;&#x83DC;&#x5355;&#x4E0B;&#x65B9;&#x7684;&#x5C0F;&#x7EFF;&#x5757; setfillcolor(TEXTCOLOR); setfillcolor(MENUCOLOR); solidrectangle(choose * menuwidth + left, menutop + textheight(&apos;a&apos;), (choose + 1)*menuwidth + left, menutop + textheight(&apos;a&apos;) + 5); //&#x753B;&#x9009;&#x4E2D;&#x7684;&#x83DC;&#x5355;&#x4E0B;&#x65B9;&#x7684;&#x5C0F;&#x7EFF;&#x5757; roundrect(5, menutop + textheight(&apos;a&apos;) + 5, WIDTH - 5, HEIGHT - 5, 5, 3); //&#x753B;&#x56FE;&#x7247;&#x5468;&#x56F4;&#x7684;&#x7EFF;&#x8272;&#x8FB9;&#x6846; solidrectangle(5, menutop + textheight(&apos;a&apos;) + 5, WIDTH - 5, menutop + textheight(&apos;a&apos;) + 10); //&#x753B;&#x56FE;&#x7247;&#x4E0A;&#x65B9;&#x4E0E;&#x5C0F;&#x7EFF;&#x5757;&#x76F8;&#x8FDE;&#x7684;&#x7EFF;&#x8272;&#x6761; setfillcolor(TEXTCOLOR); LOGFONT font1; gettextstyle(&amp;font1); settextstyle(font1.lfHeight, 0, _T(&quot;&#x5B8B;&#x4F53;&quot;)); string menu[11] = {&quot; &#x6253;&#x5F00;&quot;, &quot; &#x663E;&#x793A;&quot;, &quot; &#x67E5;&#x8BE2;&#x8DEF;&#x5F84;&quot;, &quot; &#x67E5;&#x8BE2;&#x666F;&#x70B9;&quot;, &quot; &#x4FEE;&#x6539;&#x666F;&#x70B9;&quot;, &quot; &#x6DFB;&#x52A0;&#x666F;&#x70B9;&quot;, &quot; &#x5220;&#x9664;&#x666F;&#x70B9;&quot;, &quot; &#x6DFB;&#x52A0;&#x8FB9;&quot;, &quot; &#x5220;&#x9664;&#x8FB9;&quot;,&quot; &#x4FDD;&#x5B58;&quot;, &quot; &#x9000;&#x51FA;&quot;}; for(int index = 0; index &lt;= menunum - 1; index++) { if(index == choose)settextcolor(SELECTCOLOR); const char *p = menu[index].c_str(); outtextxy(left + index * menuwidth, menutop, p); if(index == choose)settextcolor(TEXTCOLOR); } settextstyle(&amp;font1); setlinecolor(MENUCOLOR); for(int index1 = 0; index1 &lt;= menunum + 1; index1++) { line(left + index1 * menuwidth, menutop, left + index1 * menuwidth, menutop + textheight(&apos;a&apos;)); } LOGFONT font; gettextstyle(&amp;font); settextstyle(10, 0, _T(&quot;&#x5B8B;&#x4F53;&quot;)); settextcolor(TEXTCOLOR); for(int lx = LEFTBORDER; lx &lt;= WIDTH; lx += 50) { outtextxy(lx, TOPBORDER - 10, &amp;int_to_str(lx - LEFTBORDER)[0]); } for(int ly = TOPBORDER; ly &lt;= HEIGHT - LEFTBORDER; ly += 50) { outtextxy(10, ly - 5, &amp;int_to_str(ly - TOPBORDER)[0]); } settextstyle(&amp;font); settextcolor(TEXTCOLOR); FlushBatchDraw(); setbkcolor(BKCOLOR); settextcolor(TEXTCOLOR); return choose;}int main() { graph; initgraph(WIDTH, HEIGHT); //,0);//SHOWCONSOLE|NOMINIMIZE setbkcolor(BKCOLOR); cleardevice(); //int in = INT_MIN; //FrontMenu(graph); bool isfirstopen = true; while(1) { FrontMenu(graph); //ShowAllVertex( graph); if(isfirstopen) { choose = 0; } else { GetChoose( ); } FrontMenu(graph); //ShowAllVertex( graph); switch(choose) { case 0: { Open(graph, isfirstopen); isfirstopen = false; } break; case 1: { ShowAllPath(graph); ShowAllVertex( graph); int vertexnum =graph.NumberOfVertices(),edgenum=graph.NumberOfEdges(); string numofvertices; numofvertices = &quot;&#x56FE;&#x4E2D;&#x5171;&#x6709;&#x666F;&#x70B9; &quot; + int_to_str(vertexnum) + &quot; &#x4E2A;\n&quot;+&quot;&#x5171;&#x6709;&#x8FB9; &quot; + int_to_str(edgenum) + &quot; &#x6761;\n&quot;; ::MessageBox(GetHWnd(), &amp;numofvertices[0], &quot;&#x663E;&#x793A;&quot;, MB_OK); } break; case 2: { ShowAllVertex( graph); FindPath(graph); ShowAllVertex( graph); }; break; case 3: { ShowAllVertex( graph); FindVertex(graph); }; break; case 4: { ShowAllVertex( graph); ModifyVertex(graph ); }; break; case 5: { ShowAllVertex( graph); AddVertex(graph); }; break; case 6: { ShowAllVertex( graph); DeleteVertex(graph); }; break; case 7: { ShowAllPath(graph); ShowAllVertex( graph); AddPath( graph); } break; case 8: { ShowAllPath(graph); ShowAllVertex( graph); DeletePath(graph); } break; case 9: { Save(graph); } break; case 10: { WinExec(_T(&quot;taskkill /f /im conhost.exe /t&quot;), 1); //WinExec(_T(&quot;taskkill /f /im &#x6821;&#x56ED;&#x5BFC;&#x6E38;&#x7CFB;&#x7EDF;.exe /t&quot;), 1); exit(0); } break; default: { } break; } } return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474//Graph_List.h//******************************** &#x7C7B;&#x5B9A;&#x4E49; ***************************************//#ifndef _MYGraph_List_h_#define _MYGraph_List_h_#define LEFTBORDER 30#define TOPBORDER 50#include&lt;string&gt;#include &lt;fstream&gt;#include &lt;graphics.h&gt;class Edge{private: int VerAdj; int cost; Edge *link;public: Edge() { VerAdj = -1; cost = -1; link = NULL; } Edge(int VerAdji, int costi,Edge *linki): VerAdj(VerAdji), cost(costi),link(linki) //&#x521D;&#x59CB;&#x5316; { } int &amp;GetVerAdj() { return VerAdj; } int &amp;Getcost() { return cost; } Edge *&amp;Getlink() { return link; }};class Vertex{private: string VerName; string Describe; Edge *adjacent; int mark; int x; int y;public: Vertex() { VerName = &quot;*&quot;; Describe = &quot;*&quot;; adjacent = NULL; mark=-1; x=-1; y=-1; } string &amp;GetVerName() { return VerName; } string &amp;GetDescribe () { return Describe; } Edge *&amp;Getadj() { return adjacent; } int &amp; GetMark() { return mark; } int &amp; GetX() { return x; } int &amp; GetY() { return y; }};class Graph_List{private: Vertex *Head; int graphsize; int MaxCost; IMAGE* map; int InsertEdge_Do(const int &amp;v1, const int &amp;v2, int weight) //&#x63D2;&#x5165;&#x65F6;&#x5C3D;&#x91CF;&#x4FDD;&#x8BC1;&#x987A;&#x5E8F;&#x6392;&#x5217; { if(Head[v1].Getadj() == NULL) { Head[v1].Getadj() = new Edge(v2, weight, NULL); //&#x82E5;&#x90BB;&#x63A5;&#x8868;&#x4E3A;&#x7A7A; &#x76F4;&#x63A5;&#x5728;adjacent&#x540E;&#x6DFB;&#x52A0;&#x8FB9; return 0; } Edge *p = Head[v1].Getadj(); Edge *pt = p; while((p != NULL)&amp;&amp;(p-&gt;GetVerAdj() &lt; v2)) { pt = p; p = p-&gt;Getlink(); } if(p == NULL) { //&#x5230;&#x90BB;&#x63A5;&#x8868;&#x672B;&#x7AEF;&#x4ECD;&#x7136;&#x6BD4;v2&#x5C0F; pt-&gt;Getlink() = new Edge(v2, weight, NULL); return 0; } if(p == Head[v1].Getadj() &amp;&amp; p-&gt;GetVerAdj() &gt; v2) { //&#x90BB;&#x63A5;&#x8868;&#x7B2C;&#x4E00;&#x4E2A;&#x5C31;&#x6BD4;v2&#x5927; Edge *q = new Edge(v2, weight, NULL); q-&gt;Getlink() = p; Head[v1].Getadj() = q; return 0; } if(p-&gt;GetVerAdj() == v2) { return -4; //&#x63D2;&#x5165;&#x8FB9;&#x5DF2;&#x5B58;&#x5728; &#x8FD4;&#x56DE;-4 } if(p != Head[v1].Getadj() &amp;&amp; p-&gt;GetVerAdj() &gt; v2) { //&#x6B63;&#x5E38;&#x5728;&#x90BB;&#x63A5;&#x8868;&#x4E2D;&#x95F4;&#x6DFB;&#x52A0;&#x7684;&#x60C5;&#x51B5; Edge *q = new Edge(v2, weight, NULL); pt-&gt;Getlink() = q; q-&gt;Getlink() = p; return 0; } return 0; } int DeleteEdge_Do(const int &amp;v1, const int &amp;v2) { Edge *p = Head[v1].Getadj(); if(p == NULL) { return -1; //&#x8FD4;&#x56DE;-1&#x8868;&#x793A;&#x6240;&#x5220;&#x9664;&#x7684;&#x8FB9;&#x4E0D;&#x5B58;&#x5728; } if(p-&gt;GetVerAdj() == v2) //&#x90BB;&#x63A5;&#x8868;&#x7B2C;&#x4E00;&#x4E2A;&#x5C31;&#x662F;v2&#x7684;&#x60C5;&#x51B5; { Head[v1].Getadj() = p-&gt;Getlink(); delete p; return 0; } Edge *pt = p; while(p != NULL) { if(p-&gt;GetVerAdj() == v2) { pt-&gt;Getlink() = p-&gt;Getlink(); delete p; break; } pt = p; p = p-&gt;Getlink(); } if(p == NULL) //&#x5230;&#x90BB;&#x63A5;&#x8868;&#x672B;&#x7AEF;&#x4ECD;&#x672A;&#x627E;&#x5230;v2 &#x5219;&#x8FB9;&#x4E0D;&#x5B58;&#x5728; { return -1; //&#x8FD4;&#x56DE;-1&#x8868;&#x793A;&#x6240;&#x5220;&#x9664;&#x7684;&#x8FB9;&#x4E0D;&#x5B58;&#x5728; } return 0; } int DeleteGraph_List() { for(int i = 0; i &lt;= graphsize - 1; i++) { Edge *p = Head[i].Getadj(); Edge *q = p; while(p != NULL) { p = p-&gt;Getlink(); delete q; q = p; } } delete [] Head; delete map; return 0; }public: int&amp; GetMaxCost() { return MaxCost; } Vertex*&amp; GetHead() { return Head; } IMAGE *&amp; GetMap() { return map; } int GetIndex(int marki) //&#x6309;&#x4EE3;&#x53F7;&#x67E5;&#x627E;&#x5728;&#x9876;&#x70B9;&#x8868;&#x4E2D;&#x7684;&#x4F4D;&#x7F6E; { for(int i = 0; i &lt;= graphsize - 1; i++) { if(marki == Head[i].GetMark()) { return i; } } return -1; //&#x627E;&#x4E0D;&#x5230;&#x5219;&#x8FD4;&#x56DE;-1 } int GetIndex(string name) //&#x6309;&#x540D;&#x79F0;&#x67E5;&#x627E;&#x5728;&#x9876;&#x70B9;&#x8868;&#x4E2D;&#x7684;&#x4F4D;&#x7F6E; { for(int i = 0; i &lt;= graphsize - 1; i++) { if(name == Head[i].GetVerName()) { return i; } } return -1; //&#x627E;&#x4E0D;&#x5230;&#x5219;&#x8FD4;&#x56DE;-1 } int graph_con(fstream &amp;file,char* mapname) //&#x63D2;&#x5165;&#x8FB9;&#x521B;&#x5EFA; { DeleteGraph_List();//&#x5148;&#x628A;&#x7C7B;&#x91CC;&#x9762;&#x4E4B;&#x524D;&#x7684;&#x5185;&#x5BB9;&#x5220;&#x9664;&#x6389; map=new IMAGE; loadimage(map, _T(mapname)); file &gt;&gt; MaxCost; file &gt;&gt; graphsize; Head = new Vertex[graphsize]; for(int i = 0; i &lt;= graphsize - 1; i++) { file &gt;&gt; Head[i].GetVerName(); file &gt;&gt; Head[i].GetDescribe(); file &gt;&gt; Head[i].GetMark(); file &gt;&gt; Head[i].GetX(); Head[i].GetX()+=LEFTBORDER; //&#x52A0;&#x5DE6;&#x8FB9;&#x754C; file &gt;&gt; Head[i].GetY(); Head[i].GetY()+=TOPBORDER; //&#x52A0;&#x4E0A;&#x8FB9;&#x754C; Head[i].Getadj() = NULL; } int edgenum; file &gt;&gt; edgenum; for(int j = 0; j &lt;= edgenum - 1; j++) { int v1, v2, weight; file &gt;&gt; v1; file &gt;&gt; v2; double dx=Head[GetIndex(v2)].GetX(); double sx=Head[GetIndex(v1)].GetX(); double dy=Head[GetIndex(v2)].GetY(); double sy=Head[GetIndex(v1)].GetY();weight=(double)sqrt(((dx-sx)*(dx-sx)+(dy-sy)*(dy-sy))/24250.0)*300.0; //&#x901A;&#x8FC7;&#x5750;&#x6807;&#x8BA1;&#x7B97;&#x8FB9;&#x957F;&#x5EA6; &#x8D4B;&#x7ED9;weight InsertEdge(GetIndex(v1),GetIndex(v2), weight); } return 0; } Graph_List() //&#x6784;&#x9020;&#x51FD;&#x6570; &#x6784;&#x9020;&#x4E00;&#x4E2A;&#x7A7A;&#x56FE; { Head=NULL; map=NULL; map=new IMAGE; graphsize=0; MaxCost=0; } ~Graph_List(){ DeleteGraph_List(); } int SaveFile(char* filename){ system(&quot;del filename &quot;); //&#x5220;&#x9664;&#x6587;&#x4EF6; ofstream fl(filename);//&#x6253;&#x5F00;&#x6587;&#x4EF6;&#x7528;&#x4E8E;&#x5199;&#xFF0C;&#x82E5;&#x6587;&#x4EF6;&#x4E0D;&#x5B58;&#x5728;&#x5C31;&#x521B;&#x5EFA;&#x5B83; if(!fl)return -1;//&#x6253;&#x5F00;&#x6587;&#x4EF6;&#x5931;&#x8D25;&#x5219;&#x7ED3;&#x675F;&#x8FD0;&#x884C; fl &lt;&lt; GetMaxCost() &lt;&lt; endl; fl &lt;&lt; NumberOfVertices() &lt;&lt; endl; for(int i = 0; i &lt;= NumberOfVertices() - 1; i++) { fl &lt;&lt; Head[i].GetVerName() &lt;&lt; &quot;\t\t\t&quot; &lt;&lt; Head[i].GetDescribe() &lt;&lt; &quot;\t\t\t\t\t\t&quot; &lt;&lt; Head[i].GetMark() &lt;&lt; &quot;\t&quot; &lt;&lt; Head[i].GetX() - LEFTBORDER &lt;&lt; &quot;\t&quot; &lt;&lt; Head[i].GetY() - TOPBORDER &lt;&lt; endl; } //&#x7528;&#x5236;&#x8868;&#x7B26;&#x5BF9;&#x9F50; fl &lt;&lt; endl; int numofedges =NumberOfEdges() * 2; fl &lt;&lt; numofedges &lt;&lt; endl; int num = 0; for(int j = 0; j &lt;= NumberOfVertices() - 1; j++) { Edge *p = Head[j].Getadj(); while(p != NULL) { if(num == 5) { fl &lt;&lt; endl; num = 0; } fl &lt;&lt; GetHead()[j].GetMark() &lt;&lt; &quot;\t&quot; &lt;&lt; GetHead()[p-&gt;GetVerAdj()].GetMark() &lt;&lt; endl; p = p-&gt;Getlink(); num++; } } fl.close(); return 0; } bool GraphEmpty()const { return graphsize == 0; } int NumberOfVertices ()const { return graphsize; } int NumberOfEdges ()const { int n = 0; for(int i = 0; i &lt;= graphsize - 1; i++) { Edge *p = Head[i].Getadj(); while(p != NULL) { n++; p = p-&gt;Getlink(); } } return n / 2; //&#x8FD4;&#x56DE;&#x8FB9;&#x7684;&#x6570;&#x76EE; &#x4E0D;&#x8BA1;&#x91CD;&#x590D;&#x8FB9; } int GetWeight(const int &amp;v1, const int &amp;v2) { if(v1 &gt; graphsize - 1 || v2 &gt; graphsize - 1 || v1 &lt; 0 || v2 &lt; 0) { //cout &lt;&lt; &quot;&#x67E5;&#x627E;&#x5143;&#x7D20;&#x8D85;&#x754C;&#xFF01;&quot; &lt;&lt; endl; return -1; } if(v1 == v2) /////// { return 0; } Edge *p = Head[v1].Getadj(); while(p != NULL &amp;&amp; p-&gt;GetVerAdj() != v2) { p = p-&gt;Getlink(); } if(p != NULL) { return p-&gt;Getcost(); } else return MaxCost + 1; //&#x4E24;&#x70B9;&#x4E4B;&#x95F4;&#x6CA1;&#x6709;&#x8FB9;&#x5219;&#x8FD4;&#x56DE; MaxCost + 1 } void InsertVertex(string name,string describe,int mark,int x,int y) { Vertex *head = new Vertex[graphsize + 1]; //&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x9876;&#x70B9;&#x8868; &#x5927;&#x5C0F;&#x4E3A;&#x73B0;&#x6709;&#x5927;&#x5C0F;&#x518D;&#x52A0;1 for(int i = 0; i &lt;= graphsize - 1; i++) //&#x590D;&#x5236;&#x73B0;&#x6709;&#x9876;&#x70B9;&#x8868;&#x7684;&#x5185;&#x5BB9;&#x5230;&#x65B0;&#x9876;&#x70B9;&#x8868; { head[i] = Head[i]; } head[graphsize].GetVerName() = name; //&#x628A;&#x65B0;&#x6DFB;&#x52A0;&#x7684;&#x9876;&#x70B9;&#x52A0;&#x5728;&#x65B0;&#x9876;&#x70B9;&#x8868;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x4F4D;&#x7F6E; head[graphsize].GetDescribe() = describe; head[graphsize].GetMark() = mark; head[graphsize].GetX() = x; head[graphsize].GetY() = y; head[graphsize].Getadj() = NULL; delete [] Head; //&#x5220;&#x9664;&#x539F;&#x9876;&#x70B9;&#x8868; Head = head; //&#x628A;Head&#x6307;&#x9488;&#x6307;&#x5411;&#x65B0;&#x9876;&#x70B9;&#x8868; graphsize++; //&#x66F4;&#x65B0;&#x9876;&#x70B9;&#x6570;&#x76EE; } int InsertEdge(int v1,int v2, int weight) { if(v1 &gt; graphsize - 1 || v2 &gt; graphsize - 1 || v1 &lt; 0 || v2 &lt; 0) { //cerr &lt;&lt; &quot;&#x63D2;&#x5165;&#x5143;&#x7D20;&#x8D85;&#x754C;&#xFF01;&#x65E0;&#x6CD5;&#x5B8C;&#x6210;&#x64CD;&#x4F5C;&#xFF01;&quot; &lt;&lt; endl; return -1; //&#x63D2;&#x5165;&#x5143;&#x7D20;&#x8D85;&#x754C;&#x8FD4;&#x56DE;-1 } if(weight &gt; MaxCost) { //cerr &lt;&lt; &quot;&#x63D2;&#x5165;&#x6743;&#x503C;&#x8D85;&#x51FA;&#x6700;&#x5927;&#x6743;&#x503C;&#xFF01;&#x65E0;&#x6CD5;&#x5B8C;&#x6210;&#x64CD;&#x4F5C;&#xFF01;&quot; &lt;&lt; endl; return -2; //&#x8FD4;&#x56DE;-2&#x8868;&#x793A;&#x6743;&#x503C;&#x8FC7;&#x5927; } if(v1 == v2) { //cerr &lt;&lt; &quot;&#x64CD;&#x4F5C;&#x4E0D;&#x5408;&#x6CD5;&quot; &lt;&lt; endl; return -3; } int i=InsertEdge_Do(v1, v2, weight); if(i==-4){ //&#x8FB9;&#x5DF2;&#x5B58;&#x5728; return i; } InsertEdge_Do(v2, v1, weight); return i; } int DeleteVertex(const int &amp;v) { if(v &gt; graphsize - 1 || v &lt; 0) { //cerr &lt;&lt; &quot;&#x5220;&#x9664;&#x5143;&#x7D20;&#x8D85;&#x754C;&#xFF01;&quot; &lt;&lt; endl; return -1; //&#x8D85;&#x754C;&#x8FD4;&#x56DE;-1 } for(int i = 0; i &lt;= graphsize - 1; i++) { DeleteEdge(i, v); //&#x5220;&#x9664;&#x6307;&#x5411;&#x8BE5;&#x9876;&#x70B9;&#x7684;&#x6240;&#x6709;&#x8FB9; } for(int j = v; j &lt;= graphsize - 2; j++) { Head[j] = Head[j + 1]; //&#x628A;&#x8BE5;&#x9876;&#x70B9;&#x540E;&#x8FB9;&#x7684;&#x5143;&#x7D20;&#x5411;&#x524D;&#x632A;&#x4E00;&#x4E2A;&#x4F4D;&#x7F6E; } graphsize--; //&#x66F4;&#x65B0;graphsize for(int k = 0; k &lt;= graphsize - 1; k++) { Edge *p = Head[k].Getadj(); while(p != NULL) { if(p-&gt;GetVerAdj() &gt; v) { p-&gt;GetVerAdj()--; //&#x6240;&#x6709;&#x8FB9;&#x4E4B;&#x4E2D;&#x6307;&#x5411;&#x6240;&#x5220;&#x9664;&#x9876;&#x70B9;&#x4E4B;&#x540E;&#x4F4D;&#x7F6E;&#x7684; &#x90FD;&#x8981;&#x51CF;1 } p = p-&gt;Getlink(); } } return 0; } int ModifyVertex(int v,string&amp; name,string&amp; describe,int&amp; marki,int&amp; x,int&amp; y){ if(v &lt; 0 || v &gt; NumberOfVertices() - 1) { return -1; } Head[v].GetVerName() = name; Head[v].GetDescribe() = describe; Head[v].GetMark() = marki; Head[v].GetX() = x; Head[v].GetX() += LEFTBORDER; Head[v].GetY() = y; Head[v].GetY() += TOPBORDER; return 0; } int DeleteEdge(int v2, int v1) { if(v1 &gt; graphsize - 1 || v2 &gt; graphsize - 1 || v1 &lt; 0 || v2 &lt; 0) { //cerr &lt;&lt; &quot;&#x5220;&#x9664;&#x5143;&#x7D20;&#x8D85;&#x754C;&#xFF01;&quot; &lt;&lt; endl; return -1; } if(v1 == v2) { return -1; } int i=DeleteEdge_Do(v1,v2); if(i==-1){return i;} DeleteEdge_Do(v2,v1); return i; } int DShortestPath(const int v,int*&amp; path) { int n = graphsize; int *s = new int[n]; int *dist = new int[n]; int i = 0, temp = 0; for (i = 0; i &lt; n; i++) { s[i] = 0; dist[i] = MaxCost*graphsize*(graphsize-1)/2; path[i] = -1; } int u = v; Edge *p = NULL; dist[u] = 0; s[u] = 1; path[u] = u; for (i = 0; i &lt; n; i++) { s[u] = 1; p = Head[u].Getadj(); while (p != NULL) { temp = p-&gt;GetVerAdj(); if (dist[u] + p-&gt;Getcost ()&lt; dist[temp]) { dist[temp] = dist[u] + p-&gt;Getcost(); path[temp] = u; } p = p-&gt;Getlink(); } temp =MaxCost*graphsize*(graphsize-1)/2;; for (int j = 0; j &lt; n; j++) { if (s[j] == 0 &amp;&amp; dist[j] &lt; temp) { temp = dist[j]; u = j;//&#x672A;&#x8BBF;&#x95EE;&#x4E2D;&#x6700;&#x5C0F; } } } delete[]s; delete[]dist; return 0; }};#endif 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//Stack.h#ifndef _MYStack_h_#define _MYStack_h_template&lt;class TL&gt;class LStack;//&#x7ED3;&#x70B9;&#x5B9A;&#x4E49;template&lt;class TL&gt;class LStackNode{private: TL data; LStackNode&lt;TL&gt;* next;public: friend class LStack&lt;TL&gt;; LStackNode() { next=NULL; } LStackNode(TL item,LStackNode&lt;TL&gt;* nextnode=NULL) { data=item; next=nextnode; } LStackNode(LStackNode&lt;TL&gt;&amp; node) { data=node.data; // &#x4E3A;&#x4EC0;&#x4E48;&#x5FC5;&#x987B;&#x662F;&#x5F15;&#x7528;&amp;&#x624D;&#x884C; next=node.next; }};//&#x6808;&#x5B9A;&#x4E49;template&lt;class TL&gt;class LStack{private: LStackNode&lt;TL&gt; * top;public: LStack() { top=NULL; } bool Push(const TL&amp; item) { LStackNode&lt;TL&gt;* p=top; top=new LStackNode&lt;TL&gt;; top-&gt;data=item; top-&gt;next=p; return true; } bool Pop( TL&amp; item) { if(top==NULL) { return false; } else { item=top-&gt;data; LStackNode&lt;TL&gt; * p=top; top=top-&gt;next; delete p; } return true; } bool Peek( TL&amp; item) { if(top==NULL) { return false; } else { item=top-&gt;data; } } ~LStack() { LStackNode&lt;TL&gt;* p=top; while(top!=NULL) { top=top-&gt;next; delete p; p=top; } top=p=NULL; } bool IsEmpty() { return top==NULL; }}; #endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//functions.h#ifndef _Functions_h_#define _Functions_h_#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;math.h&gt;#include &lt;sstream&gt;using namespace std;string int_to_str(int n){ std::stringstream ss; std::string str; ss&lt;&lt;n; ss&gt;&gt;str; return str;}int str_to_num1(const char*&amp; str){ if(!(str[0]==&apos;-&apos;||(str[0]&gt;=&apos;0&apos;&amp;&amp;str[0]&lt;=&apos;9&apos;))){ return INT_MIN; } int n=0; while(str[n]!=&apos;\0&apos;){ n++; } int number=0; if(str[0]!=&apos;-&apos;){ for(int i=0;i&lt;n;i++){ if(!(str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;)){ return INT_MIN; } number+=(str[i]-&apos;0&apos;)*pow(10,n-i-1); } } if(str[0]==&apos;-&apos;){ for(int i=1;i&lt;n;i++){ if(!(str[i]&gt;=&apos;0&apos;&amp;&amp;str[i]&lt;=&apos;9&apos;)){ return INT_MIN; } number+=(str[i]-&apos;0&apos;)*pow(10,n-i-1); } number*=-1; } return number;}int str_to_num(const string&amp; str){ const char* data=str.c_str(); int number=str_to_num1(data); return number;}#endif &#x2002;&#x2002;&#x2002;&#x2002; &#x8D44;&#x6E90;&#x6587;&#x4EF6;&#xFF1A;map.txt&#x5185;&#x5BB9; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837994&#x4E1C;&#x95E8; &#x5B66;&#x6821;&#x6B63;&#x95E8; 1 974 182&#x56FE;&#x4E66;&#x9986; &#x4E00;&#x697C;&#x53EF;&#x81EA;&#x4E60;&#xFF0C;&#x53EF;&#x901A;&#x5BB5; 2 693 210&#x8BA1;&#x7B97;&#x673A;&#x697C; &#x8BA1;&#x7B97;&#x673A;&#x5B66;&#x9662;&#x548C;&#x8F6F;&#x4EF6;&#x5B66;&#x9662;&#x516C;&#x7528;&#x5B9E;&#x9A8C;&#x6559;&#x5B66;&#x697C; 3 665 335&#x7B2C;&#x4E09;&#x6559;&#x5B66;&#x697C; &#x4E00;&#x6559;&#x4E8C;&#x6559;&#x4E0D;&#x5728;&#x672C;&#x6821;&#x533A;&#x256E;(&#x256F;_&#x2570;)&#x256D; 4 739 277&#x9038;&#x592B;&#x697C; &#x516C;&#x5171;&#x6559;&#x5B66;&#x697C; 5 585 147&#x5317;&#x95E8; &#x6700;&#x7E41;&#x5FD9;&#x7684;&#x5B66;&#x6821;&#x5927;&#x95E8; 6 528 25&#x529E;&#x516C;&#x697C; &#x884C;&#x653F;&#x4EBA;&#x5458;&#x529E;&#x516C;&#x697C; 7 528 219&#x56DB;&#x98DF;&#x5802; &#x6700;&#x5C0F;&#x98DF;&#x5802;&#xFF0C;&#x5374;&#x5C45;&#x4E8E;&#x6700;&#x91CD;&#x8981;&#x4F4D;&#x7F6E; 8 420 252&#x4F53;&#x80B2;&#x9986; &#x5927;&#x578B;&#x6D3B;&#x52A8;&#x4E3E;&#x529E;&#x5730; 9 440 300&#x4F53;&#x80B2;&#x8FD0;&#x52A8;&#x573A; &#x4E3B;&#x4F53;&#x80B2;&#x573A; 10 325 277&#x5357;&#x82D1; &#x5B66;&#x751F;&#x516C;&#x5BD3; 11 380 460&#x5C0F;&#x5317;&#x95E8; &#x5C0F;&#x6821;&#x95E8; 12 365 129&#x7ECF;&#x4FE1;&#x6559;&#x5B66;&#x697C; &#x7ECF;&#x6D4E;&#x4FE1;&#x606F;&#x5B66;&#x9662;&#x6559;&#x5B66;&#x697C; 13 149 448&#x5317;&#x82D1; &#x5B66;&#x751F;&#x516C;&#x5BD3; 14 215 169&#x65B0;&#x98DF;&#x5802; &#x98DF;&#x5802;&#xFF0C;&#x6709;&#x4E24;&#x5C42; 15 252 383&#x674E;&#x56DB;&#x5149;&#x697C; &#x5730;&#x8D28;&#x6559;&#x5B66;&#x697C; 16 34 343* * 17 202 427* * 18 213 245* * 19 261 237* * 20 249 194* * 21 475 235* * 22 346 200* * 23 388 183* * 24 399 321* * 25 299 362* * 26 447 157* * 27 497 276* * 28 529 352* * 29 649 297* * 30 759 210* * 31 651 211* * 32 545 256* * 33 978 10* * 34 439 140&#x97F3;&#x4E50;&#x5385; &#x97F3;&#x4E50;&#x5385; 35 489 125&#x9038;&#x592B;&#x56FE;&#x4E66;&#x9986; &#x6821;&#x53F2;&#x9648;&#x5217;&#x9986; 36 496 147&#x9EA6;&#x514B;&#x5FB7;&#x5C14;&#x7C73;&#x5FB7;&#x5B9E;&#x9A8C;&#x5BA4; &#x5B9E;&#x9A8C;&#x5BA4; 37 568 115* * 38 21 303* * 39 760 182&#x5510;&#x6556;&#x5E86;&#x697C; &#x5510;&#x6556;&#x5E86;&#x697C; 40 757 125* * 41 758 151* * 42 650 154* * 43 597 175* * 44 521 205&#x5916;&#x8BED;&#x697C; &#x5916;&#x8BED;&#x5B66;&#x9662;&#x6559;&#x5B66;&#x697C; 45 550 115&#x7BEE;&#x7403;&#x573A; &#x65B0;&#x98DF;&#x5802;&#x7BEE;&#x7403;&#x573A; 46 231 340&#x5321;&#x4E9A;&#x660E;&#x697C; &#x5321;&#x4E9A;&#x660E;&#x697C; 47 614 375* * 48 596 321&#x5357;&#x95E8; &#x5357;&#x95E8; 49 479 521* * 50 517 324&#x8398;&#x5B50;&#x56ED;&#x98DF;&#x5802; &#x8398;&#x5B50;&#x56ED;&#x98DF;&#x5802; 51 365 369* * 52 354 340* * 53 572 459* * 54 432 397* * 55 446 430* * 56 453 451* * 57 551 410* * 58 637 420* * 59 688 389* * 60 274 276* * 61 239 299* * 62 114 303* * 63 136 338* * 64 72 383* * 65 170 363* * 66 202 404* * 67 648 176* * 68 464 205* * 69 315 422* * 70 373 395* * 71 419 375* * 72 330 478* * 73 272 488* * 74 260 441* * 75 201 507* * 76 201 459&#x7ECF;&#x4FE1;&#x516C;&#x5BD3; &#x7ECF;&#x4FE1;&#x516C;&#x5BD3; 77 277 525* * 78 658 317* * 79 132 453&#x897F;&#x95E8; &#x897F;&#x95E8; 80 66 488&#x7269;&#x7406;&#x697C; &#x7269;&#x7406;&#x697C; 81 644 83&#x751F;&#x79D1;&#x697C; &#x751F;&#x547D;&#x79D1;&#x5B66;&#x697C; 82 859 81* * 83 861 180* * 84 862 259&#x4E1C;&#x8363; 0 85 804 211&#x6570;&#x5B66;&#x697C; &#x6570;&#x5B66;&#x5B66;&#x9662;&#x6570;&#x5B66;&#x697C; 86 913 259* * 87 711 85* * 88 718 56* * 89 789 57* * 90 796 80* * 91 861 207* * 92 861 150* * 93 410 226* * 94 511 1841 33 83 30 31 59 78 29 30 78 85 37 43 12 33 35 37 81 21 32 44 9 21 93 8 24 27 50 19 22 24 25 55 72 6 20 23 34 17 79 20 38 25 66 20 38 62 64 13 66 76 19 62 10 18 20 22 60 12 14 16 19 7 8 26 27 10 19 23 24 12 22 26 93 9 10 22 52 71 10 15 52 60 69 21 23 34 9 21 32 50 48 50 53 54 4 31 32 48 78 2 4 39 85 2 29 32 43 67 7 27 29 31 1 6 12 26 35 6 34 36 35 45 94 5 6 45 81 14 16 30 40 41 67 83 39 39 42 92 41 43 67 81 5 31 42 44 67 7 43 94 36 37 61 66 48 58 28 29 47 53 56 9 27 28 52 70 24 25 51 28 49 58 28 55 71 11 54 56 49 55 57 56 47 53 59 3 58 19 25 61 46 60 65 16 18 63 62 64 65 16 63 79 61 63 66 15 17 46 65 31 39 42 43 93 94 25 70 72 74 51 69 71 24 54 70 11 69 73 72 74 75 77 69 73 76 73 76 17 74 75 73 3 4 29 13 64 80 79 6 37 42 87 90 92 1 39 91 92 86 91 4 30 91 84 81 88 87 89 88 90 82 89 83 84 85 41 82 83 8 23 68 36 44 68 map.jpg &#x5927;&#x4E8C;&#x4E0A;&#x5B66;&#x671F;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x8BFE;&#x7A0B;&#x8BBE;&#x8BA1;&#x5199;&#x6B64;&#x7A0B;&#x5E8F;&#x3002; 2016.4.12&#x66F4;&#x65B0;&#x535A;&#x5BA2;&#x3002;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[五子棋估值算法]]></title>
      <url>2015%2F09%2F21%2F%E4%BA%94%E5%AD%90%E6%A3%8B%2F</url>
      <content type="text"><![CDATA[&#x76EE;&#x5F55; &#x7A0B;&#x5E8F;&#x5E03;&#x5C40; &#x4F30;&#x503C;&#x7B97;&#x6CD5; &#x6210;&#x679C; &#x5B8C;&#x6574;&#x4EE3;&#x7801; &#x2002;&#x2002;&#x2002;&#x2002; &#x7A0B;&#x5E8F;&#x5E03;&#x5C40;&#x9996;&#x5148;&#x8BF4;&#x660E;&#x6574;&#x4E2A;&#x4E94;&#x5B50;&#x68CB;&#x7A0B;&#x5E8F;&#x7684;&#x6574;&#x4F53;&#x5E03;&#x5C40;&#x3002;&#xFF08;&#x7528;Java&#x5B9E;&#x73B0;&#xFF09;1234567891011121314151617181920212223242526class Chess{ //&#x754C;&#x9762;&#x7C7B;&#x3000;&#x3000;Player player1 ;&#x3000;&#x3000;Player player2;&#x3000;&#x3000;ChessBox box;&#x3000;&#x3000;//&#x5176;&#x4F59;&#x754C;&#x9762;&#x663E;&#x793A;&#x76F8;&#x5173;&#x51FD;&#x6570;;}class Player{&#x3000;&#x3000;int code;&#x3000;&#x3000;//&#x4EE3;&#x53F7;&#x3000;&#x3000;1:&#x9009;&#x624B;1 2:&#x9009;&#x624B;2&#x3000;&#x3000;ChessBox box; &#x3000;&#x3000;&#x3000;abstract Point play(); //&#x843D;&#x5B50;&#x64CD;&#x4F5C; &#x3000;&#x3000;&#x3000;int getLine(Point p, int i, int j) ;}class Person extends Player{ &#x3000;&#x3000;Point play(int x,int y );}class Robot extends Player{&#x3000;&#x3000;//&#x673A;&#x5668;&#x3000;&#x3000;int evaluate(Point, int, int);&#x3000;&#x3000;int Evaluate(Point);&#x3000;&#x3000;Point play();}class ChessBox{&#x3000;&#x3000;int chess_flag[15][15] //0:&#x7A7A; 1:&#x9009;&#x624B;1 2:&#x9009;&#x624B;2} &#x2002;&#x2002;&#x2002;&#x2002; &#x4F30;&#x503C;&#x7B97;&#x6CD5;&#x8981;&#x6C42;&#x5206;&#x6790;&#x3000;&#x3000;&#x4F30;&#x503C;&#x7B97;&#x6CD5;&#x3002;&#x8981;&#x6C42;&#x7ED9;&#x5B9A;&#x68CB;&#x76D8;&#x4E0A;&#x4E00;&#x4E2A;&#x70B9;&#xFF0C;&#x6C42;&#x51FA;&#x8BE5;&#x70B9;&#x5728;&#x5F53;&#x524D;&#x68CB;&#x5C40;&#x4E0B;&#x7684;&#x6743;&#x503C;&#x3002;&#x82E5;&#x5728;&#x8BE5;&#x70B9;&#x843D;&#x5B50;&#x540E;&#x66F4;&#x5BB9;&#x6613;&#x63A5;&#x8FD1;&#x80DC;&#x5229;&#xFF0C;&#x5219;&#x8BE5;&#x70B9;&#x6743;&#x503C;&#x5C31;&#x9AD8;&#xFF0C;&#x8D8A;&#x63A5;&#x8FD1;5&#x5B50;&#x76F8;&#x8FDE;&#xFF0C;&#x6743;&#x503C;&#x8D8A;&#x9AD8;&#x3002; &#x3000;&#x3000;&#x5219;&#x51FD;&#x6570;&#x7684;&#x5F62;&#x5F0F;&#x4E3A;int Evaluate(Point p); &#x3000;&#x3000;&#x9996;&#x5148;&#x8003;&#x8651;&#x6BCF;&#x4E2A;&#x70B9;&#x6709;8&#x4E2A;&#x65B9;&#x5411;&#x53EF;&#x4EE5;&#x8FDE;&#x5B50;&#xFF0C;&#x6BCF;&#x4E2A;&#x65B9;&#x5411;&#x4E0A;&#x53C8;&#x6709;&#x591A;&#x79CD;&#x8FDE;&#x5B50;&#x68CB;&#x578B;&#xFF0C;&#x5982;&#x6D3B;&#x56DB;&#x3001;&#x6D3B;&#x4E09;&#x3001;&#x6B7B;&#x4E09;&#x7B49;&#xFF0C;&#x800C;&#x8FD9;&#x4E9B;&#x5B50;&#x53C8;&#x53EF;&#x80FD;&#x5C5E;&#x4E8E;&#x5DF1;&#x65B9;&#x6216;&#x8005;&#x5BF9;&#x65B9;&#x3002;&#x6D3B;&#x56DB;&#x4E0E;&#x6D3B;&#x4E09;&#x7684;&#x6743;&#x503C;&#x81EA;&#x7136;&#x4E0D;&#x540C;&#x3002;&#x800C;&#x540C;&#x6837;&#x662F;&#x6D3B;&#x4E09;&#xFF0C;&#x5DF1;&#x65B9;&#x7684;&#x6D3B;&#x4E09;&#x4E0E;&#x5BF9;&#x65B9;&#x7684;&#x6D3B;&#x4E09;&#x6743;&#x503C;&#x4E5F;&#x4E0D;&#x540C;&#xFF0C;&#x8FD9;&#x6837;&#x624D;&#x80FD;&#x5B9E;&#x73B0;&#x653B;&#x5B88;&#x7684;&#x7B56;&#x7565;&#x3002;&#x5047;&#x5982;&#x73B0;&#x5728;&#x68CB;&#x5C40;&#x4E0A;&#x540C;&#x65F6;&#x6709;&#x5DF1;&#x65B9;&#x7684;&#x6D3B;&#x4E09;&#x548C;&#x5BF9;&#x65B9;&#x7684;&#x6D3B;&#x4E09;&#xFF0C;&#x6B64;&#x65F6;&#x8F6E;&#x5230;&#x6211;&#x65B9;&#x843D;&#x5B50;&#xFF0C;&#x5219;&#x6B63;&#x5E38;&#x60C5;&#x51B5;&#x4E0B;&#x5E94;&#x5F53;&#x5728;&#x5DF1;&#x65B9;&#x6D3B;&#x4E09;&#x4E0A;&#x843D;&#x5B50;&#xFF0C;&#x4F7F;&#x4E4B;&#x6210;&#x4E3A;&#x6D3B;&#x56DB;&#xFF0C;&#x4ECE;&#x800C;&#x83B7;&#x80DC;&#x3002;&#x5219;&#x8BA1;&#x7B97;&#x673A;&#x5728;&#x5224;&#x65AD;&#x68CB;&#x5C40;&#x65F6;&#xFF0C;&#x9047;&#x5230;&#x5DF1;&#x65B9;&#x6D3B;&#x4E09;&#xFF0C;&#x6743;&#x503C;&#x5E94;&#x5F53;&#x8F83;&#x9AD8;&#xFF0C;&#x9047;&#x5230;&#x5BF9;&#x65B9;&#x6D3B;&#x4E09;&#xFF0C;&#x6743;&#x503C;&#x5E94;&#x5F53;&#x8F83;&#x4F4E;&#x3002; &#x3000;&#x3000;&#x4EE5;&#x4E0A;&#x5373;&#x662F;&#x5BF9;&#x4E8E;&#x4F30;&#x503C;&#x51FD;&#x6570;&#x6240;&#x5E94;&#x8FBE;&#x5230;&#x7684;&#x8981;&#x6C42;&#x7684;&#x5206;&#x6790;&#x3002; &#x65B9;&#x5411;&#x95EE;&#x9898;&#x3000;&#x3000;&#x7531;&#x4E8E;&#x7740;&#x773C;&#x5904;&#x5728;&#x4E8E;&#x5BF9;&#x68CB;&#x578B;&#x7684;&#x5224;&#x65AD;&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x65B9;&#x5411;&#xFF0C;&#x6240;&#x4EE5;&#x9996;&#x5148;&#x5E94;&#x8BE5;&#x60F3;&#x4E2A;&#x65B9;&#x6CD5;&#x628A;&#x65B9;&#x5411;&#x95EE;&#x9898;&#x5148;&#x89E3;&#x51B3;&#x6389;&#xFF0C;&#x8FD9;&#x6837;&#x5728;&#x68CB;&#x578B;&#x5224;&#x65AD;&#x65F6;&#x5C31;&#x80FD;&#x591F;&#x5BF9;&#x5404;&#x4E2A;&#x65B9;&#x5411;&#x8FDB;&#x884C;&#x6BD4;&#x8F83;&#x7EDF;&#x4E00;&#x7684;&#x5904;&#x7406;&#xFF0C;&#x4E0D;&#x81F3;&#x4E8E;&#x68CB;&#x578B;&#x5224;&#x65AD;&#x65F6;&#x5BF9;&#x6BCF;&#x4E2A;&#x65B9;&#x5411;&#x90FD;&#x5199;&#x4E00;&#x6BB5;&#x4EE3;&#x7801;&#x3002; &#x3000;&#x3000;&#x7EE7;&#x7EED;&#x5206;&#x6790;&#xFF0C;&#x5728;&#x5224;&#x65AD;&#x68CB;&#x578B;&#x65F6;&#xFF0C;&#x7740;&#x773C;&#x70B9;&#x5728;&#x4E8E;&#x68CB;&#x5B50;&#x7684;&#x76F8;&#x5BF9;&#x4F4D;&#x7F6E;&#xFF0C;&#x800C;&#x5E38;&#x89C1;&#x68CB;&#x578B;&#x90FD;&#x5448;&#x7EBF;&#x5F62;&#x6392;&#x5217;&#xFF0C;&#x6240;&#x4EE5;&#x8FD9;&#x4E2A;&#x76F8;&#x5BF9;&#x4F4D;&#x7F6E;&#x4E5F;&#x5C31;&#x662F;&#x987A;&#x5E8F;&#x3002;&#x76F8;&#x5BF9;&#x4F4D;&#x7F6E;&#x3001;&#x987A;&#x5E8F;&#xFF0C;&#x5F88;&#x5BB9;&#x6613;&#x60F3;&#x5230;&#x8981;&#x7528;&#x4E00;&#x7EF4;&#x7684;&#x5750;&#x6807;&#x89E3;&#x51B3;&#x3002;&#x82E5;&#x53D6;&#x67D0;&#x4E00;&#x659C;&#x5217;&#xFF08;&#x884C;&#x3001;&#x5217;&#xFF09;&#xFF0C;&#x5047;&#x8BBE;&#x5F53;&#x524D;&#x70B9;&#x7684;&#x5750;&#x6807;&#x4E3A;0&#xFF0C;&#x53D6;&#x53F3;&#x4E0B;&#xFF08;&#x4E0B;&#x3001;&#x53F3;&#x3001;&#x53F3;&#x4E0A;&#xFF09;&#x4E3A;&#x6B63;&#x65B9;&#x5411;&#xFF0C;&#x5219;&#x5728;&#x8BE5;&#x659C;&#x5217;&#xFF08;&#x884C;&#x3001;&#x5217;&#xFF09;&#x4E0A;&#x5404;&#x70B9;&#x90FD;&#x80FD;&#x5F97;&#x5230;&#x76F8;&#x5E94;&#x7684;&#x5750;&#x6807;&#x3002;&#x5982;&#x4E0B;&#x56FE;&#x3002; &#x3000;&#x3000;&#x4F46;&#x82E5;&#x662F;&#x540C;&#x6837;&#x7684;&#x4E00;&#x7EF4;&#x5750;&#x6807;&#xFF0C;&#x4E0D;&#x540C;&#x7684;&#x65B9;&#x5411;&#xFF0C;&#x53C8;&#x4F1A;&#x5BF9;&#x5E94;&#x68CB;&#x76D8;&#x4E0A;&#x4E0D;&#x540C;&#x7684;&#x4F4D;&#x7F6E;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x8BF4;&#xFF0C;&#x4E00;&#x7EF4;&#x5750;&#x6807;&#x8F6C;&#x6362;&#x5230;&#x68CB;&#x76D8;&#x4E0A;&#x7684;&#x4E8C;&#x7EF4;&#x5750;&#x6807;&#xFF0C;&#x8FD8;&#x9700;&#x8981;&#x4E00;&#x4E2A;&#x65B9;&#x5411;&#x3002;&#xFF08;&#x989D;&#xFF0C;&#x60F3;&#x5230;&#x8FD9;&#x91CC;&#xFF0C;&#x7A81;&#x7136;&#x53D1;&#x73B0;&#x81EA;&#x5DF1;&#x7684;&#x601D;&#x8DEF;&#x660E;&#x660E;&#x5C31;&#x662F;&#x6781;&#x5750;&#x6807;&#x554A;&#x3002;&#x3002;&#x3002;&#xFFE3;&#x25A1;&#xFFE3;&#xFF5C;&#xFF5C;&#x2026;&#x2026;&#x2026;&#xFF09; &#x3000;&#x3000;&#x7531;&#x6B64;&#xFF0C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x8FBE;&#x5230;&#x8FD9;&#x4E48;&#x4E00;&#x79CD;&#x8981;&#x6C42;&#xFF1A;&#x7ED9;&#x5B9A;&#x4E00;&#x4E2A;&#x70B9;&#x3001;&#x4E00;&#x4E2A;&#x65B9;&#x5411;&#x3001;&#x4E00;&#x4E2A;&#x76F8;&#x5BF9;&#x5750;&#x6807;&#x503C;&#xFF0C;&#x5C31;&#x80FD;&#x5F97;&#x5230;&#x4E00;&#x4E2A;&#x4E8C;&#x7EF4;&#x5750;&#x6807;&#xFF0C;&#x5BF9;&#x5E94;&#x68CB;&#x76D8;&#x4E0A;&#x4E00;&#x4E2A;&#x70B9;&#xFF0C;&#x8FDB;&#x800C;&#x53EF;&#x4EE5;&#x83B7;&#x5F97;&#x4EFB;&#x610F;&#x4E00;&#x70B9;&#x7684;&#x843D;&#x5B50;&#x60C5;&#x51B5;&#x3002;&#x6240;&#x4EE5;&#x6211;&#x5199;&#x4E86;&#x8FD9;&#x4E48;&#x4E00;&#x4E2A;&#x51FD;&#x6570;&#xFF1A;1int getLine(Point p,int i,int j); &#x3000;&#x3000;&#x5176;&#x4E2D;p&#x4E3A;&#x5F53;&#x524D;&#x70B9;&#xFF0C;i&#x4E3A;&#x65B9;&#x5411;&#xFF0C;&#x53D6;&#x503C;&#x4E3A;&#x4ECE;1&#x5230;8&#x7684;&#x6574;&#x6570;&#xFF0C;&#x5BF9;&#x5E94;8&#x4E2A;&#x65B9;&#x5411;&#xFF0C;j&#x4E3A;&#x76F8;&#x5BF9;&#x4E8E;p&#x70B9;&#x7684;&#x5750;&#x6807;&#x503C;&#x3002;&#x5728;&#x51FD;&#x6570;&#x4F53;&#x5185;&#x8981;&#x4F9D;&#x636E;&#x65B9;&#x5411;&#x5BF9;p&#x7684;x&#x3001;y&#x7684;&#x503C;&#x8FDB;&#x884C;&#x5904;&#x7406;&#x3002;&#x8FD4;&#x56DE;&#x8BE5;&#x70B9;&#x7684;&#x843D;&#x5B50;&#x60C5;&#x51B5;&#xFF0C;0&#x8868;&#x793A;&#x65E0;&#x5B50;&#xFF0C;1&#x6216;2&#x5206;&#x522B;&#x8868;&#x793A;&#x4E24;&#x4E2A;player&#xFF0C;-1&#x8868;&#x793A;&#x8D85;&#x51FA;&#x68CB;&#x76D8;&#x754C;&#x3002; &#x3000;&#x3000;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A; 12345678910111213141516171819202122int getLine(Point p, int i, int j) { // p&#xFF1A;&#x5F53;&#x524D;&#x70B9; i&#xFF1A;&#x65B9;&#x5411; j&#xFF1A;&#x5750;&#x6807;&#x76F8;&#x5BF9;&#x503C; int x = p.x, y = p.y; switch (i) {&#x3000;&#x3000;//&#x5BF9;8&#x4E2A;&#x65B9;&#x5411;&#x7684;&#x5904;&#x7406; case 1 : x = x + j; break; case 2 : x = x + j; y = y + j; break; ... ... case 8 : x = x + j; y = y - j; } if (x &lt; 0 || y &lt; 0 || x &gt; 14 || y &gt; 14) { // &#x8D8A;&#x754C;&#x5904;&#x7406; &#x8FD4;&#x56DE;-1 return -1; } return box.getFlag(x,y); } } &#x68CB;&#x578B;&#x5224;&#x65AD;&#x3000;&#x3000;&#x5BF9;&#x4E8E;&#x65B9;&#x5411;&#x7684;&#x5904;&#x7406;&#x5B8C;&#x6210;&#x540E;&#xFF0C;&#x5C31;&#x662F;&#x68CB;&#x578B;&#x7684;&#x5224;&#x65AD;&#x3002;&#x5224;&#x65AD;&#x68CB;&#x578B;&#x65F6;&#x9700;&#x8981;&#x533A;&#x5206;&#x5F53;&#x524D;&#x6240;&#x5224;&#x65AD;&#x7684;&#x68CB;&#x578B;&#x662F;&#x54EA;&#x4E00;&#x65B9;&#x7684;&#xFF0C;&#x5047;&#x8BBE;&#x5F53;&#x524D;&#x6240;&#x5224;&#x65AD;&#x7684;&#x68CB;&#x578B;&#x6240;&#x5C5E;&#x65B9;&#x7684;&#x4EE3;&#x53F7;&#x4E3A;plyer&#xFF0C;&#x5219;&#x5B83;&#x7684;&#x503C;&#x53EF;&#x4EE5;&#x662F;1&#x6216;2&#xFF0C;&#x800C;&#x8981;&#x786E;&#x5B9A;&#x8FD9;&#x4E2A;plyer&#x662F;&#x81EA;&#x5DF1;&#x8FD8;&#x662F;&#x5BF9;&#x65B9;&#xFF0C;&#x5C31;&#x9700;&#x8981;&#x548C;&#x81EA;&#x5DF1;&#x7684;&#x4EE3;&#x53F7;&#x6BD4;&#x5BF9;&#x4E00;&#x4E0B;&#xFF0C;&#x5047;&#x8BBE;&#x81EA;&#x5DF1;&#x7684;&#x4EE3;&#x53F7;&#x662F;me&#x3002;&#x5219;&#x8FD9;&#x4E2A;&#x5224;&#x65AD;&#x68CB;&#x578B;&#x7684;&#x51FD;&#x6570;&#x5E94;&#x8BE5;&#x6EE1;&#x8DB3;&#x4EE5;&#x4E0B;&#x8981;&#x6C42;&#xFF1A;&#x7ED9;&#x51FA;&#x4E00;&#x4E2A;&#x70B9;p&#xFF0C;&#x81EA;&#x5DF1;&#x7684;&#x4EE3;&#x53F7;me&#xFF0C;&#x4E00;&#x4E2A;plyer&#xFF0C;&#x80FD;&#x5F97;&#x51FA;&#x5F53;&#x524D;&#x70B9;&#x5BF9;&#x5E94;plyer&#x7684;&#x6743;&#x503C;&#x3002;&#x4E8E;&#x662F;&#x51FD;&#x6570;&#x5F62;&#x5F0F;&#x5982;&#x4E0B;&#xFF1A;1int evaluate(Point p, int me,int plyer); &#x3000;&#x3000;&#x7136;&#x540E;&#x7ED3;&#x5408;&#x5DF2;&#x6709;&#x7684;&#x7B97;&#x6CD5;&#x7ED3;&#x6784;&#xFF0C;&#x53C2;&#x8003;&#x4E0B;&#x56FE;&#xFF08;&#x7F51;&#x4E0A;&#x627E;&#x5230;&#x7684;&#xFF09; &#x3000;&#x3000;&#x5C06;&#x68CB;&#x578B;&#x5206;&#x4E3A;&#x4EE5;&#x4E0B;&#x51E0;&#x79CD;&#xFF1A; &#x68CB;&#x578B; &#x7F16;&#x7801; &#x6D3B;&#x56DB; 01111* &#x6B7B;&#x56DB;A 21111* &#x6B7B;&#x56DB;B 111*1 &#x6B7B;&#x56DB;C 11*11 &#x6D3B;&#x4E09;&#xFF08;&#x8FD1;&#x4E09;&#x4F4D;&#x7F6E;&#xFF09; 111*0 &#x6D3B;&#x4E09;&#xFF08;&#x8FDC;&#x4E09;&#x4F4D;&#x7F6E;&#xFF09; 1110* &#x6B7B;&#x4E09; 11*1 &#x5176;&#x4E2D;&#x4EE3;&#x53F7;&#x53CA;&#x542B;&#x4E49;&#x5982;&#x4E0B;&#xFF1A; &#x4EE3;&#x53F7; &#x542B;&#x4E49; * &#x5F53;&#x524D;&#x7A7A;&#x4F4D;&#x7F6E;; 0 &#x5176;&#x4ED6;&#x7A7A;&#x4F4D;&#x7F6E;; 1 plyer(&#x5F53;&#x524D;&#x6240;&#x8BA1;&#x7B97;&#x7684;player&#x7684;&#x4EE3;&#x53F7;); 2 3 - plyer (&#x5BF9;&#x65B9;&#x7684;&#x4EE3;&#x53F7;); &#x3000;&#x3000; &#x6B64;&#x5916;&#x7531;&#x4E8E;&#x4E24;&#x4E2A;&#x6216;&#x591A;&#x4E2A;&#x65B9;&#x5411;&#x4E0A;&#x90FD;&#x6709;&#x6D3B;&#x4E8C;&#x7684;&#x68CB;&#x578B;&#x8F83;&#x4E3A;&#x5E38;&#x89C1;&#x4E14;&#x80DC;&#x7387;&#x8F83;&#x9AD8;&#xFF08;&#x89C1;&#x4E0B;&#x56FE;&#xFF09;&#x3002;&#x6240;&#x4EE5;&#x53C8;&#x589E;&#x52A0;&#x5BF9;&#x6B64;&#x79CD;&#x68CB;&#x578B;&#x7684;&#x5224;&#x65AD;&#x3002; &#x3000;&#x3000;&#x5373;&#x5728;&#x6BCF;&#x4E00;&#x4E2A;&#x65B9;&#x5411;&#x7684;&#x68CB;&#x578B;&#x5224;&#x65AD;&#x4E2D;&#x626B;&#x63CF;011*0&#x6216;111*0&#x5E76;&#x8BA1;&#x6570;&#xFF0C;&#x82E5;&#x6700;&#x7EC8;&#x8BA1;&#x6570;&#x503C;&#x5927;&#x4E8E;&#x7B49;&#x4E8E;2&#xFF0C;&#x5219;&#x6743;&#x503C;&#x589E;&#x52A0;&#x4E00;&#x4E2A;&#x8F83;&#x5927;&#x7684;&#x6570;&#x503C;&#xFF0C;&#x5426;&#x5219;&#x4E0D;&#x589E;&#x52A0;&#x3002; &#x3000;&#x3000; &#x3000;&#x3000;&#x81F3;&#x6B64;&#x53EA;&#x8981;&#x5FAA;&#x73AF;8&#x6B21;&#xFF0C;&#x6BCF;&#x6B21;&#x5FAA;&#x73AF;&#x4E2D;&#x626B;&#x63CF;&#x5404;&#x4E2A;&#x68CB;&#x578B;&#xFF0C;&#x5E76;&#x66F4;&#x65B0;&#x6743;&#x503C;&#xFF08;&#x8BBE;&#x4E3A;value&#xFF09;&#x5373;&#x53EF;&#x3002; &#x3000;&#x3000;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A;1234567891011121314151617181920212223242526272829int evaluate(Point p, int me,int plyer) { /* me:&#x6211;&#x7684;&#x4EE3;&#x53F7;;&#x3000;&#x3000;plyer:&#x5F53;&#x524D;&#x8BA1;&#x7B97;&#x7684;player&#x7684;&#x4EE3;&#x53F7;;*/ int value = 0; int numoftwo=0;&#x3000;&#x3000;&#x3000;&#x3000; for (int i = 1; i &lt;= 8; i++) { // 8&#x4E2A;&#x65B9;&#x5411; // &#x6D3B;&#x56DB; 01111* *&#x4EE3;&#x8868;&#x5F53;&#x524D;&#x7A7A;&#x4F4D;&#x7F6E; 0&#x4EE3;&#x8868;&#x5176;&#x4ED6;&#x7A7A;&#x4F4D;&#x7F6E; if (getLine(p, i, -1) == plyer &amp;&amp; getLine(p, i, -2) == plyer &amp;&amp; getLine(p, i, -3) == plyer &amp;&amp; getLine(p, i, -4) == plyer &amp;&amp; getLine(p, i, -5) == 0) { value += 300000; if(me!=plyer){value-=500;} System.out.print(&quot;+ 300000&quot;); continue; &#x3000;&#x3000; }&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;... //&#x8BA1;&#x7B97;011*0&#x6216;111*0&#x7684;&#x4E2A;&#x6570; if (getLine(p, i, -1) == plyer &amp;&amp; getLine(p, i, -2) == plyer &amp;&amp; getLine(p, i, -3) != 3-plyer&amp;&amp;getLine(p,i,1)!=3-plyer) { numoftwo++; &#x3000;&#x3000;&#x3000; &#x3000; }&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000; ...&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;}&#x3000;&#x3000;&#x3000;&#x3000;if(numoftwo&gt;=2){&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;value+=3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;if(me!=plyer){&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000;&#x3000; value-=100;&#x3000; &#x3000;&#x3000;&#x3000;&#x3000; }&#x3000;&#x3000;&#x3000; } return value;} &#x3000;&#x3000;&#x5176;&#x4E2D;&#x6BCF;&#x79CD;&#x68CB;&#x578B;&#x5BF9;value&#x503C;&#x6240;&#x505A;&#x7684;&#x8D21;&#x732E;&#x8981;&#x4F9D;&#x636E;&#x5B9E;&#x9645;&#x60C5;&#x51B5;&#x4E0D;&#x65AD;&#x8C03;&#x6574;&#x4F18;&#x5316;&#xFF0C;&#x4F18;&#x5316;&#x4E0D;&#x5F53;&#x5C31;&#x53EF;&#x80FD;&#x9020;&#x6210;&#x8BA1;&#x7B97;&#x673A;&#x653E;&#x7740;&#x6D3B;&#x4E09;&#x4E0D;&#x5835;&#x8DD1;&#x53BB;&#x5835;&#x6D3B;&#x4E8C;&#x4E86;&#x3002;&#x3002;&#x3002; &#x3000;&#x3000;&#x6700;&#x7EC8;&#x7684;&#x4F30;&#x503C;&#x51FD;&#x6570;int Evaluate(Point p)&#x53EA;&#x8981;&#x8C03;&#x7528;int evaluate(Point p, int me,int plyer)&#x51FD;&#x6570;&#x5C31;&#x53EF;&#x4EE5;&#x83B7;&#x5F97;p&#x70B9;&#x7684;&#x6743;&#x503C;&#x3002; &#x3000;&#x3000;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A;1234int Evaluate(Point p){ //code&#x662F;&#x8C03;&#x7528;&#x8005;&#x7684;&#x4EE3;&#x53F7; return evaluate(p,code,1)+ evaluate(p,code,2);&#x3000;&#x3000;} &#x2002;&#x2002;&#x2002;&#x2002; &#x6210;&#x679C;&#x3000;&#x3000;&#x6700;&#x7EC8;&#x7A0B;&#x5E8F;&#x6838;&#x5FC3;&#x7B97;&#x6CD5;&#x53EA;&#x8FD0;&#x7528;&#x8BE5;&#x4F30;&#x503C;&#x7B97;&#x6CD5;&#xFF0C;&#x6CA1;&#x6709;&#x8FDB;&#x884C;&#x6DF1;&#x5EA6;&#x641C;&#x7D22;&#x3002;&#x754C;&#x9762;&#x5982;&#x4E0B;&#xFF1A; &#x3000;&#x3000;&#x53EF;&#x89C1;&#x4F30;&#x503C;&#x7B97;&#x6CD5;&#x5373;&#x4FBF;&#x975E;&#x5E38;&#x5B8C;&#x7F8E;&#xFF08;&#x5F53;&#x7136;&#x8FD9;&#x4E2A;&#x7B97;&#x6CD5;&#x79BB;&#x5B8C;&#x7F8E;&#x8FD8;&#x5DEE;&#x5F97;&#x8FDC;&#xFFE3;&#x25A1;&#xFFE3;&#xFF5C;&#xFF5C;&#xFF09;&#xFF0C;&#x4F9D;&#x7136;&#x65E0;&#x6CD5;&#x505A;&#x5230;&#x7ACB;&#x4E8E;&#x4E0D;&#x8D25;&#x4E4B;&#x5730;&#xFF0C;&#x56E0;&#x4E3A;&#x5F80;&#x5F80;&#x4F1A;&#x51FA;&#x73B0;&#x5BF9;&#x65B9;&#x6709;&#x591A;&#x4E2A;&#x63A5;&#x8FD1;&#x8FDE;&#x4E94;&#xFF0C;&#x4EE5;&#x81F3;&#x4E8E;&#x5835;&#x90FD;&#x5835;&#x4E0D;&#x4F4F;&#x3002;&#x6240;&#x4EE5;&#x535A;&#x5F08;&#x8FD8;&#x662F;&#x5FC5;&#x987B;&#x8981;&#x6DF1;&#x5EA6;&#x641C;&#x7D22;&#x7684;&#x3002; &#x2002;&#x2002;&#x2002;&#x2002; &#x5B8C;&#x6574;&#x4EE3;&#x7801; &#x6700;&#x540E;&#x8D34;&#x51FA;&#x81EA;&#x5DF1;&#x5199;&#x7684;&#x4F30;&#x503C;&#x7B97;&#x6CD5;&#x5B8C;&#x6574;&#x7684;&#x4EE3;&#x7801;&#xFF08;&#x4EC5;&#x4F9B;&#x53C2;&#x8003;&#xFF0C;&#x6B63;&#x786E;&#x6027;&#x672A;&#x7ECF;&#x4E25;&#x683C;&#x9A8C;&#x8BC1;&#xFF09;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145int Evaluate(Point p){ return evaluate(p, code,1) + evaluate(p, code,2); }int evaluate(Point p, int me,int plyer) { // me:&#x6211;&#x7684;&#x4EE3;&#x53F7; plyer:&#x5F53;&#x524D;&#x8BA1;&#x7B97;&#x7684;player&#x7684;&#x4EE3;&#x53F7; int value = 0; int numoftwo=0; for (int i = 1; i &lt;= 8; i++) { // 8&#x4E2A;&#x65B9;&#x5411; // &#x6D3B;&#x56DB; 01111* *&#x4EE3;&#x8868;&#x5F53;&#x524D;&#x7A7A;&#x4F4D;&#x7F6E; 0&#x4EE3;&#x8868;&#x5176;&#x4ED6;&#x7A7A;&#x4F4D;&#x7F6E; &#x4E0B;&#x540C; if (getLine(p, i, -1) == plyer &amp;&amp; getLine(p, i, -2) == plyer &amp;&amp; getLine(p, i, -3) == plyer &amp;&amp; getLine(p, i, -4) == plyer &amp;&amp; getLine(p, i, -5) == 0) { value += 300000; if(me!=plyer){value-=500;} continue; } // &#x6B7B;&#x56DB;A 21111* if (getLine(p, i, -1) == plyer &amp;&amp; getLine(p, i, -2) == plyer &amp;&amp; getLine(p, i, -3) == plyer &amp;&amp; getLine(p, i, -4) == plyer &amp;&amp; (getLine(p, i, -5) == 3 - plyer||getLine(p, i, -5) == -1)) { value += 250000; if(me!=plyer){value-=500;} continue; } // &#x6B7B;&#x56DB;B 111*1 if (getLine(p, i, -1) == plyer &amp;&amp; getLine(p, i, -2) == plyer &amp;&amp; getLine(p, i, -3) == plyer &amp;&amp; getLine(p, i, 1) == plyer) { value += 240000; if(me!=plyer){value-=500;} continue; } // &#x6B7B;&#x56DB;C 11*11 if (getLine(p, i, -1) == plyer &amp;&amp; getLine(p, i, -2) == plyer &amp;&amp; getLine(p, i, 1) == plyer &amp;&amp; getLine(p, i, 2) == plyer) { value += 230000; if(me!=plyer){value-=500;} continue; } // &#x6D3B;&#x4E09; &#x8FD1;3&#x4F4D;&#x7F6E; 111*0 if (getLine(p, i, -1) == plyer &amp;&amp; getLine(p, i, -2) == plyer &amp;&amp; getLine(p, i, -3) == plyer) { if (getLine(p, i, 1) == 0) { value += 750; if (getLine(p, i, -4) == 0) { value += 3150; if(me!=plyer){value-=300;} } } if ((getLine(p, i, 1) == 3 - plyer||getLine(p, i, 1) == -1) &amp;&amp; getLine(p, i, -4) == 0) { value += 500; } continue; } // &#x6D3B;&#x4E09; &#x8FDC;3&#x4F4D;&#x7F6E; 1110* if (getLine(p, i, -1) == 0 &amp;&amp; getLine(p, i, -2) == plyer &amp;&amp; getLine(p, i, -3) == plyer &amp;&amp; getLine(p, i, -4) == plyer) { value += 350; continue; } // &#x6B7B;&#x4E09; 11*1 if (getLine(p, i, -1) == plyer &amp;&amp; getLine(p, i, -2) == plyer &amp;&amp; getLine(p, i, 1) == plyer) { value += 600; if (getLine(p, i, -3) == 0 &amp;&amp; getLine(p, i, 2) == 0) { value += 3150; continue; } if ((getLine(p, i, -3) == 3 - plyer||getLine(p, i, -3) == -1) &amp;&amp; (getLine(p, i, 2) == 3 - plyer||getLine(p, i, 2) == -1)) { continue; } else { value += 700; continue; } } //&#x6D3B;&#x4E8C;&#x7684;&#x4E2A;&#x6570; if (getLine(p, i, -1) == plyer &amp;&amp; getLine(p, i, -2) == plyer &amp;&amp; getLine(p, i, -3) != 3-plyer&amp;&amp;getLine(p,i,1)!=3-plyer) { numoftwo++; } //&#x5176;&#x4F59;&#x6563;&#x68CB; int numOfplyer = 0; // &#x56E0;&#x4E3A;&#x65B9;&#x5411;&#x4F1A;&#x7B97;&#x4E24;&#x6B21;&#xFF1F; for (int k = -4; k &lt;= 0; k++) { // ++++* +++*+ ++*++ +*+++ *++++ int temp = 0; for (int l = 0; l &lt;= 4; l++) { if (getLine(p, i, k + l) == plyer) { temp++; } else if (getLine(p, i, k + l) == 3 - plyer || getLine(p, i, k + l) == -1) { temp = 0; break; } } numOfplyer += temp; } value += numOfplyer * 15; if (numOfplyer != 0) { } } if(numoftwo&gt;=2){ value+=3000; if(me!=plyer){ value-=100; } } return value; }int getLine(Point p, int i, int j) { // i:&#x65B9;&#x5411; j:&#x76F8;&#x5BF9;p&#x7684;&#x987A;&#x5E8F;&#x503C;&#xFF08;&#x4EE5;p&#x4E3A;0&#xFF09; p:&#x5F53;&#x524D;&#x70B9; int x = p.x, y = p.y; switch (i) { case 1 : x = x + j; break; case 2 : x = x + j; y = y + j; break; case 3 : y = y + j; break; case 4 : x = x - j; y = y + j; break; case 5 : x = x - j; break; case 6 : x = x - j; y = y - j; break; case 7 : y = y - j; break; case 8 : x = x + j; y = y - j; } if (x &lt; 0 || y &lt; 0 || x &gt; 14 || y &gt; 14) { // &#x8D8A;&#x754C;&#x5904;&#x7406; return -1; } return box.getFlag(x,y); } 2015.9.21 10:53]]></content>
    </entry>

    
  
  
</search>
