<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[开始使用GitHub Pages]]></title>
      <url>2016%2F10%2F28%2FFirstPost%2F</url>
      <content type="text"><![CDATA[开始使用GitHub Pages，并使用Hexo。 2016.10.28 22:17]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[近期学到的]]></title>
      <url>2016%2F10%2F22%2F%E8%BF%91%E6%9C%9F%E5%AD%A6%E5%88%B0%E7%9A%84%2F</url>
      <content type="text"><![CDATA[Markdown 编辑器使用Remarkable 语法，参考Remarkable帮助里的Tutorial MathjaxMathjax语法简介 Sphinx使用docstring生成APIdoc 1$sphinx-apidoc -o /home/me/outdir -F /home/me/code 1$cd /home/me/outdir 1$gedit conf.py 12345import osimport syssys.path.insert(0, os.path.abspath('../..'))........ reStructuredTextreStructuredText语法简介]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[重定向]]></title>
      <url>2016%2F09%2F12%2F%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
      <content type="text"><![CDATA[Linux 终端:12345cat testin.txt|./test./test&gt;testout.txtcat testin.txt|./test&gt;testout.txt Windows cmd: 12345 test.exe&lt;testin.txt test.exe&gt;testout.txt test.exe&lt;testin.txt&gt;testout.txt C代码：123456789freopen("testin.txt","r",stdin);fclose(stdin); freopen("testout.txt","w",stdout);fclose(stdout);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CCF考试]]></title>
      <url>2016%2F09%2F11%2FCCF%E8%AE%B0%E5%BD%95%2F</url>
      <content type="text"><![CDATA[第八次CCF考试记录 代码还不知道对不对，过两天出成绩。 成绩出来了，310分。 100+100+100+10+0； 考试13:27开始，17:30结束，提交第4题后不再答题，只是检查前四题的代码 第一次提交：1 13:342 14:00左右3 15:324 16:565 最后一次提交：1 13:342 16:063 15:324 16:565 代码行数（不算空行，算无用的include，算注释掉的部分）1 232 503 1014 715共 245 行 源代码：11234567891011121314151617181920212223#include &lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;string&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char** argv) &#123; int n; cin&gt;&gt;n; int * a=new int[n]; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;a[i]; &#125; int m=-99999; for(int i=1;i&lt;n;i++)&#123; int t=a[i]-a[i-1]; t=t&gt;0?t:0-t; m=m&lt;t?t:m; &#125; cout&lt;&lt;m; return 0;&#125; 21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;string&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;int main(int argc, char** argv) &#123; int * a=new int[20]; for(int i=0;i&lt;20;i++)&#123; a[i]=5; &#125; int n,t; cin&gt;&gt;n; for(int i=0;i&lt;n;i++)&#123; cin&gt;&gt;t; int flag=0; for(int i=0;i&lt;20;i++)&#123; if(a[i]&gt;=t)&#123; for(int j=0;j&lt;t;j++)&#123; cout&lt;&lt;i*5+5-a[i]+j+1&lt;&lt;" "; &#125; cout&lt;&lt;endl; a[i]-=t; flag=1; break; &#125; &#125; if(flag==0)&#123; for(int i=0;i&lt;20;i++)&#123; if(a[i]-t&gt;0)&#123; for(int j=0;j&lt;t;j++)&#123; cout&lt;&lt;i*5+5-a[i]+j+1&lt;&lt;" "; &#125; a[i]-=t; break; &#125;else&#123; for(int j=0;j&lt;a[i];j++)&#123; cout&lt;&lt;i*5+5-a[i]+j+1&lt;&lt;" "; &#125; t-=a[i]; a[i]=0; &#125; &#125; cout&lt;&lt;endl; &#125; &#125; delete []a; return 0;&#125; 3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;string&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;struct suicong&#123; int hth; int att; suicong(int h,int a)&#123; hth=h; att=a; &#125;&#125;;struct ying&#123; int hth; int att; ying()&#123; hth=30; att=0; &#125;&#125;;int main(int argc, char** argv) &#123; vector&lt;suicong&gt;* war=new vector&lt;suicong&gt;[2]; //vector&lt;suicong&gt; war0; //vector&lt;suicong&gt; war1; //suicong* ying0=new suicong(30,0,1); //suicong* ying1=new suicong(30,0,1); ying ying[2]; //war[0].push_back(*ying0); //war[1].push_back(*ying1); int n; cin&gt;&gt;n; int t=0; //int y[2]; for(int i=0;i&lt;n;i++)&#123; string str; cin&gt;&gt;str; if(str=="summon")&#123; int p,h,a; cin&gt;&gt;p&gt;&gt;a&gt;&gt;h; suicong* temp=new suicong(h,a); war[t].insert(war[t].begin()+p-1,*temp); &#125; if(str=="attack")&#123; int d,a; cin&gt;&gt;a&gt;&gt;d; if(d==0)&#123; ying[1-t].hth-=war[t].at(a-1).att; war[t].at(a-1).hth-=ying[1-t].att; if(war[t].at(a-1).hth&lt;=0)&#123; war[t].erase(war[t].begin()+a-1); &#125; &#125; else&#123; //cout&lt;&lt;t&lt;&lt;" "&lt;&lt;war[t].size()&lt;&lt;" "&lt;&lt;war[1-t].size(); war[1-t].at(d-1).hth-=war[t].at(a-1).att; war[t].at(a-1).hth-=war[1-t].at(d-1).att; if(war[t].at(a-1).hth&lt;=0)&#123; war[t].erase(war[t].begin()+a-1); &#125; if(war[1-t].at(d-1).hth&lt;=0)&#123; war[1-t].erase(war[1-t].begin()+d-1); &#125; &#125; &#125; if(str=="end")&#123; t=1-t; &#125; /*cout&lt;&lt;0&lt;&lt;" "&lt;&lt;ying[0].hth&lt;&lt;" "&lt;&lt;war[0].size()&lt;&lt;" "; for(int i=0;i&lt;war[0].size();i++)&#123; cout&lt;&lt;war[0].at(i).hth&lt;&lt;" "; &#125;cout&lt;&lt;endl; cout&lt;&lt;1&lt;&lt;" "&lt;&lt;ying[1].hth&lt;&lt;" "&lt;&lt;war[1].size()&lt;&lt;" "; for(int i=0;i&lt;war[1].size();i++)&#123; cout&lt;&lt;war[1].at(i).hth&lt;&lt;" "; &#125;cout&lt;&lt;endl;*/ &#125; if(ying[0].hth&lt;=0)&#123; cout&lt;&lt;-1&lt;&lt;endl; &#125;else if(ying[1].hth&lt;=0)&#123; cout&lt;&lt;1&lt;&lt;endl; &#125;else&#123; cout&lt;&lt;0&lt;&lt;endl; &#125; cout&lt;&lt;ying[0].hth&lt;&lt;endl; cout&lt;&lt;war[0].size()&lt;&lt;" "; for(int i=0;i&lt;war[0].size();i++)&#123; cout&lt;&lt;war[0].at(i).hth&lt;&lt;" "; &#125; cout&lt;&lt;endl; cout&lt;&lt;ying[1].hth&lt;&lt;endl; cout&lt;&lt;war[1].size()&lt;&lt;" "; for(int i=0;i&lt;war[1].size();i++)&#123; cout&lt;&lt;war[1].at(i).hth&lt;&lt;" "; &#125; cout&lt;&lt;endl; return 0;&#125; 4 此代码是错误的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;string&gt;#include&lt;stack&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;struct road&#123; int to; int len; road(int t,int l)&#123; to=t;len=l; &#125;&#125;;struct city&#123; //int num; int pre=0; int tlen=999999999; vector&lt;road&gt; v; void addroad(int t,int len)&#123; road* r=new road(t,len); v.push_back(*r); &#125;&#125;;int get(city* cs,int i,int j)&#123; for(int k=0;k&lt;cs[i].v.size();k++)&#123; if(cs[i].v.at(k).to==j)return cs[i].v.at(k).len; &#125; return 0;&#125;int main(int argc, char** argv) &#123; int n,m; cin&gt;&gt;n&gt;&gt;m; city* cs=new city[n+1]; for(int i=0;i&lt;m;i++)&#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cs[a].addroad(b,c); cs[b].addroad(a,c); &#125; cs[1].tlen=0; queue&lt;int&gt; q; q.push(1); while(!q.empty())&#123; int t=q.front(); q.pop(); for(int i=0;i&lt;cs[t].v.size();i++)&#123; if(cs[cs[t].v.at(i).to].tlen&gt;cs[t].tlen+cs[t].v.at(i).len)&#123; cs[cs[t].v.at(i).to].tlen=cs[t].tlen+cs[t].v.at(i).len; cs[cs[t].v.at(i).to].pre=t; q.push(cs[t].v.at(i).to); &#125; if(cs[cs[t].v.at(i).to].tlen==cs[t].tlen+cs[t].v.at(i).len)&#123; if(get(cs,cs[cs[t].v.at(i).to].pre,cs[t].v.at(i).to)&gt;cs[t].v.at(i).len)&#123; cs[cs[t].v.at(i).to].tlen=cs[t].tlen+cs[t].v.at(i).len; cs[cs[t].v.at(i).to].pre=t; q.push(cs[t].v.at(i).to); &#125; &#125; &#125; &#125;/* for(int i=0;i&lt;n+1;i++)&#123; cout&lt;&lt;i&lt;&lt;" "&lt;&lt;cs[i].pre&lt;&lt;" "&lt;&lt;get(cs,i,cs[i].pre)&lt;&lt;endl; &#125;*/ int ll=0; for(int i=0;i&lt;n+1;i++)&#123; ll+=get(cs,i,cs[i].pre); &#125; cout&lt;&lt;ll; return 0;&#125; 2016.9.11 晚8:40]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[简单的词法分析和语法分析（C++实现，CodeBlocks+GCC编译）]]></title>
      <url>2016%2F07%2F13%2F%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[说明： 分析的语言是SNL语言，详见《编译程序的设计与实现》（ 刘磊、金英、张晶、张荷花、单郸编著） 词法分析就是实现了词法分析的自动机 语法分析使用递归下降法 运行结果： 词法分析 得到TokenList 语法分析 输出语法树 运行输出： 代码：main.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;vector&gt;#include&lt;string.h&gt;using namespace std;#define NUMOFRESERVED 22#define NUMOFSYMBOLS 20#define RES 0#define ID 1#define NUM 2#define SYM 3#define STR 4#define PLUS 100#define SUB 101#define MUL 102#define DIV 103#define LT 104#define LBRACK 105#define RBRACK 106#define LSQUBRACK 107#define RSQUBRACK 108#define POINT 109#define SEMI 110#define LBRACE 111#define RBRACE 112#define EOFF 113#define BLANK 114#define QUO 115#define EQU 116#define INDEX 117#define ASSI 118#define COM 119#define uint unsignedtypedef struct Token &#123; int id; int ptr; int linenum;&#125; Token;typedef struct Node &#123; char *desc; vector&lt;Node*&gt; children; Node(const char* str) &#123; desc=new char[30]; strcpy(desc,str); &#125;&#125; Node;vector&lt;Token&gt;* tokens;int Token_n=0;const char* reserved_words[NUMOFRESERVED]= &#123;"begin","end","program","var", "type","procedure","while","endwh", "integer","char","array","of", "intc","record","if","then", "else","fi","do","write", "read","return" &#125;;static const char* symbol_table[NUMOFSYMBOLS]= &#123;"+","-","*","/","&lt;", "(",")","[","]",".", ";","&#123;","&#125;","EOF","BLANK", "\'","=","..",":=","," &#125;;void syntaxError(const char* message);Node* MatchRES(const char* expected);Node* MatchSYM(const int expected);Node* MatchID();Node* MatchNUM();bool isRES(const char* res);bool isSYM(const int res);bool isID();bool isNUM();bool isLineEnd();Node* Program();Node* ProgramHead();Node* DeclarePart();Node* TypeDec();Node* TypeDeclaration();Node* TypeDecList();Node* TypeDecMore();Node* TypeId();Node* TypeName();Node* BaseType();Node* StructureType();Node* ArrayType();Node* RecType();Node* FieldDecList();Node* FieldDecMore();Node* IdList();Node* IdMore();Node* VarDec();Node* VarDeclaration();Node* VarDecList();Node* VarDecMore();Node* VarIdList();Node* VarIdMore();Node* ProcDec();Node* ProcDeclaration();Node* ParamList();Node* ParamDecList();Node* ParamMore();Node* Param();Node* FormList();Node* FidMore();Node* ProcDecPart();Node* ProcBody();Node* ProgramBody();Node* StmList();Node* StmMore();Node* Stm();Node* AssCall();Node* AssignmentRest();Node* ConditionalStm();Node* LoopStm();Node* InputStm();Node* OutputStm();Node* ReturnStm();Node* CallStmRest();Node* ActParamList();Node* ActParamMore();Node* Exp();Node* Term();Node* OtherFactor();Node* OtherTerm();Node* Factor();Node* Variable();Node* VariMore();Node* FieldVar();Node* FieldVarMore();Node* Parse();Node* CmpOp();Node* AddOp();Node* MultOp();void show_tree(Node* root,int depth,vector&lt;int&gt;* v,bool islast);int add(vector&lt;Node* &gt;&amp; children,Node* node) &#123; if(node!=NULL) &#123; children.push_back(node); &#125; return 0;&#125;#define COMMENT_ERROR -1000#define STR_ERROR -1001#define SYM_ERROR -1002#define NOT_REC_SYMBOL -1003vector&lt;char*&gt; ID_table;vector&lt;uint&gt; NUM_table;vector&lt;char*&gt; STR_table;int ID_n=0,NUM_n=0,STR_n=0;int num_of_lines=1;FILE * file;/***************************************************************************************//***************** 词法分析 *****************//***************************************************************************************/void handle_error(int error_num,const char* str) &#123; printf("行号:%d \t",num_of_lines); switch(error_num) &#123; case COMMENT_ERROR: printf("注释未结束 \t"); break; case SYM_ERROR: printf("出现未定义的符号，您想输入的是\":=\"吗? \t"); break; case STR_ERROR: printf("字符串未结束 \t"); break; case NOT_REC_SYMBOL: printf("出现未定义的符号 \t"); break; &#125; printf("%s\n",str); exit(-1);&#125;char getNextChar() &#123; char c; c=fgetc(file); return c;&#125;void ungetNextChar() &#123; fseek(file,-1,SEEK_CUR);&#125;int reservedLookup(char* str) &#123; for(int i=0; i&lt;NUMOFRESERVED; i++) &#123; if(strcmp(str,reserved_words[i])==0)return i; &#125; return -1;&#125;int str_to_num(char* str) &#123; int len=strlen(str); int n=0; for(int i=0; i&lt;len; i++) &#123; n=n*10+str[i]-'0'; &#125; return n;&#125;int addIDTable(char* str) &#123; ID_table.push_back(str); return ID_n++;&#125;int addNUMTable(int num) &#123; NUM_table.push_back(num); return NUM_n++;&#125;int addSTRTable(char* str ) &#123; STR_table.push_back(str); return STR_n++;&#125;Token scan() &#123; static const char symbols[12]= &#123;'+','-','*','/','&lt;','(',')','[',']',';','=',','&#125;; static const int symbols_n[12]= &#123;PLUS,SUB,MUL,DIV,LT,LBRACK,RBRACK,LSQUBRACK,RSQUBRACK,SEMI,EQU,COM&#125;; Token t; t.linenum=num_of_lines; char* str=new char[256]; strcpy(str,"");//字符串要初始化，不然有乱码 char c[2]= &#123;'a','\0'&#125;; c[0]=getNextChar();LS0: if(c[0]&gt;='a'&amp;&amp;c[0]&lt;='z')goto LS1; if(c[0]&gt;='A'&amp;&amp;c[0]&lt;='Z')goto LS1; if(c[0]&gt;='0'&amp;&amp;c[0]&lt;='9')goto LS2; int indexofsym; for(indexofsym=0; indexofsym&lt;12; indexofsym++) &#123; if(c[0]==symbols[indexofsym]) &#123; goto LS3; &#125; &#125; if(c[0]=='.')goto LS4; if(c[0]=='&#123;')goto LS5; if(c[0]==':')goto LS6; if(c[0]=='\'')goto LS7; if(c[0]=='\n')goto LS8; if(c[0]==EOF)goto LS9; if(c[0]=='\t'||c[0]==' ')goto LS10; goto OTHER;LS1: strcat(str,c); c[0]=getNextChar(); if(c[0]&gt;='a'&amp;&amp;c[0]&lt;='z')goto LS1; else if(c[0]&gt;='A'&amp;&amp;c[0]&lt;='Z')goto LS1; else if(c[0]&gt;='0'&amp;&amp;c[0]&lt;='9')goto LS1; ungetNextChar(); int nres; if(nres=reservedLookup(str),nres!=-1) &#123; t.id=RES; t.ptr=nres; return t; &#125; else &#123; t.id=ID; t.ptr=addIDTable(str); return t; &#125;LS2: strcat(str,c); c[0]=getNextChar(); if(c[0]&gt;='0'&amp;&amp;c[0]&lt;='9')goto LS2; ungetNextChar(); t.id=NUM; t.ptr=addNUMTable(str_to_num(str)); return t;LS3: t.ptr=symbols_n[indexofsym]; t.id=SYM; return t;LS4: strcat(str,c); c[0]=getNextChar(); if(c[0]=='.') &#123; t.id=SYM; t.ptr=INDEX; return t; &#125; else &#123; t.id=SYM; t.ptr=POINT; ungetNextChar(); return t; &#125;LS5: while(c[0]=getNextChar(),c[0]!=EOF&amp;&amp;c[0]!='&#125;') &#123; if(c[0]=='\n'||c[0]=='\r')num_of_lines++; &#125; if(c[0]=='&#125;') &#123; c[0]=getNextChar(); goto LS0; &#125; else &#123; handle_error(COMMENT_ERROR,""); &#125;LS6: strcat(str,c); c[0]=getNextChar(); if(c[0]=='=') &#123; t.id=SYM; t.ptr=ASSI; return t; &#125; else &#123; handle_error(SYM_ERROR,"符号为 \':\'"); &#125;LS7: while(c[0]=getNextChar(),c[0]!=EOF&amp;&amp;c[0]!='\'') &#123; strcat(str,c); &#125; if(c[0]=='\'') &#123; t.id=STR; t.ptr=addSTRTable(str); return t; &#125; else &#123; handle_error(STR_ERROR,""); &#125;LS8: t.id=-1; num_of_lines++; return t;LS9: t.id=SYM; t.ptr=EOFF; return t;LS10: t.id=-1; return t;OTHER: handle_error(NOT_REC_SYMBOL,c); t.id=-1; return t;&#125;void show_token(Token t) &#123; if(t.id==STR) &#123; printf("&lt;%d %s %s&gt; \n",t.linenum,"STR",STR_table[t.ptr]); return ; &#125; if(t.id==NUM) &#123; printf("&lt;%d %s %d&gt; \n",t.linenum,"NUM",NUM_table[t.ptr]); return ; &#125; if(t.id==ID) &#123; printf("&lt;%d %s %s&gt; \n",t.linenum,"ID",ID_table[t.ptr]); return ; &#125; if(t.id==RES) &#123; printf("&lt;%d %s %s&gt; \n",t.linenum,"RES",reserved_words[t.ptr]); return ; &#125; if(t.id==SYM) &#123; printf("&lt;%d %s %s&gt; \n",t.linenum,"SYM",symbol_table[t.ptr-100]); return ; &#125; return ;&#125;vector&lt;Token&gt;* getTokenlist(const char* filename) &#123; tokens-&gt;clear(); file=fopen(filename,"r"); Token temp; while(temp=scan(),!(temp.id==SYM&amp;&amp;temp.ptr==EOFF)) &#123; if(temp.id!=-1) &#123; tokens-&gt;push_back(temp); if(temp.id==RES&amp;&amp;strcmp("end",reserved_words[temp.ptr])==0) &#123; char c; if(c=getNextChar(),c=='.') &#123; break; &#125; else &#123; ungetNextChar(); &#125; &#125; &#125; &#125; fclose(file); return tokens;&#125;void show_Token_list() &#123; int len=tokens-&gt;size(); for(int i=0; i&lt;len; i++) &#123; show_token(tokens-&gt;at(i)); &#125;&#125;void write_token(FILE* file,Token t) &#123; if(t.id==STR) &#123; fprintf(file,"&lt;%s %s&gt; \n","STR",STR_table[t.ptr]); return ; &#125; if(t.id==NUM) &#123; fprintf(file,"&lt;%s %d&gt; \n","NUM",NUM_table[t.ptr]); return ; &#125; if(t.id==ID) &#123; fprintf(file,"&lt;%s %s&gt; \n","ID",ID_table[t.ptr]); return ; &#125; if(t.id==RES) &#123; fprintf(file,"&lt;%s %s&gt; \n","RES",reserved_words[t.ptr]); return ; &#125; if(t.id==SYM) &#123; fprintf(file,"&lt;%s %s&gt; \n","SYM",symbol_table[t.ptr-100]); return ; &#125; return ;&#125;void save_Token_list(const char* filename) &#123; FILE* f=fopen(filename,"w"); int len=tokens-&gt;size(); for(int i=0; i&lt;len; i++) &#123; write_token(f,tokens-&gt;at(i)); &#125; fclose(f);&#125;/***************************************************************************************//***************** 语法分析 *****************//***************************************************************************************/void syntaxError(const char* message) &#123; if(strcmp(message,"outofrange")==0) &#123; printf("出现越界错误"); printf(" Token_n:%d tokens-&gt;size:%d\n",Token_n,tokens-&gt;size()); exit(-1); &#125; printf("行号：%d %s",tokens-&gt;at(Token_n).linenum,message); printf("当前token："); show_token(tokens-&gt;at(Token_n)); exit(-1);&#125;Node* MatchRES(const char* expected) &#123; if(Token_n&gt;=(int)tokens-&gt;size())syntaxError("outofrange"); int id=tokens-&gt;at(Token_n).id,ptr=tokens-&gt;at(Token_n).ptr; if(id==RES&amp;&amp;strcmp(expected,reserved_words[ptr])==0) &#123; Node*t =new Node(expected); Token_n++; return t; &#125; char* message=new char[100]; strcpy(message,"match res error.\nexpect: "); strcat(message,expected); strcat(message,"\n"); syntaxError(message); delete message; return NULL;&#125;Node* MatchNUM() &#123; if(Token_n&gt;=(int)tokens-&gt;size())syntaxError("outofrange"); int id=tokens-&gt;at(Token_n).id; if(id==NUM) &#123; Node* t= new Node("NUM"); Token_n++; return t; &#125; syntaxError("match num error\n"); return NULL;&#125;Node* MatchSTR() &#123; if(Token_n&gt;=(int)tokens-&gt;size())syntaxError("outofrange"); int id=tokens-&gt;at(Token_n).id; if(id==STR) &#123; Node* t= new Node("STR"); Token_n++; return t; &#125; syntaxError("match str error\n"); return NULL;&#125;Node* MatchID() &#123; if(Token_n&gt;=(int)tokens-&gt;size())syntaxError("outofrange"); int id=tokens-&gt;at(Token_n).id; if(id==ID) &#123; Node* t =new Node("ID"); Token_n++; return t; &#125; syntaxError("match id error\n"); return NULL;&#125;Node* MatchSYM(const int expected) &#123; if(Token_n&gt;=(int)tokens-&gt;size())syntaxError("outofrange"); int id=tokens-&gt;at(Token_n).id,ptr=tokens-&gt;at(Token_n).ptr; if(id==SYM&amp;&amp;ptr==expected) &#123; Node* t =new Node(symbol_table[ptr-100]); Token_n++; return t; &#125; char* message=new char[100]; strcpy(message,"match symbol error.\nexpect: "); strcat(message,symbol_table[expected-100]); strcat(message,"\n"); syntaxError(message); delete message; return NULL;&#125;bool isRES(const char* res) &#123; if(Token_n&gt;=(int)tokens-&gt;size())syntaxError("outofrange"); int id=tokens-&gt;at(Token_n).id,ptr=tokens-&gt;at(Token_n).ptr; if(id==RES&amp;&amp;strcmp(reserved_words[ptr],res)==0)return true; return false;&#125;bool isSYM(const int res) &#123; if(Token_n&gt;=(int)tokens-&gt;size())syntaxError("outofrange"); int id=tokens-&gt;at(Token_n).id,ptr=tokens-&gt;at(Token_n).ptr; if(id==SYM&amp;&amp;ptr==res)return true; return false;&#125;bool isID() &#123; if(Token_n&gt;=(int)tokens-&gt;size())syntaxError("outofrange"); int id=tokens-&gt;at(Token_n).id; if(id==ID)return true; return false;&#125;bool isNUM() &#123; if(Token_n&gt;=(int)tokens-&gt;size())syntaxError("outofrange"); int id=tokens-&gt;at(Token_n).id; if(id==NUM)return true; return false;&#125;bool isSTR() &#123; if(Token_n&gt;=(int)tokens-&gt;size())syntaxError("outofrange"); int id=tokens-&gt;at(Token_n).id; if(id==STR)return true; return false;&#125;Node* Program() &#123; Node* t=new Node("Program"); add(t-&gt;children,ProgramHead()); add(t-&gt;children,DeclarePart()); add(t-&gt;children,ProgramBody()); return t;&#125;Node* ProgramHead() &#123; Node* t=new Node("ProgramHead"); add(t-&gt;children,MatchRES("program")); add(t-&gt;children,MatchID()); return t;&#125;Node* DeclarePart() &#123; Node* t=new Node("DeclarePart"); add(t-&gt;children,TypeDeclaration()); add(t-&gt;children,VarDeclaration()); add(t-&gt;children,ProcDeclaration()); return t;&#125;Node* TypeDec() &#123; Node* t=new Node("TypeDec"); add(t-&gt;children,MatchRES("type")); add(t-&gt;children,TypeDecList()); return t;&#125;Node* TypeDeclaration() &#123; Node*t=NULL; if(isRES("type")) &#123; t=new Node("TypeDeclaration"); add(t-&gt;children,TypeDec()); &#125; return t;&#125;Node* TypeDecList() &#123; Node* t=new Node("TypeDecList"); add(t-&gt;children,TypeId()); add(t-&gt;children,MatchSYM(EQU)); add(t-&gt;children,TypeName()); add(t-&gt;children,MatchSYM(SEMI)); add(t-&gt;children,TypeDecMore()); return t;&#125;Node* TypeDecMore() &#123; Node*t=NULL; if(isID()) &#123; t=new Node("TypeDecMore"); add(t-&gt;children,TypeDecList()); &#125; return t;&#125;Node* TypeId() &#123; Node* t=new Node("TypeId"); add(t-&gt;children,MatchID()); return t;&#125;Node* TypeName() &#123; Node* t=new Node("TypeName"); if(isRES("integer")||isRES("char")) &#123; add(t-&gt;children,BaseType()); return t; &#125; if(isRES("array")||isRES("record")) &#123; add(t-&gt;children,StructureType()); return t; &#125; add(t-&gt;children,MatchID()); return t;&#125;Node* BaseType() &#123; Node*t=NULL; if(isRES("integer")) &#123; t=new Node("BaseType"); add(t-&gt;children,MatchRES("integer")); return t; &#125; if(isRES("char")) &#123; t=new Node("BaseType"); add(t-&gt;children,MatchRES("char")); return t; &#125; syntaxError("not a base type\n"); return t;&#125;Node* StructureType() &#123; Node*t=NULL; if(isRES("array")) &#123; t=new Node("StructureType"); add(t-&gt;children,ArrayType()); return t; &#125; if(isRES("record")) &#123; t=new Node("StructureType"); add(t-&gt;children,RecType()); return t; &#125; return t;&#125;Node* ArrayType() &#123; Node* t=new Node("ArrayType"); add(t-&gt;children,MatchRES("array")); add(t-&gt;children,MatchSYM(LSQUBRACK)); add(t-&gt;children,MatchNUM()); add(t-&gt;children,MatchSYM(INDEX)); add(t-&gt;children,MatchNUM()); add(t-&gt;children,MatchSYM(RSQUBRACK)); add(t-&gt;children,MatchRES("of")); add(t-&gt;children,BaseType()); return t;&#125;Node* RecType() &#123; Node* t=new Node("RecType"); add(t-&gt;children,MatchRES("record")); add(t-&gt;children,FieldDecList()); add(t-&gt;children,MatchRES("end")); return t;&#125;Node* FieldDecList() &#123; Node*t=NULL; if(isRES("integer")||isRES("char")) &#123; t=new Node("FieldDecList"); add(t-&gt;children,BaseType()); add(t-&gt;children,IdList()); add(t-&gt;children,MatchSYM(SEMI)); add(t-&gt;children,FieldDecMore()); return t; &#125; if(isRES("array")) &#123; t=new Node("FieldDecList"); add(t-&gt;children,ArrayType()); add(t-&gt;children,IdList()); add(t-&gt;children,MatchSYM(SEMI)); add(t-&gt;children,FieldDecMore()); return t; &#125; syntaxError("field declare list error\n"); return t;&#125;Node* FieldDecMore() &#123; Node*t=NULL; if(isRES("integer")||isRES("char")||isRES("array")) &#123; t=new Node("FieldDecMore"); add(t-&gt;children,FieldDecList()); &#125; return t;&#125;Node* IdList() &#123; Node* t=new Node("IdList"); add(t-&gt;children,MatchID()); add(t-&gt;children,IdMore()); return t;&#125;Node* IdMore() &#123; Node*t=NULL; if(isSYM(COM)) &#123; t=new Node("IdMore"); add(t-&gt;children,MatchSYM(COM)); add(t-&gt;children,IdList()); &#125; return t;&#125;Node* VarDec() &#123; Node* t=new Node("VarDec"); add(t-&gt;children,MatchRES("var")); add(t-&gt;children,VarDecList()); return t;&#125;Node* VarDeclaration() &#123; Node*t=NULL; if(isRES("var")) &#123; t=new Node("VarDeclaration"); add(t-&gt;children,VarDec()); &#125; return t;&#125;Node* VarDecList() &#123; Node* t=new Node("VarDecList"); add(t-&gt;children,TypeName()); add(t-&gt;children,VarIdList()); add(t-&gt;children,MatchSYM(SEMI)); add(t-&gt;children,VarDecMore()); return t;&#125;Node* VarDecMore() &#123; Node*t=NULL; if(isRES("integer")||isRES("char")||isRES("array")||isRES("record")||isID()) &#123; t=new Node("VarDecMore"); add(t-&gt;children,VarDecList()); &#125; return t;&#125;Node* VarIdList() &#123; Node* t=new Node("VarIdList"); add(t-&gt;children,MatchID()); add(t-&gt;children,VarIdMore()); return t;&#125;Node* VarIdMore() &#123; Node*t=NULL; if(isSYM(COM)) &#123; t=new Node("VarIdMore"); add(t-&gt;children,MatchSYM(COM)); add(t-&gt;children,VarIdList()); &#125; return t;&#125;Node* ProcDec() &#123; Node* t=new Node("ProcDec"); add(t-&gt;children,MatchRES("procedure")); add(t-&gt;children,MatchID()); add(t-&gt;children,MatchSYM(LBRACK)); add(t-&gt;children,ParamList()); add(t-&gt;children,MatchSYM(RBRACK)); add(t-&gt;children,MatchSYM(SEMI)); add(t-&gt;children,DeclarePart()); add(t-&gt;children,ProcBody()); add(t-&gt;children,ProcDeclaration()); return t;&#125;Node* ProcDeclaration() &#123; Node*t=NULL; if(isRES("procedure")) &#123; t=new Node("ProcDeclaration"); add(t-&gt;children,ProcDec()); &#125; return t;&#125;Node* ParamList() &#123; Node*t=NULL; if(isRES("integer")||isRES("char")||isRES("array")||isRES("record")||isID()||isRES("var")) &#123; t=new Node("ParamList"); add(t-&gt;children,ParamDecList()); &#125; return t;&#125;Node* ParamDecList() &#123; Node* t=new Node("ParamDecList"); add(t-&gt;children,Param()); add(t-&gt;children,ParamMore()); return t;&#125;Node* ParamMore() &#123; Node*t=NULL; if(isSYM(SEMI)) &#123; t=new Node("ParamMore"); add(t-&gt;children,MatchSYM(SEMI)); add(t-&gt;children,ParamDecList()); &#125; return t;&#125;Node* Param() &#123; Node*t=NULL; if(isRES("integer")||isRES("char")||isRES("array")||isRES("record")||isID()) &#123; t=new Node("Param"); add(t-&gt;children,TypeName()); add(t-&gt;children,FormList()); return t; &#125; if(isRES("var")) &#123; t=new Node("Param"); add(t-&gt;children,MatchRES("var")); add(t-&gt;children,TypeName()); add(t-&gt;children,FormList()); return t; &#125; syntaxError("param error\n"); return t;&#125;Node* FormList() &#123; Node* t=new Node("FormList"); add(t-&gt;children,MatchID()); add(t-&gt;children,FidMore()); return t;&#125;Node* FidMore() &#123; Node*t=NULL; if(isSYM(COM)) &#123; t=new Node("FidMore"); add(t-&gt;children,MatchSYM(COM)); add(t-&gt;children,FormList()); &#125; return t;&#125;Node* ProcDecPart() &#123; Node* t=new Node("ProcDecPart"); add(t-&gt;children,DeclarePart()); return t;&#125;Node* ProcBody() &#123; Node* t=new Node("ProcBody"); add(t-&gt;children,ProgramBody()); return t;&#125;Node* ProgramBody() &#123; Node* t=new Node("ProgramBody"); add(t-&gt;children,MatchRES("begin")); add(t-&gt;children,StmList()); add(t-&gt;children,MatchRES("end")); return t;&#125;Node* StmList() &#123; Node* t=new Node("StmList"); add(t-&gt;children,Stm()); add(t-&gt;children,StmMore()); return t;&#125;Node* StmMore() &#123; Node*t=NULL; if(isSYM(SEMI)) &#123; t=new Node("StmMore"); add(t-&gt;children,MatchSYM(SEMI)); add(t-&gt;children,StmList()); &#125; return t;&#125;Node* Stm() &#123; Node* t=new Node("Stm"); if(isRES("if")) &#123; add(t-&gt;children,ConditionalStm()); return t; &#125; if(isRES("while")) &#123; add(t-&gt;children,LoopStm()); return t; &#125; if(isRES("read")) &#123; add(t-&gt;children,InputStm()); return t; &#125; if(isRES("write")) &#123; add(t-&gt;children,OutputStm()); return t; &#125; if(isRES("return")) &#123; add(t-&gt;children,ReturnStm()); return t; &#125; if(isID()) &#123; add(t-&gt;children,MatchID()); add(t-&gt;children,AssCall()); return t; &#125; delete t; return NULL;&#125;Node* AssCall() &#123; Node*t=NULL; if(isSYM(LSQUBRACK)||isSYM(POINT)||isSYM(ASSI)) &#123; t=new Node("AssCall"); add(t-&gt;children,AssignmentRest()); return t; &#125; if(isSYM(LBRACK)) &#123; t=new Node("AssCall"); add(t-&gt;children,CallStmRest()); return t; &#125; syntaxError("ass call error\n"); return t;&#125;Node* AssignmentRest() &#123; Node* t=new Node("AssignmentRest"); if(isSYM(LSQUBRACK)||isSYM(POINT)) &#123; add(t-&gt;children,VariMore()); &#125; add(t-&gt;children,MatchSYM(ASSI)); add(t-&gt;children,Exp()); return t;&#125;Node* ConditionalStm() &#123; Node* t=new Node("ConditionalStm"); add(t-&gt;children,MatchRES("if")); add(t-&gt;children,Exp()); if(isSYM(LT))add(t-&gt;children,MatchSYM(LT)); else if(isSYM(EQU))add(t-&gt;children,MatchSYM(EQU)); else syntaxError("condition error\n"); add(t-&gt;children,Exp()); add(t-&gt;children,MatchRES("then")); add(t-&gt;children,StmList()); add(t-&gt;children,MatchRES("else")); add(t-&gt;children,StmList()); add(t-&gt;children,MatchRES("fi")); return t;&#125;Node* LoopStm() &#123; Node* t=new Node("LoopStm"); add(t-&gt;children,MatchRES("while")); add(t-&gt;children,Exp()); if(isSYM(LT))add(t-&gt;children,MatchSYM(LT)); else if(isSYM(EQU))add(t-&gt;children,MatchSYM(EQU)); else syntaxError("condition error\n"); add(t-&gt;children,Exp()); add(t-&gt;children,MatchRES("do")); add(t-&gt;children,StmList()); add(t-&gt;children,MatchRES("endwh")); return t;&#125;Node* InputStm() &#123; Node* t=new Node("InputStm"); add(t-&gt;children,MatchRES("read")); add(t-&gt;children,MatchSYM(LBRACK)); add(t-&gt;children,MatchID()); add(t-&gt;children,MatchSYM(RBRACK)); return t;&#125;Node* OutputStm() &#123; Node* t=new Node("OutputStm"); add(t-&gt;children,MatchRES("write")); add(t-&gt;children,MatchSYM(LBRACK)); add(t-&gt;children,Exp()); add(t-&gt;children,MatchSYM(RBRACK)); return t;&#125;Node* ReturnStm() &#123; Node* t=new Node("ReturnStm"); add(t-&gt;children,MatchRES("return")); return t;&#125;Node* CallStmRest() &#123; Node* t=new Node("CallStmRest"); add(t-&gt;children,MatchSYM(LBRACK)); add(t-&gt;children,ActParamList()); add(t-&gt;children,MatchSYM(RBRACK)); return t;&#125;Node* ActParamList() &#123; Node*t=NULL; if(isSYM(LBRACK)||isNUM()||isID()) &#123; t=new Node("ActParamList"); add(t-&gt;children,Exp()); add(t-&gt;children,ActParamMore()); &#125; return t;&#125;Node* ActParamMore() &#123; Node*t=NULL; if(isSYM(COM)) &#123; t=new Node("ActParamMore"); add(t-&gt;children,MatchSYM(COM)); add(t-&gt;children,ActParamList()); &#125; return t;&#125;Node* Exp() &#123; Node* t=new Node("Exp"); add(t-&gt;children,Term()); add(t-&gt;children,OtherTerm()); return t;&#125;Node* OtherTerm() &#123; Node*t=NULL; if(isSYM(PLUS)||isSYM(SUB)) &#123; t=new Node("OtherTerm"); add(t-&gt;children,AddOp()); add(t-&gt;children,Exp()); &#125; return t;&#125;Node* Term() &#123; Node* t=new Node("Term"); add(t-&gt;children,Factor()); add(t-&gt;children,OtherFactor()); return t;&#125;Node* OtherFactor() &#123; Node*t=NULL; if(isSYM(MUL)||isSYM(DIV)) &#123; t=new Node("OtherFactor"); add(t-&gt;children,MultOp()); add(t-&gt;children,Term()); &#125; return t;&#125;Node* Factor() &#123; Node* t=new Node("Factor"); if(isNUM()) &#123; add(t-&gt;children,MatchNUM()); return t; &#125; if(isSTR()) &#123; add(t-&gt;children,MatchSTR()); return t; &#125; if(isSYM(LBRACK)) &#123; add(t-&gt;children,MatchSYM(LBRACK)); add(t-&gt;children,Exp()); add(t-&gt;children,MatchSYM(RBRACK)); return t; &#125; if(isID()) &#123; add(t-&gt;children,Variable()); return t; &#125; delete t; syntaxError("factor error\n"); return NULL;&#125;Node* Variable() &#123; Node* t=new Node("Variable"); add(t-&gt;children,MatchID()); add(t-&gt;children,VariMore()); return t;&#125;Node* VariMore() &#123; Node*t=NULL; if(isSYM(LSQUBRACK)) &#123; t=new Node("VariMore"); add(t-&gt;children,MatchSYM(LSQUBRACK)); add(t-&gt;children,Exp()); add(t-&gt;children,MatchSYM(RSQUBRACK)); &#125; if(isSYM(POINT)) &#123; t=new Node("VariMore"); add(t-&gt;children,MatchSYM(POINT)); add(t-&gt;children,FieldVar()); &#125; return t;&#125;Node* FieldVar() &#123; Node* t=new Node("FieldVar"); add(t-&gt;children,MatchID()); add(t-&gt;children,FieldVarMore()); return t;&#125;Node* FieldVarMore() &#123; Node*t=NULL; if(isSYM(LSQUBRACK)) &#123; t=new Node("FieldVarMore"); add(t-&gt;children,MatchSYM(LSQUBRACK)); add(t-&gt;children,Exp()); add(t-&gt;children,MatchSYM(RSQUBRACK)); &#125; return t;&#125;Node* CmpOp() &#123; Node*t=NULL; if(isSYM(LT)) &#123; t=new Node("CmpOp"); add(t-&gt;children,MatchSYM(LT)); return t; &#125; if(isSYM(EQU)) &#123; t=new Node("CmpOp"); add(t-&gt;children,MatchSYM(EQU)); return t; &#125; syntaxError("cmpop error\n"); return t;&#125;Node* AddOp() &#123; Node*t=NULL; if(isSYM(PLUS)) &#123; t=new Node("AddOp"); add(t-&gt;children,MatchSYM(PLUS)); return t; &#125; if(isSYM(SUB)) &#123; t=new Node("AddOp"); add(t-&gt;children,MatchSYM(SUB)); return t; &#125; syntaxError("cmpop error\n"); return t;&#125;Node* MultOp() &#123; Node*t=NULL; if(isSYM(MUL)) &#123; t=new Node("MultOp"); add(t-&gt;children,MatchSYM(MUL)); return t; &#125; if(isSYM(DIV)) &#123; t=new Node("MultOp"); add(t-&gt;children,MatchSYM(DIV)); return t; &#125; syntaxError("cmpop error\n"); return t;&#125;Node* Parse() &#123; num_of_lines=1; Node* root=Program(); return root;&#125;void show_tree(Node* root,int depth,vector&lt;int&gt;* v,bool islast) &#123; if(root==NULL)return ; printf("\n"); for(int i=0; i&lt;depth; i++) &#123; if(v-&gt;at(i)==1)printf(" │"); else printf(" "); &#125; if(islast) &#123; printf(" └─%s",root-&gt;desc); v-&gt;at(depth)=0; &#125; else printf(" ├─%s",root-&gt;desc); if(depth+1==(int)v-&gt;size())v-&gt;push_back(1); v-&gt;at(depth+1)=1; int len=root-&gt;children.size(); for(int i=0; i&lt;len; i++) &#123; if(i==len-1)show_tree(root-&gt;children.at(i),depth+1,v,true); else show_tree(root-&gt;children.at(i),depth+1,v,false); &#125;&#125;int main() &#123; tokens=new vector&lt;Token&gt;(); getTokenlist("cs1.txt"); save_Token_list("tokens.txt"); //打印显示 printf("TOKENS:\n\n"); show_Token_list(); printf("\n\n\n\n语法树:\n\n"); vector&lt;int&gt;* v=new vector&lt;int&gt;(); v-&gt;push_back(0); show_tree(Parse(),0,v,true); return 0;&#125; cs1.txt123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123;冒泡排序&#125;&#123;输入m,表示要排序的数的个数；接着输入m个整数； 输出从小到大排序后的结果&#125;program pvar integer i,j,num; array[1..20] of integer a;procedure q(integer num);var integer i,j,k; integer t;begin i:='lklklk'; j:=1; while i &lt; num do j:=num-i+1; k:=1; while k&lt;j do if a[k+1] &lt; a[k] then t:=a[k]; a[k]:=a[k+1]; a[k+1]:=t else t:=0 fi; k:=k+1 endwh; i:=i+1 endwhendbegin read(num); i:=1; while i&lt;(num+1) do read(j); a[i]:=j; i:=i+1 endwh; q(num); i:=1; while i&lt;(num+1) do write(a[i]); i:=i+1 endwhend. 代码写于大三下6月份，编译原理课程设计 随笔写于2016.7.13]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[聊天室（Java实现）]]></title>
      <url>2016%2F07%2F03%2FChatRoom%2F</url>
      <content type="text"><![CDATA[&ensp;&ensp;&ensp; 功能：登录 若用户账号不存在，弹出错误 若用户密码错误，弹出错误 若用户账号已在线，弹出错误 注册 若用户已注册，弹出错误 聊天室 多人聊天，类似QQ里的群。 点击右侧的在线用户，可进行一对一聊天。 一对一聊天 在聊天室中点击在线用户可进入此窗口。 发送消息后，对方会收到消息，并弹出一对一聊天窗口 。 &ensp;&ensp;&ensp;&ensp; 说明： 服务端的IP和端口固定。（代码中使用127.0.0.1作为服务端的IP） 客户端通过该IP和端口访问服务器。 客户端向服务器发送消息，服务器根据消息做出不同的处理，并可能向其他客户端发送消息。 每个客户端都有一个客户端server进程，以接收服务端发来的消息。 初始化客户端时，启动客户端server进程，监听任意一个可用端口。用户登录时，将本地账户、密码、本地的server进程端口发给服务端，服务端检验用户合法性，若合 法，则更新该账户的IP地址和端口。以后服务端即可向该IP发送消息。 &ensp;&ensp;&ensp;&ensp; 代码： 项目工程结构： Server1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package chatroomutil;import java.io.BufferedReader;import java.io.IOException;import java.io.PrintWriter;import java.net.ServerSocket;import java.net.Socket;public abstract class Server &#123; protected ServerSocket sSocket; public Server() &#123; &#125; protected int listen() &#123; while (true) &#123; Socket ots = null; try &#123; ots = sSocket.accept(); &#125; catch (IOException e) &#123; ChatRoomUtil.showErrorBox("服务器Accept错误"); System.exit(-1); &#125; Thread hThread = new Thread(new handleThread(ots)); hThread.start(); &#125; &#125; // 处理消息的进程 的内部类 class handleThread implements Runnable &#123; Socket ots; handleThread(Socket ots) &#123; this.ots = ots; &#125; @Override public void run() &#123; handleMessage(ots); &#125; &#125;; protected abstract String handle(Socket ots,String rMessage);//处理函数，输入收到的消息，返回要发送的消息 private String handleMessage(Socket ots) &#123; StringBuffer buffer=new StringBuffer(); BufferedReader reader=ChatRoomUtil.getMsgFromSocket(ots,buffer);//获取消息 String rMessage = buffer.toString(); String message=handle(ots,rMessage);//处理消息 PrintWriter writer=ChatRoomUtil.putMesgToSocket(ots, message);//发送消息 ChatRoomUtil.closeSocket(ots,reader,writer);//关闭 return null; &#125;&#125; ChatRoomUtil123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package chatroomutil;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.net.Socket;import javax.swing.JOptionPane;public class ChatRoomUtil &#123; public static String showErrorBox(String message) &#123;//显示错误信息对话框 JOptionPane.showMessageDialog(null, message, "错误", JOptionPane.ERROR_MESSAGE); return message; &#125; //获取消息 public static BufferedReader getMsgFromSocket(Socket socket,StringBuffer buffer)&#123; BufferedReader reader = null; try &#123; reader = new BufferedReader( new InputStreamReader(socket.getInputStream())); &#125; catch (IOException e) &#123; ChatRoomUtil.showErrorBox("获取Socket输入流错误"); System.exit(-1); &#125; try &#123; String line = ""; while ((line = reader.readLine()) != null) &#123; buffer.append(line + "\n"); &#125; buffer.deleteCharAt(buffer.length()-1);//去掉最后一个回车符 &#125; catch (IOException e) &#123; ChatRoomUtil.showErrorBox("读取Socket输入流错误"); System.exit(-1); &#125; try &#123; socket.shutdownInput(); &#125; catch (IOException e) &#123; ChatRoomUtil.showErrorBox("关闭Socket输入时发生错误"); System.exit(-1); &#125; return reader; &#125; //发送消息 public static PrintWriter putMesgToSocket(Socket socket,String message)&#123; PrintWriter writer = null; try &#123; writer = new PrintWriter(socket.getOutputStream()); &#125; catch (IOException e) &#123; ChatRoomUtil.showErrorBox("获取Socket输出流错误"); System.exit(-1); &#125; writer.println(message); writer.flush(); try &#123; socket.shutdownOutput(); &#125; catch (IOException e1) &#123; ChatRoomUtil.showErrorBox("关闭Socket输出时发生错误"); System.exit(-1); &#125; return writer; &#125; //关闭socket、输入流、输出流 public static void closeSocket(Socket socket,BufferedReader reader,PrintWriter writer )&#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; ChatRoomUtil.showErrorBox("关闭Scoket输入流时发生错误"); System.exit(-1); &#125; writer.close(); try &#123; socket.close(); &#125; catch (IOException e) &#123; ChatRoomUtil.showErrorBox("关闭Scoket输出流时发生错误"); System.exit(-1); &#125; &#125;&#125; ServerServer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238package chatroomserver;import java.io.BufferedReader;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.IOException;import java.io.RandomAccessFile;import java.net.ServerSocket;import java.net.Socket;import java.util.Enumeration;import java.util.Hashtable;import chatroomsend.Send;import chatroomutil.ChatRoomUtil;import chatroomutil.Server;public class ServerServer extends Server &#123; Hashtable&lt;String, User&gt; onlineTable = new Hashtable&lt;String, User&gt;();// 在线用户集合 Hashtable&lt;String, User&gt; offlineTable = new Hashtable&lt;String, User&gt;();// 离线用户集合 // 用户内部类 class User &#123; String id; String pwd; String IP; int port; User(String id, String pwd) &#123; this.id = id; this.pwd = pwd; &#125; &#125; // 发送进程内部类 class sendThread implements Runnable &#123; String mesg; String IP; int port; sendThread(String IP, int port, String mesg) &#123; this.IP = IP; this.port = port; this.mesg = mesg; &#125; @Override public void run() &#123; Send sendClient = new Send(); sendClient.connect(IP, port, 1000); sendClient.send(mesg); &#125; &#125;; public ServerServer(int port) throws IOException &#123; init(port); initUsers(); listen(); &#125; private int init(int port) throws IOException &#123; try &#123; sSocket = new ServerSocket(port);//绑定指定端口 &#125; catch (IOException e) &#123; ChatRoomUtil.showErrorBox("服务器初始化失败，无法绑定端口。"); System.exit(-1); &#125; return port; &#125; private int initUsers() &#123;//读取Users文件，初始化offlineTable BufferedReader reader = null; try &#123; reader = new BufferedReader(new FileReader("Users.txt")); &#125; catch (FileNotFoundException e1) &#123; ChatRoomUtil.showErrorBox("无法找到User文件"); System.exit(-1); &#125; String line; String[] fa; try &#123; while ((line = reader.readLine()) != null) &#123; fa = line.split(":", 2); User f = new User(fa[0], fa[1]); offlineTable.put(fa[0], f); &#125; reader.close(); &#125; catch (IOException e) &#123; ChatRoomUtil.showErrorBox("读取User文件错误"); System.exit(-1); &#125; return 0; &#125; private int saveNewUser(String id, String pwd) &#123;//将新用户写入Users文件最后 try &#123; RandomAccessFile file = new RandomAccessFile("Users.txt", "rw"); file.seek(file.length()); file.writeBytes(id + ":" + pwd + "\r\n"); file.close(); &#125; catch (FileNotFoundException e) &#123; ChatRoomUtil.showErrorBox("写入User文件错误"); System.exit(-1); &#125; catch (IOException e) &#123; ChatRoomUtil.showErrorBox("写入User文件错误"); System.exit(-1); &#125; return 0; &#125; String loginCheck(String id, String pwd, String IP, int port) &#123;//检查登录用户的合法性 System.out.println("logi check"); if (onlineTable.containsKey(id)) return "alreadyonline";//该用户已在线 User f = offlineTable.get(id); if (f == null) return "nothisid";//无此用户 if (f.pwd.compareTo(pwd) == 0) &#123; oneUserOnline(id, IP, port); sendOnlinesToNewOnlineUser(id, IP, port); sendNewOnlineUserToOnlines(id); return "yes";//合法 &#125; else &#123; return "wrong";//密码错误 &#125; &#125; int oneUserOnline(String id, String IP, int port) &#123;//一个新用户上线 User f = offlineTable.get(id); offlineTable.remove(id); onlineTable.put(id, f); f.IP = IP; f.port = port; return 0; &#125; int sendNewOnlineUserToOnlines(String id) &#123;//给所有在线用户发送新上线的用户的id Enumeration&lt;User&gt; fs = onlineTable.elements(); while (fs.hasMoreElements()) &#123; User f = fs.nextElement(); if (f.id.compareTo(id) != 0) &#123; Thread hThread = new Thread( new sendThread(f.IP, f.port, "newf" + id)); hThread.start(); &#125; &#125; return 0; &#125; int sendMesg(String mesg) &#123;//向所有在线用户转发一条消息 Enumeration&lt;User&gt; fs = onlineTable.elements(); while (fs.hasMoreElements()) &#123; User f = fs.nextElement(); Thread hThread = new Thread( new sendThread(f.IP, f.port, "mesg" + mesg)); hThread.start(); &#125; return 0; &#125; int sendChat(String id, String mesg) &#123;//向一个用户发送一条一对一聊天的消息 User f = onlineTable.get(id); Thread hThread = new Thread( new sendThread(f.IP, f.port, "chat" + mesg)); hThread.start(); return 0; &#125; String newRegisUser(String id, String pwd) &#123;//有新注册的用户 if (onlineTable.containsKey(id) || offlineTable.containsKey(id)) &#123; return "no"; &#125; offlineTable.put(id, new User(id, pwd)); saveNewUser(id, pwd); return "yes"; &#125; int sendOnlinesToNewOnlineUser(String id, String IP, int port) &#123;//给新上线的用户发送所有已在线用户的id if (onlineTable.isEmpty() || onlineTable.size() == 1) &#123; return 0; &#125; StringBuffer strBuf = new StringBuffer(); Enumeration&lt;User&gt; fs = onlineTable.elements(); while (fs.hasMoreElements()) &#123; User f = fs.nextElement(); if (f.id.compareTo(id) != 0) &#123; strBuf.append(f.id); strBuf.append(";"); &#125; &#125; String str = strBuf.toString(); Thread hThread = new Thread(new sendThread(IP, port, "newf" + str)); hThread.start(); return 0; &#125; int oneUserOffline(String id) &#123;//有一个用户下线，将其下线消息发送给所有在线用户 Enumeration&lt;User&gt; fs = onlineTable.elements(); while (fs.hasMoreElements()) &#123; User f = fs.nextElement(); if (f.id.compareTo(id) == 0) &#123; onlineTable.remove(id); offlineTable.put(id, f); &#125; else &#123; Thread hThread = new Thread( new sendThread(f.IP, f.port, "offl" + id)); hThread.start(); &#125; &#125; return 0; &#125; protected String handle(Socket ots,String rMessage)&#123; System.out.println("handle"); if (rMessage.startsWith("regi")) &#123;//注册 rMessage = rMessage.substring("regi".length()); String id = rMessage.substring(0, rMessage.indexOf(',')); String pwd = rMessage.substring(rMessage.indexOf(',') + 1); return newRegisUser(id, pwd); &#125; if (rMessage.startsWith("logi")) &#123;//登录 System.out.println("logi"); rMessage = rMessage.substring("logi".length()); String id = rMessage.substring(0, rMessage.indexOf(',')); String pwd = rMessage.substring(rMessage.indexOf(',') + 1, rMessage.lastIndexOf(',')); String portstr = rMessage.substring(rMessage.lastIndexOf(',') + 1); int port = new Integer(portstr); String IP = ots.getInetAddress().getHostAddress(); return loginCheck(id, pwd, IP, port); &#125; if (rMessage.startsWith("mesg")) &#123;//聊天室消息 String mesg = rMessage.substring(("mesg").length()); sendMesg(mesg); return "getm"; &#125; if (rMessage.startsWith("chat")) &#123;//一对一消息 String chat = rMessage.substring(("chat").length()); String id = chat.substring(0, chat.indexOf(':')); String mesg = chat.substring(chat.indexOf(':') + 1); sendChat(id, mesg); return "getm"; &#125; if (rMessage.startsWith("offl")) &#123;//下线 String id = rMessage.substring(("offl").length()); oneUserOffline(id); return "getm"; &#125; return "getm"; &#125; public static void main(String[] args) &#123; try &#123; new ServerServer(65142); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; Send12345678910111213141516171819202122232425262728293031package chatroomsend;import java.io.BufferedReader;import java.io.IOException;import java.io.PrintWriter;import java.net.InetSocketAddress;import java.net.Socket;import chatroomutil.ChatRoomUtil;public class Send &#123; Socket socket; public Send() &#123; super(); socket = new Socket(); &#125; public int connect(String IP, int port, int timeout) &#123;//连接 try &#123; socket.connect(new InetSocketAddress(IP, port), timeout); &#125; catch (IOException e) &#123; return -1; &#125; return 0; &#125; public String send(String message) &#123; PrintWriter writer=ChatRoomUtil.putMesgToSocket(socket, message); StringBuffer buffer=new StringBuffer(); BufferedReader reader=ChatRoomUtil.getMsgFromSocket(socket,buffer); String rMessage = buffer.toString(); ChatRoomUtil.closeSocket(socket,reader,writer); return rMessage; &#125;&#125; LoginBox123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174package chatroomclient;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.io.IOException;import javax.swing.*;import chatroomsend.Send;import chatroomutil.ChatRoomUtil;public class LoginBox extends JFrame implements ActionListener, MouseListener &#123; private static final long serialVersionUID = -329711894663212488L; ClientServer myServer; String serverIP; int serverPort; JLabel l_account = new JLabel(); JLabel l_password = new JLabel(); JLabel l_regist = new JLabel(); JTextField j_account = new JTextField(); JPasswordField j_password = new JPasswordField(); JButton submit = new JButton(); JButton cancel = new JButton(); JLabel clearAccount = new JLabel(); JLabel clearPassword = new JLabel(); public LoginBox(String ip, int port) &#123; super("登录"); try &#123; myServer = new ClientServer(serverIP, serverPort); Thread myServerThread = new Thread(myServer); myServerThread.start(); &#125; catch (IOException e) &#123; ChatRoomUtil.showErrorBox("服务器进程初始化失败，无法绑定端口。"); System.exit(-1); &#125; serverIP = ip; serverPort = port; setLayout(null); l_account.setVisible(true); l_account.setBounds(80, 40, 50, 30); l_account.setText("账号:"); l_password.setVisible(true); l_password.setBounds(80, 80, 50, 30); l_password.setText("密码:"); j_account.setBounds(130, 40, 150, 30); j_password.setBounds(130, 80, 150, 30); clearAccount.setBounds(280, 42, 26, 26); clearPassword.setBounds(280, 82, 26, 26); submit.setBounds(100, 130, 80, 30); submit.setText("登录"); cancel.setText("取消"); clearAccount.setText("X"); clearPassword.setText("X"); clearAccount.setOpaque(true); clearPassword.setOpaque(true); clearAccount.setBackground(Color.LIGHT_GRAY); clearPassword.setBackground(Color.LIGHT_GRAY); clearAccount.setHorizontalAlignment(JLabel.CENTER); clearPassword.setHorizontalAlignment(JLabel.CENTER); submit.setBackground(Color.LIGHT_GRAY); cancel.setBackground(Color.LIGHT_GRAY); submit.addActionListener(this); cancel.addActionListener(this); cancel.setBounds(190, 130, 80, 30); l_regist.setBounds(270, 200, 70, 30); l_regist.setText("没有账号?"); this.add(l_account); this.add(l_password); this.add(j_account); this.add(j_password); this.add(submit); this.add(cancel); this.add(l_regist); this.add(clearAccount); this.add(clearPassword); setBounds(480, 240, 370, 270); setVisible(true); setResizable(false); this.setDefaultCloseOperation(EXIT_ON_CLOSE); validate(); l_regist.addMouseListener(this); clearAccount.addMouseListener(this); clearPassword.addMouseListener(this); &#125; String checkPwd(String id, String pwd) &#123; Send sendClient = new Send(); sendClient.connect(serverIP, serverPort, 1000); String ret= sendClient .send("logi" + id + "," + pwd + "," + myServer.getMyServerPort()); if (ret.compareTo("yes") == 0) &#123; myServer.chatRoom = new ChatRoom(id, serverIP, serverPort); dispose(); &#125; else if (ret.compareTo("wrong") == 0) &#123; ChatRoomUtil.showErrorBox("登录失败，密码有误。"); &#125; else if (ret.compareTo("alreadyonline") == 0) &#123; ChatRoomUtil.showErrorBox("登录失败，该账号已在线"); &#125; else if (ret.compareTo("nothisid") == 0) &#123; ChatRoomUtil.showErrorBox("登录失败，账号不存在。"); new RegisBox(serverIP, serverPort, myServer.getMyServerPort()); &#125; return ret; &#125; @Override public void actionPerformed(ActionEvent e) &#123; Object t = e.getSource(); if (e.getSource().getClass() == JButton.class) &#123; JButton button = (JButton) (t); if (button.getText().compareTo("登录") == 0) &#123; String id = j_account.getText(); String pwd = String.valueOf(j_password.getPassword()); if (id.compareTo("") == 0 || pwd.compareTo("") == 0) &#123; ChatRoomUtil.showErrorBox("账号与密码均不能为空"); return; &#125; checkPwd(id, pwd); &#125; if (button.getText().compareTo("取消") == 0) &#123; dispose(); System.exit(0); &#125; &#125; &#125; @Override public void mouseClicked(MouseEvent e) &#123; if (e.getSource().equals(l_regist)) &#123; new RegisBox(serverIP, serverPort, myServer.getMyServerPort()); &#125; if (e.getSource().equals(clearAccount)) &#123; j_account.setText(""); &#125; if (e.getSource().equals(clearPassword)) &#123; j_password.setText(""); &#125; &#125; @Override public void mousePressed(MouseEvent e) &#123; &#125; @Override public void mouseReleased(MouseEvent e) &#123; &#125; @Override public void mouseEntered(MouseEvent e) &#123; Object x = e.getSource(); if (x.equals(l_regist)) &#123; JLabel l = (JLabel) x; l.setForeground(Color.blue); &#125; if (x.equals(clearAccount) || x.equals(clearPassword)) &#123; JLabel l = (JLabel) x; l.setBackground(Color.GRAY); &#125; &#125; @Override public void mouseExited(MouseEvent e) &#123; Object x = e.getSource(); if (x.equals(l_regist)) &#123; JLabel l = (JLabel) x; l.setForeground(Color.BLACK); &#125; if (x.equals(clearAccount) || x.equals(clearPassword)) &#123; JLabel l = (JLabel) x; l.setBackground(Color.LIGHT_GRAY); &#125; &#125; public static void main(String[] args) &#123; String serverIP = "127.0.0.1"; int serverPort = 65142; new LoginBox(serverIP, serverPort); &#125;&#125; RegisBox123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171package chatroomclient;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import javax.swing.*;import chatroomsend.Send;import chatroomutil.ChatRoomUtil;public class RegisBox extends JFrame implements ActionListener &#123; private static final long serialVersionUID = 5795626909275119718L; String serverIP; int serverPort; int myServerPort; JLabel id_label = new JLabel(); JLabel pwd_label = new JLabel(); JLabel pwdCheck_label = new JLabel(); JLabel num_label = new JLabel(); JLabel firstName_label = new JLabel(); JLabel lastName_label = new JLabel(); JLabel age_label = new JLabel(); JLabel sex_label = new JLabel(); JTextField id_text = new JTextField(); JPasswordField pwd_text = new JPasswordField(); JPasswordField pwdCheck_text = new JPasswordField(); JTextField num_text = new JTextField(); JTextField firstName_text = new JTextField(); JTextField lastName_text = new JTextField(); JTextField age_text = new JTextField(); JComboBox sex_box = new JComboBox(); JButton cancel = new JButton(); JButton regis = new JButton(); public RegisBox(String serverIP, int serverPort, int myServerPort) &#123; super(); this.serverIP = serverIP; this.serverPort = serverPort; this.myServerPort = myServerPort; setLayout(null); setTitle("注册"); id_label.setBounds(60, 23, 50, 20); pwd_label.setBounds(60, 53, 50, 20); pwdCheck_label.setBounds(50, 83, 70, 20); num_label.setBounds(60, 113, 50, 20); firstName_label.setBounds(60, 143, 50, 20); lastName_label.setBounds(60, 173, 50, 20); age_label.setBounds(60, 203, 50, 20); sex_label.setBounds(60, 233, 50, 20); id_text.setBounds(130, 20, 200, 26); pwd_text.setBounds(130, 50, 200, 26); pwdCheck_text.setBounds(130, 80, 200, 26); num_text.setBounds(130, 110, 200, 26); firstName_text.setBounds(130, 140, 200, 26); lastName_text.setBounds(130, 170, 200, 26); age_text.setBounds(130, 200, 200, 26); sex_box.setBounds(130, 230, 200, 26); regis.setBounds(190, 270, 70, 30); cancel.setBounds(270, 270, 70, 30); id_label.setText("账号"); pwd_label.setText("密码"); pwdCheck_label.setText("密码确认"); num_label.setText("编号"); firstName_label.setText("名"); lastName_label.setText("姓"); age_label.setText("年龄"); sex_label.setText("性别"); sex_box.addItem("男"); sex_box.addItem("女"); regis.setText("提交"); cancel.setText("取消"); regis.setBackground(Color.LIGHT_GRAY); cancel.setBackground(Color.LIGHT_GRAY); sex_box.setBackground(Color.LIGHT_GRAY); regis.addActionListener(this); cancel.addActionListener(this); this.add(id_label); this.add(pwd_label); this.add(pwdCheck_label); this.add(num_label); this.add(firstName_label); this.add(lastName_label); this.add(age_label); this.add(sex_label); this.add(id_text); this.add(pwd_text); this.add(pwdCheck_text); this.add(num_text); this.add(firstName_text); this.add(lastName_text); this.add(age_text); this.add(sex_box); this.add(regis); this.add(cancel); setBounds(200, 200, 500, 400); validate(); setResizable(false); setVisible(true); &#125; boolean regis(String serverIP, int serverPort, String id, String pwd, int myServerPort) &#123; Send sendClient = new Send(); sendClient.connect(serverIP, serverPort, 1000); if (sendClient.send("regi" + id + "," + pwd).compareTo("yes") == 0) &#123; return true; &#125; return false; &#125; boolean check() &#123; String id = id_text.getText(); String pwd = String.valueOf(pwd_text.getPassword()); String pwdc = String.valueOf(pwdCheck_text.getPassword()); String fName = firstName_text.getText(); String lName = lastName_text.getText(); String age = age_text.getText(); String num = num_text.getText(); String sex = sex_box.getSelectedItem().toString(); if (id.compareTo("") == 0) &#123; ChatRoomUtil.showErrorBox("账号不能为空"); return false; &#125; if (pwd.compareTo("") == 0) &#123; ChatRoomUtil.showErrorBox("密码不能为空"); return false; &#125; if (pwdc.compareTo("") == 0) &#123; ChatRoomUtil.showErrorBox("请确认密码"); return false; &#125; if (pwd.compareTo(pwdc) != 0) &#123; ChatRoomUtil.showErrorBox("两次输入的密码不符"); return false; &#125; if (num.compareTo("") == 0) &#123; ChatRoomUtil.showErrorBox("编号不能为空"); return false; &#125; if (fName.compareTo("") == 0) &#123; ChatRoomUtil.showErrorBox("名不能为空"); return false; &#125; if (lName.compareTo("") == 0) &#123; ChatRoomUtil.showErrorBox("姓不能为空"); return false; &#125; if (age.compareTo("") == 0) &#123; ChatRoomUtil.showErrorBox("年龄不能为空"); return false; &#125; if (sex.compareTo("") == 0) &#123; ChatRoomUtil.showErrorBox("性别不能为空"); return false; &#125; if (regis(serverIP, serverPort, id, pwd, myServerPort)) &#123; dispose(); &#125; else &#123; ChatRoomUtil.showErrorBox("注册失败。该用户已存在"); return false; &#125; return true; &#125; @Override public void actionPerformed(ActionEvent e) &#123; Object t = e.getSource(); if (e.getSource().getClass() == JButton.class) &#123; JButton button = (JButton) (t); if (button.getText().compareTo("提交") == 0) &#123; check(); &#125; if (button.getText().compareTo("取消") == 0) &#123; dispose(); &#125; &#125; &#125;&#125; ClientServer12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package chatroomclient;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;import chatroomutil.ChatRoomUtil;import chatroomutil.Server;public class ClientServer extends Server implements Runnable &#123; ChatRoom chatRoom; private int myPort; public ClientServer(String serverIP, int serverPort) throws IOException &#123; super(); myPort = init(); &#125; int getMyServerPort() &#123; return myPort; &#125; private int createServerSocket(int i) throws IOException &#123;//绑定端口i if (i &gt;= 65536) &#123; ChatRoomUtil.showErrorBox("ClientServer无端口可绑定"); System.exit(-1); &#125; try &#123; sSocket = new ServerSocket(i); &#125; catch (IOException e) &#123; return createServerSocket(i + 1); &#125; return i; &#125; private int init() throws IOException &#123; int port = createServerSocket(1025); return port; &#125; @Override protected String handle(Socket ots,String rMessage)&#123; String message = "getm"; if (rMessage.startsWith("newf")) &#123; while (chatRoom == null) &#123; try &#123; Thread.sleep(300); &#125; catch (InterruptedException e) &#123; ChatRoomUtil.showErrorBox("ClientServer在Sleep时出错"); System.exit(-1); &#125; &#125; String ids = rMessage.substring(("newf").length()); String[] idArray = ids.split(";"); chatRoom.addFriend(idArray); &#125; if (rMessage.startsWith("offl")) &#123; String name = rMessage.substring(("offl").length()); chatRoom.removeFriend(name); &#125; if (rMessage.startsWith("mesg")) &#123; String mesg = rMessage.substring(("mesg").length()); chatRoom.addRecord(mesg); &#125; if (rMessage.startsWith("chat")) &#123; String chat = rMessage.substring(("chat").length()); String id = chat.substring(0, chat.indexOf(':')); String mesg = chat.substring(chat.indexOf(':') + 1); chatRoom.dialogAddRecord(id, mesg); &#125; return message; &#125; @Override public void run() &#123; listen(); &#125;&#125; ChatRoom123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212package chatroomclient;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.util.HashSet;import java.util.Hashtable;import java.util.Iterator;import java.util.TimerTask;import javax.swing.*;import javax.swing.event.CaretEvent;import javax.swing.event.CaretListener;import chatroomsend.Send;import chatroomutil.ChatRoomUtil;public class ChatRoom extends JFrame implements ActionListener, MouseListener &#123; private static final long serialVersionUID = -9016166784223701159L; String myId; String serverIP; int serverPort; JLabel chatRoomLabel = new JLabel(); JLabel onlineLabel = new JLabel(); JTextArea chatArea = new JTextArea(); JPanel onlineArea = new JPanel(); JTextArea sendArea = new JTextArea(5, 20); JButton sendButton = new JButton(); JScrollPane chatScroll = new JScrollPane(chatArea); JScrollPane onlineScroll = new JScrollPane(onlineArea); JScrollPane sendScroll = new JScrollPane(sendArea); JPanel chatPanel = new JPanel(); JPanel onlinePanel = new JPanel(); JPanel sendPanel = new JPanel(); JPanel chatAndOnlinePanel = new JPanel(); HashSet&lt;String&gt; friends = new HashSet&lt;String&gt;(); Hashtable&lt;String, ChatDialog&gt; chatDialogs = new Hashtable&lt;String, ChatDialog&gt;(); BorderLayout mainLayout = new BorderLayout(); BorderLayout chatLayout = new BorderLayout(); BorderLayout onlineLayout = new BorderLayout(); BorderLayout sendLayout = new BorderLayout(); BorderLayout chatAndOnlineLayout = new BorderLayout(); FlowLayout onlineAreaLayout = new FlowLayout(); public ChatRoom(String id, String serverIP, int port) &#123; super("聊天室 " + id); this.myId = id; this.serverIP = serverIP; this.serverPort = port; mainLayout.setVgap(5); sendLayout.setHgap(10); chatAndOnlineLayout.setHgap(15); onlineAreaLayout.setVgap(1); this.setLayout(mainLayout); chatPanel.setLayout(chatLayout); onlinePanel.setLayout(onlineLayout); sendPanel.setLayout(sendLayout); chatAndOnlinePanel.setLayout(chatAndOnlineLayout); chatArea.setLineWrap(true); sendArea.setLineWrap(true); onlineArea.setLayout(onlineAreaLayout); onlineArea.setPreferredSize(new Dimension(130, 200)); sendButton.setText(" 发送 "); sendButton.setBackground(Color.LIGHT_GRAY); sendButton.addActionListener(this); onlineLabel.setText("在线好友(点击可开始聊天)"); chatRoomLabel.setText("聊天"); chatArea.setEditable(false); chatArea.setBackground(new Color(230, 230, 230)); chatPanel.add(chatRoomLabel, BorderLayout.NORTH); chatPanel.add(chatScroll, BorderLayout.CENTER); onlinePanel.add(onlineLabel, BorderLayout.NORTH); onlinePanel.add(onlineScroll, BorderLayout.CENTER); sendPanel.add(sendScroll, BorderLayout.CENTER); sendPanel.add(sendButton, BorderLayout.EAST); chatAndOnlinePanel.add(chatPanel, BorderLayout.CENTER); chatAndOnlinePanel.add(onlinePanel, BorderLayout.EAST); this.add(sendPanel, BorderLayout.SOUTH); this.add(chatAndOnlinePanel, BorderLayout.CENTER); friends.add(myId); this.setBounds(200, 200, 600, 650); setVisible(true); reFreshOnlineArea(); this.setDefaultCloseOperation(DO_NOTHING_ON_CLOSE); this.addWindowListener(new WindowAdapter() &#123; public void windowClosing(WindowEvent e) &#123;//点击关闭按钮时发送下线消息 sendOffLine(); System.exit(0); &#125; &#125;); sendArea.addCaretListener(new CaretListener() &#123; @Override public void caretUpdate(CaretEvent e) &#123; String str = sendArea.getText(); if (str.length() &gt; 5000) &#123; ChatRoomUtil.showErrorBox("字数过多，超出限制。"); &#125; &#125; &#125;); new java.util.Timer().schedule(new TimerTask() &#123;//定时刷新界面 public void run() &#123; repaint(); &#125; &#125;, 400, 400); &#125; int reFreshOnlineArea() &#123;//刷新当前在线用户 int size = friends.size(); onlineArea.removeAll(); Iterator&lt;String&gt; it = friends.iterator(); while (it.hasNext()) &#123; String str = it.next(); String id = str; JLabel label = new JLabel(id); label.addMouseListener(this); label.setPreferredSize(new Dimension(130, 20)); label.setBackground(Color.GRAY); label.setForeground(Color.WHITE); label.setHorizontalAlignment(JLabel.CENTER); label.setOpaque(true); onlineArea.add(label); &#125; onlineArea.setPreferredSize(new Dimension(130, size * 22)); this.repaint(); this.validate(); return 0; &#125; int sendOffLine() &#123;//发送下线消息 Send sendClient = new Send(); sendClient.connect(serverIP, serverPort, 1000); sendClient.send("offl" + myId); return 0; &#125; public int addFriend(String[] fs) &#123;//添加上线的用户 for (int i = 0; i &lt; fs.length; i++) &#123; friends.add(fs[i]); &#125; reFreshOnlineArea(); return 0; &#125; public int removeFriend(String friendID) &#123;//移除一个用户（已下线） friends.remove(friendID); reFreshOnlineArea(); return 0; &#125; public int addRecord(String mesg) &#123;//添加聊天记录 chatArea.append(mesg + "\n"); chatArea.setCaretPosition(chatArea.getText().length()); this.validate(); return 0; &#125; public int dialogAddRecord(String id, String mesg) &#123;//给一对一聊天增加聊天记录 if (chatDialogs.containsKey(id) == false) &#123; chatDialogs.put(id, new ChatDialog(this, myId, id, serverIP, serverPort)); &#125; chatDialogs.get(id).addRecord(mesg); return 0; &#125; int removeDialog(String id) &#123;//移除一对一聊天 chatDialogs.remove(id); return 0; &#125; private String sendMessage(String mesg) &#123;//发送群聊消息 Send sendClient = new Send(); sendClient.connect(serverIP, serverPort, 1000); String getm = sendClient.send("mesg" + myId + ": \n" + mesg); return getm; &#125; @Override public void actionPerformed(ActionEvent e) &#123; if (e.getSource().getClass() == JButton.class) &#123; sendMessage(sendArea.getText()); sendArea.setText(""); &#125; &#125; @Override public void mouseClicked(MouseEvent e) &#123; if (e.getSource().getClass() == JLabel.class) &#123; JLabel l = (JLabel) e.getSource(); if (l.getText().compareTo(myId) == 0) &#123; return; &#125; if (chatDialogs.containsKey(l.getText())) &#123; return; &#125; chatDialogs.put(l.getText(), new ChatDialog(this, myId, l.getText(), serverIP, serverPort)); &#125; &#125; @Override public void mouseEntered(MouseEvent e) &#123; if (e.getSource().getClass() == JLabel.class) &#123; JLabel l = (JLabel) e.getSource(); l.setBackground(Color.LIGHT_GRAY); l.setForeground(Color.BLACK); &#125; &#125; @Override public void mouseExited(MouseEvent e) &#123; if (e.getSource().getClass() == JLabel.class) &#123; JLabel l = (JLabel) e.getSource(); l.setBackground(Color.GRAY); l.setForeground(Color.WHITE); &#125; &#125; @Override public void mousePressed(MouseEvent e) &#123; &#125; @Override public void mouseReleased(MouseEvent e) &#123; &#125;&#125; ChatDialog123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107package chatroomclient;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import java.util.HashSet;import java.util.TimerTask;import javax.swing.*;import javax.swing.event.CaretEvent;import javax.swing.event.CaretListener;import chatroomsend.Send;import chatroomutil.ChatRoomUtil;public class ChatDialog extends JFrame implements ActionListener &#123; private static final long serialVersionUID = 1437996471885472344L; String myId; String otsId; String serverIP; int serverPort; JLabel chatRoomLabel = new JLabel(); JTextArea chatArea = new JTextArea(); JTextArea sendArea = new JTextArea(5, 20); JButton sendButton = new JButton(); JScrollPane chatScroll = new JScrollPane(chatArea); JScrollPane sendScroll = new JScrollPane(sendArea); JPanel chatPanel = new JPanel(); JPanel sendPanel = new JPanel(); HashSet&lt;String&gt; friends = new HashSet&lt;String&gt;(); BorderLayout mainLayout = new BorderLayout(); BorderLayout chatLayout = new BorderLayout(); BorderLayout sendLayout = new BorderLayout(); ChatRoom chatRoom; public ChatDialog(final ChatRoom chatRoom, String id, final String otsId, String serverIP, int port) &#123; super(id + "与" + otsId + "聊天"); this.chatRoom = chatRoom; this.myId = id; this.otsId = otsId; this.serverIP = serverIP; this.serverPort = port; mainLayout.setVgap(5); sendLayout.setHgap(10); this.setLayout(mainLayout); chatPanel.setLayout(chatLayout); sendPanel.setLayout(sendLayout); chatArea.setLineWrap(true); sendArea.setLineWrap(true); sendButton.setText(" 发送 "); sendButton.setBackground(Color.LIGHT_GRAY); sendButton.addActionListener(this); chatRoomLabel.setText("聊天"); chatArea.setEditable(false); chatArea.setBackground(new Color(230, 230, 230)); chatPanel.add(chatRoomLabel, BorderLayout.NORTH); chatPanel.add(chatScroll, BorderLayout.CENTER); sendPanel.add(sendScroll, BorderLayout.CENTER); sendPanel.add(sendButton, BorderLayout.EAST); this.add(sendPanel, BorderLayout.SOUTH); this.add(chatPanel, BorderLayout.CENTER); this.setBounds(200, 200, 530, 600); setVisible(true); this.setDefaultCloseOperation(DISPOSE_ON_CLOSE); sendArea.addCaretListener(new CaretListener() &#123; @Override public void caretUpdate(CaretEvent e) &#123; String str = sendArea.getText(); if (str.length() &gt; 5000) &#123; ChatRoomUtil.showErrorBox("字数过多，超出限制。"); &#125; &#125; &#125;); this.setDefaultCloseOperation(DO_NOTHING_ON_CLOSE); this.addWindowListener(new WindowAdapter() &#123; public void windowClosing(WindowEvent e) &#123;//关闭窗口后，ChatRoom要移除该对话 chatRoom.removeDialog(otsId); dispose(); &#125; &#125;); new java.util.Timer().schedule(new TimerTask() &#123; public void run() &#123; repaint(); &#125; &#125;, 400, 400); &#125; public int addRecord(String mesg) &#123; chatArea.append(mesg + "\n"); chatArea.setCaretPosition(chatArea.getText().length()); this.validate(); return 0; &#125; private String sendMessage(String mesg) &#123; Send sendClient = new Send(); sendClient.connect(serverIP, serverPort, 1000); String getm = sendClient.send( "chat" + otsId + ":" + myId + ":" + myId + ": \n" + mesg); addRecord(myId + ": \n" + mesg); return getm; &#125; @Override public void actionPerformed(ActionEvent e) &#123; if (e.getSource().getClass() == JButton.class) &#123; sendMessage(sendArea.getText()); sendArea.setText(""); &#125; &#125;&#125; Users.txt1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061:12:23:34:45:56:67:78:89:910:1011:1112:1213:1314:1415:1516:1617:1718:1819:1920:2021:2122:2223:2324:2425:2526:2627:2728:2829:2930:3031:3132:3233:3334:3435:3536:3637:3738:3839:3940:4041:4142:4243:4344:4445:4546:4647:4748:4849:4950:5051:5152:5253:5354:5455:5556:5657:5758:5859:5960:6061:6162:6263:6364:6465:6566:6667:6768:6869:6970:7071:7172:7273:7374:7475:7576:7677:7778:7879:7980:8081:8182:8283:8384:8485:8586:8687:8788:8889:8990:9091:9192:9293:9394:9495:9596:96aa:aaqq:qqww:wwee:eeguochengxin:guochengxinhuoda:huodazhangfa:zhangfahanyu:hanyumaxuewei:maxueweilizeyu:lizeyu 写于大三下实训期间 随笔写于2016.7.13]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[俄罗斯方块（Win32实现，Codeblocks+GCC编译）]]></title>
      <url>2016%2F05%2F08%2F%E4%BF%84%E7%BD%97%E6%96%AFC%2B%2B%2F</url>
      <content type="text"><![CDATA[缘起： 在玩Codeblocks自带的俄罗斯方块时觉得不错，然而有时间限制。所以想自己再写一个。 后来发现在设置中是可以取消时间限制的。。。Orz 程序效果： 主要内容： 程序中有一个board数组，其中有要显示的部分，也有不显示的部分，不显示的部分都存储1。 如下图： shape采用4*4数组(shape)保存。如：&gt;0 0 0 00 1 0 01 1 1 00 0 0 0 另外用变量row和column保存shape数组左上角在board中的位置。 每次下落或左右移动，先对row和column做出改变，然后检测当前row和column下，shape是否重合了为1的格子，如果有重合，就说明shape出界了或者到达下落最低点，则要恢复row和column值。另外，如果是下落，还要将shape放在board上，并产生新的shape。 旋转时，先对shape数组进行旋转操作，然后检测重合，如果有重合，则反向旋转回来。 &ensp;&ensp;&ensp;&ensp; 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553#if defined(UNICODE) &amp;&amp; !defined(_UNICODE)#define _UNICODE#elif defined(_UNICODE) &amp;&amp; !defined(UNICODE)#define UNICODE#endif#include &lt;tchar.h&gt;#include &lt;windows.h&gt;#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;time.h&gt;/*-----------------宏定义--------------------------------------------------------*/#define WIDTH 180#define HEIGHT 400#define LONG_SLEEP 300#define BKCOLOR RGB(238,238,238)//背景色/*-----------------变量----------------------------------------------------------*/static int shapes[7][4][4];//存储7个形状static int high_score[4]= &#123;0,0,0,0&#125;;//前三个元素存储最高分，最后一个元素存储此次得分static int **shape;//当前形状static int **board;static int M=15;//显示的列数static int N=30;//显示的行数static int MM=M+8;//board的列数static int NN=N+4;//board的行数static int LEFT=4;//显示的最左一列static int RIGHT=LEFT+M-1;//显示的最右一列static int TOP=0;//显示的最上一列static int BOTTOM=N-1;//显示的最下一列static int score=0;static int row=0;//形状所在行static int column=MM/2;//形状坐在列static bool is_pause=false;static HBRUSH grey_brush =CreateSolidBrush (RGB(210,210,210));static HBRUSH white_brush =CreateSolidBrush (RGB(130,130,130));static HBRUSH bk_brush =CreateSolidBrush (BKCOLOR);static HPEN hPen = CreatePen(PS_SOLID,1,RGB(147,155,166));static int lattices_top=40;//上面留白static int lattices_left=20;//左侧留白static int width=WIDTH/M;//每个格子的宽度static int height=(HEIGHT-lattices_top)/N;//每个格子的高度/*-----------------函数-----------------------------------------------------------*/void add_score() ;bool check_is_lose() ;void clear_up() ;//消除没有空格子的行void* down_thread_function(void * args) ;//形状下落进程要执行的函数void exit_game(HWND hwnd) ;void give_new_shape() ;//随机生成一个新形状int handle_key(HWND hwnd,WPARAM wParam) ;int init_down_thread(HWND hwnd) ;//初始化形状下落进程int init_game(HWND hwnd) ;//初始化游戏程序void init_play() ;//初始化游戏数据bool is_legel() ;//检测形状在当前位置是否合法（即是否重合了非空的格子）int load_scores(int* a) ;//读取游戏最高分数据int load_shape() ;//从文件中加载7个形状void lose_game(HWND hwnd) ;int move_down(HWND hwnd) ;//形状下落int move_lr(HWND hwnd,int lr) ;//形状左右移动void paint_lattice(HDC hdc,int x,int y,int color) ;//显示一个格子void paint_UI(HDC hdc) ;//画界面void reset_rc() ;void rerotate_matrix(int mn) ;//顺时针旋转一个行列数为mn的方阵void rotate_matrix(int mn) ;//逆时针旋转一个行列数为mn的方阵int rotate_shape(HWND hwnd) ;//旋转当前形状并更新界面bool save_score(HWND hwnd) ;//保存最高分数据void shape_to_ground() ;//当前形状落地之后，更新boardbool sort_scores(int* a) ;//对最高分和此次得分排序，若创造新纪录则返回truevoid update_UI(HWND hwnd) ;//更新界面，仅更新Rect区域（形状所在的那几行）内void update_UI_all(HWND hwnd) ;//更新界面，更新整个界面int write_scores(int* a) ;//写最高分数据/* Declare Windows procedure */LRESULT CALLBACK WindowProcedure (HWND, UINT, WPARAM, LPARAM);/* Make the class name into a global variable */TCHAR szClassName[ ] = _T("Tris");int WINAPI WinMain (HINSTANCE hThisInstance, HINSTANCE hPrevInstance, LPSTR lpszArgument, int nCmdShow) &#123; HWND hwnd; /* This is the handle for our window */ MSG messages; /* Here messages to the application are saved */ WNDCLASSEX wincl; /* Data structure for the windowclass */ /* The Window structure */ wincl.hInstance = hThisInstance; wincl.lpszClassName = szClassName; wincl.lpfnWndProc = WindowProcedure; /* This function is called by windows */ wincl.style = CS_DBLCLKS; /* Catch double-clicks */ wincl.cbSize = sizeof (WNDCLASSEX); /* Use default icon and mouse-pointer */ wincl.hIcon = LoadIcon (NULL, IDI_APPLICATION); wincl.hIconSm = LoadIcon (NULL, IDI_APPLICATION); wincl.hCursor = LoadCursor (NULL, IDC_ARROW); wincl.lpszMenuName = NULL; /* No menu */ wincl.cbClsExtra = 0; /* No extra bytes after the window class */ wincl.cbWndExtra = 0; /* structure or the window instance */ /* Use Windows's default colour as the background of the window */ wincl.hbrBackground =bk_brush; /* Register the window class, and if it fails quit the program */ if (!RegisterClassEx (&amp;wincl)) return 0; /* The class is registered, let's create the program*/ hwnd = CreateWindowEx ( 0, /* Extended possibilites for variation */ szClassName, /* Classname */ _T("Tris"), /* Title Text */ WS_OVERLAPPEDWINDOW, /* default window */ CW_USEDEFAULT, /* Windows decides the position */ CW_USEDEFAULT, /* where the window ends up on the screen */ WIDTH+200, /* The programs width */ HEIGHT+70, /* and height in pixels */ HWND_DESKTOP, /* The window is a child-window to desktop */ NULL, /* No menu */ hThisInstance, /* Program Instance handler */ NULL /* No Window Creation data */ ); /* Make the window visible on the screen */ ShowWindow (hwnd, nCmdShow); /* Run the message loop. It will run until GetMessage() returns 0 */ while (GetMessage (&amp;messages, NULL, 0, 0)) &#123; /* Translate virtual-key messages into character messages */ TranslateMessage(&amp;messages); /* Send message to WindowProcedure */ DispatchMessage(&amp;messages); &#125; /* The program return-value is 0 - The value that PostQuitMessage() gave */ return messages.wParam;&#125;//从文件中加载7个形状int load_shape() &#123; FILE* f=fopen("shapes.txt","rb"); if(f==NULL) &#123; return -1; &#125; for(int i=0; i&lt;7; i++) &#123; for(int j=0; j&lt;4; j++) &#123; for(int k=0; k&lt;4; k++) &#123; if(fscanf(f,"%d",&amp;shapes[i][j][k])!=1) &#123; return -1; &#125; &#125; &#125; &#125; fclose(f); return 0;&#125;//随机生成一个新形状void give_new_shape() &#123; int shape_num=rand()%7; for(int i=0; i&lt;4; i++) &#123; for(int j=0; j&lt;4; j++) &#123; shape[i][j]=shapes[shape_num][i][j]; &#125; &#125;&#125;void add_score() &#123; score+=100;&#125;//消除没有空格子的行void clear_up() &#123; for(int i=row; i&lt;=row+3; i++) &#123; if(i&gt;BOTTOM)continue; bool there_is_blank=false; for(int j=LEFT; j&lt;=RIGHT; j++) &#123; if(board[i][j]==0) &#123; there_is_blank=true; break; &#125; &#125; if(!there_is_blank) &#123; add_score(); for(int r=i; r&gt;=1; r--) &#123; for(int c=LEFT; c&lt;=RIGHT; c++) &#123; board[r][c]=board[r-1][c]; &#125; &#125; &#125; &#125;&#125;//检测形状在当前位置是否合法（即是否重合了非空的格子）bool is_legel() &#123; for(int i=0; i&lt;4; i++) &#123; for(int j=0; j&lt;4; j++) &#123; if(shape[i][j]==1&amp;&amp;board[row+i][column+j]==1) &#123; return false; &#125; &#125; &#125; return true;&#125;//逆时针旋转一个行列数为mn的方阵void rotate_matrix(int mn) &#123; int** a=shape; int s=0; for(int n=mn; n&gt;=1; n-=2) &#123; for(int i=0; i&lt;n-1; i++) &#123; int t=a[s+i][s]; a[s+i][s]=a[s][s+n-i-1]; a[s][s+n-i-1]=a[s+n-i-1][s+n-1]; a[s+n-i-1][s+n-1]=a[s+n-1][s+i]; a[s+n-1][s+i]=t; &#125; s++; &#125;&#125;//顺时针旋转一个行列数为mn的方阵void rerotate_matrix(int mn) &#123; int** a=shape; int s=0; for(int n=mn; n&gt;=1; n-=2) &#123; for(int i=0; i&lt;n-1; i++) &#123; int t=a[s+i][s]; a[s+i][s]=a[s+n-1][s+i]; a[s+n-1][s+i]=a[s+n-i-1][s+n-1]; a[s+n-i-1][s+n-1]=a[s][s+n-i-1]; a[s][s+n-i-1]=t; &#125; s++; &#125;&#125;//显示一个格子void paint_lattice(HDC hdc,int x,int y,int color) &#123; if(x&lt;TOP||x&gt;BOTTOM||y&lt;LEFT||y&gt;RIGHT) &#123; return ; &#125; x-=TOP; y-=LEFT; int left=lattices_left+y*width; int right=lattices_left+y*width+width; int top=lattices_top+x*height; int bottom=lattices_top+x*height+height; MoveToEx (hdc,left,top, NULL) ; LineTo (hdc,right,top) ; MoveToEx (hdc,left,top, NULL) ; LineTo (hdc,left,bottom) ; MoveToEx (hdc,left,bottom, NULL) ; LineTo (hdc,right,bottom) ; MoveToEx (hdc,right,top, NULL) ; LineTo (hdc,right,bottom) ; SelectObject(hdc, grey_brush); if(color==0) &#123; SelectObject(hdc, white_brush); &#125; Rectangle(hdc,left,top,right,bottom);&#125;//更新界面，仅更新Rect区域（形状所在的那几行）内void update_UI(HWND hwnd) &#123; static RECT rect; rect.left=lattices_left; rect.right=lattices_left+M*width+width; rect.top=lattices_top+(row-1)*height; rect.bottom=lattices_top+(row+4)*height; InvalidateRect (hwnd,&amp;rect, false) ;&#125;//更新界面，更新整个界面void update_UI_all(HWND hwnd) &#123; InvalidateRect (hwnd,NULL, false) ;&#125;//画界面void paint_UI(HDC hdc) &#123; SetBkColor(hdc,BKCOLOR); SelectObject(hdc,hPen); //选用画笔 char score_str[20]; sprintf(score_str,"Score:%d",score); TextOut(hdc,10,10,score_str,strlen(score_str)); sprintf(score_str,"Highest Scores:"); TextOut(hdc,WIDTH+50,50,score_str,strlen(score_str)); for(int i=0; i&lt;3; i++) &#123; sprintf(score_str,"%d",high_score[i]); TextOut(hdc,WIDTH+50,50+(i+1)*20,score_str,strlen(score_str)); &#125; for(int i=TOP; i&lt;=BOTTOM; i++) &#123; for(int j=LEFT; j&lt;=RIGHT; j++) &#123; paint_lattice(hdc,i,j,board[i][j]); &#125; &#125; for(int i=0; i&lt;4; i++) &#123; for(int j=0; j&lt;4; j++) &#123; if(shape[i][j]==1) paint_lattice(hdc,row+i,column+j,shape[i][j]); &#125; &#125;&#125;//旋转当前形状并更新界面int rotate_shape(HWND hwnd) &#123; int mn=4; rotate_matrix(mn); if(!is_legel()) &#123; rerotate_matrix(mn); &#125; update_UI(hwnd);&#125;void reset_rc() &#123; row=0; column=MM/2-2;&#125;//读取游戏最高分数据int load_scores(int* a) &#123; FILE* f=fopen("scores.txt","r"); if(f==NULL)return -1; fscanf(f,"%d%d%d",&amp;a[0],&amp;a[1],&amp;a[2]); return 0;&#125;//初始化游戏数据void init_play() &#123; load_scores(high_score); for(int i=0; i&lt;NN; i++) &#123; for(int j=0; j&lt;MM; j++) &#123; board[i][j]=0; &#125; &#125; for(int i=0; i&lt;N; i++) &#123; for(int j=0; j&lt;LEFT; j++) &#123; board[i][j]=1; &#125; &#125; for(int i=0; i&lt;N; i++) &#123; for(int j=RIGHT+1; j&lt;MM; j++) &#123; board[i][j]=1; &#125; &#125; for(int i=BOTTOM+1; i&lt;NN; i++) &#123; for(int j=0; j&lt;MM; j++) &#123; board[i][j]=1; &#125; &#125; reset_rc(); score=0; give_new_shape(); is_pause=false; return ;&#125;bool check_is_lose() &#123; if(row==0)return true; return false;&#125;//对最高分和此次得分排序，若创造新纪录则返回truebool sort_scores(int* a) &#123; int temp=a[3]; for(int i=0; i&lt;4; i++) &#123; for(int j=0; j&lt;3; j++) &#123; if(a[j]&lt;a[j+1]) &#123; int t=a[j]; a[j]=a[j+1]; a[j+1]=t; &#125; &#125; &#125; if(temp&gt;a[3])return true; return false;&#125;//写最高分数据int write_scores(int* a) &#123; FILE* f=fopen("scores.txt","w"); if(f==NULL)return -1; fprintf(f,"%d\n%d\n%d\n",a[0],a[1],a[2]); return 0;&#125;//保存最高分数据bool save_score(HWND hwnd) &#123; high_score[3]=score; bool made_record=sort_scores(high_score); if(write_scores(high_score)!=0) &#123; MessageBox(hwnd,"Write file error.Program will exit.","Error",NULL); DestroyWindow(hwnd); &#125; return made_record;&#125;void lose_game(HWND hwnd) &#123; if(is_pause)return ; is_pause=true; char message[200]="You lose the Game.\n"; char title[50]="Game Over"; if(save_score(hwnd)) &#123; strcat(message,"You have made a new record.\n"); char score_str[100]; sprintf(score_str,"The Highest Scores:\n%d\n%d\n%d\n",high_score[0],high_score[1],high_score[2]); strcat(message,score_str); &#125; strcat(message,"\nPlay again?\n"); if(MessageBox(hwnd,message,title,MB_YESNO)==IDYES) &#123; init_play(); update_UI_all(hwnd); &#125; else &#123; exit(0); &#125;&#125;void exit_game(HWND hwnd) &#123; is_pause=true; char message[200]=""; char title[50]="Exit"; if(save_score(hwnd)) &#123; strcat(message,"You have made a new record.\n"); char score_str[100]; sprintf(score_str,"The Highest Scores:\n%d\n%d\n%d\n",high_score[0],high_score[1],high_score[2]); strcat(message,score_str); MessageBox(hwnd,message,title,NULL); &#125; exit(0);&#125;//当前形状落地之后，更新boardvoid shape_to_ground() &#123; for(int i=0; i&lt;4; i++) &#123; for(int j=0; j&lt;4; j++) &#123; board[row+i][column+j]=shape[i][j]==1?1:board[row+i][column+j]; &#125; &#125;&#125;//形状下落int move_down(HWND hwnd) &#123; row++; if(!is_legel()) &#123; row--; if(check_is_lose()) &#123; lose_game(hwnd); return 0; &#125; shape_to_ground(); clear_up(); update_UI_all(hwnd); reset_rc(); give_new_shape(); &#125; update_UI(hwnd);&#125;//进程参数结构体struct thread_arg &#123; HWND arg_hwnd;&#125;;//形状下落进程要执行的函数void* down_thread_function(void * args) &#123; thread_arg *arg=(thread_arg*)args; HWND dhwnd=arg-&gt;arg_hwnd; while(true) &#123; if(is_pause) &#123; Sleep(300); continue; &#125; move_down(dhwnd); Sleep(LONG_SLEEP); &#125;&#125;//初始化形状下落进程int init_down_thread(HWND hwnd) &#123; int ret; pthread_t t; thread_arg *argp=new thread_arg; argp-&gt;arg_hwnd=hwnd; ret=pthread_create(&amp;t,NULL,down_thread_function,argp); delete argp; if(ret!=0) &#123; return -1; &#125; return 0;&#125;//初始化游戏程序int init_game(HWND hwnd) &#123; board=new int*[NN]; for(int i=0; i&lt;NN; i++) &#123; board[i]=new int[MM]; &#125; shape=new int*[4]; for(int i=0; i&lt;4; i++) &#123; shape[i]=new int[4]; &#125; srand(time(0)); if(load_shape()!=0) &#123; MessageBox(hwnd,"Read file error.Program will exit.","Error",NULL); exit(-1); &#125; init_play(); update_UI_all(hwnd); if(init_down_thread(hwnd)!=0) &#123; MessageBox(hwnd,"Thread error.Program will exit.","Error",NULL); exit(-1); &#125; return 0;&#125;//形状左右移动int move_lr(HWND hwnd,int lr) &#123; int temp=column; if(lr==0)column--; else &#123; column++; &#125; if(!is_legel()) &#123; column=temp; &#125; update_UI(hwnd);&#125;int handle_key(HWND hwnd,WPARAM wParam) &#123; if(wParam==VK_ESCAPE) &#123;//ESC退出 exit_game(hwnd); &#125; if(wParam==VK_SPACE) &#123;//空格暂停 is_pause=!is_pause; &#125; if(is_pause==true) &#123; Sleep(300); return 0; &#125; if(wParam==VK_UP) &#123; rotate_shape(hwnd); &#125; if(wParam==VK_DOWN) &#123; move_down(hwnd); &#125; if(wParam==VK_LEFT) &#123; move_lr(hwnd,0); &#125; if(wParam==VK_RIGHT) &#123; move_lr(hwnd,1); &#125; return 0;&#125;/* This function is called by the Windows function DispatchMessage() */HWND hwnd;LRESULT CALLBACK WindowProcedure (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) &#123; static HDC hdc; static HDC hdcBuffer; static HBITMAP hBitMap; static PAINTSTRUCT ps ; switch (message) &#123; /* handle the messages */ case WM_CREATE: init_game(hwnd); break; case WM_KEYDOWN: handle_key(hwnd,wParam); break; case WM_DESTROY: exit_game(hwnd); PostQuitMessage (0); /* send a WM_QUIT to the message queue */ break; case WM_PAINT: hdc = BeginPaint (hwnd, &amp;ps) ; paint_UI(hdc); EndPaint (hwnd, &amp;ps) ; break; default: /* for messages that we don't deal with */ return DefWindowProc (hwnd, message, wParam, lParam); &#125; return 0;&#125; 程序写于2016年五一期间 随笔写于2016.5.8]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java迷宫游戏]]></title>
      <url>2016%2F05%2F08%2F%E8%BF%B7%E5%AE%AB%2F</url>
      <content type="text"><![CDATA[缘起： 去年（大三上学期）比较喜欢写小游戏，于是想试着写个迷宫试一下。 程序效果： 按下空格显示路径： 思考过程： 迷宫由一个一个格子组成，要求从入口到出口只有一条路径. 想了一下各种数据结构，似乎树是比较合适的，从根节点到每一个子节点都只有一条路径。假设入口是根节点，出口是树中某个子节点，那么，从根节点到该子节点的路径肯定是唯一的。 所以如果能构造一棵树把所有的格子都覆盖到，也就能够做出一个迷宫了。 另外还要求树的父节点和子节点必须是界面上相邻的格子。 在界面显示时，父节点和子节点之间共用的边不画，其他的边都画出来，就能画出一个迷宫。 之后就是想一下该怎么实现这样一棵树。 首要的两个问题：&gt; 树怎么表示？&gt; 怎么构造这棵树？ 1.树怎么表示？ 假设像写二叉树一样实现这棵树，那么每个树节点里就要存储一个坐标（X,Y）表示一个格子，另外还要存储四个指针。指针中有的为空，有的不为空，不为空的指针指向子节点，子节点保存邻居格子的坐标。这样做最大的问题是无法判定是否所有的格子都在树中。也许还要用一个二维数组作标志数组。 假如用二维数组表示迷宫的格子。每个数组元素存储一个指向父节点的引用，这样也可以形成一个虚拟的树。于是就用一个NN的二维数组，表示NN个格子，每个数组元素(Lattice)中有一个指向父节点的引用(father)。另外，为了能方便的获取格子的坐标，还要保存坐标信息。 2.怎么构造这棵树？ 首先选定一个格子作为根节点。为了让迷宫的形状够随机，我选择随机生成一个坐标作为根节点。其实，选择确定的一个坐标也可以。 然后，怎样往这棵树上增加节点呢？ 在这里我走了不少弯路，一开始想的是一种现在看来类似回溯的算法（当时还不知道回溯算法。。），但是时间复杂度很高，大概当迷宫为64*64的时候，算法就不出结果了。 然后，又使用了一种扫深度搜索也是回溯描的方法，每次扫描在当前树中找一个节点，看它的邻居格子是否在树中，如果还没在树中，就将该邻居格子加入树中，如果已在树中，就看下一个邻居格子，如果该节点所有邻居格子都在树中了，就找下一个节点，继续同样的操作。另外为了让迷宫生成的随机，扫描的起始位置是随机的就可以了。但是，该方法生成的迷宫中的路径总是不够深，没有我想要的曲折深入的效果。毕竟是类似广度搜索的方法。而且，这样做总还像是靠蛮力，算法不够聪明简洁。 最后，我终于想到使用深度搜索。。大概是因为数据结构已经学过了一年，又没太练，忘了不少，所以一直没想到这个应该第一想到的方法。。 随机选择一个格子作为根节点，从它开始随机地深度搜索前进，开出一条路来，直到无路可走了，退回一步，换另一条路，再走到无路可走，回退一步，换另一条……如此循环往复，直到完全无路可走。。。其实也还是回溯。 在程序里就是以下过程（详见代码中的createMaze()函数）：&gt; 随机选择一个格子作为根节点，将它压进栈里。&gt; 然后在栈不为空的时候执行以下循环： &gt; 取出一个格子，将它的INTREE标志设置为1，然后将它的所有不在树中的邻居格子压进栈里（顺序随机），并且让这些邻居格子的father指向该格子。 解决了这两个问题，其余的画迷宫、显示路径、小球移动也就比较简单了。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281package maze;import java.awt.Color;import java.awt.Graphics;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.util.Random;import java.util.Stack;import javax.swing.JFrame;import javax.swing.JOptionPane;import javax.swing.JPanel;class Lattice &#123; static final int INTREE = 1; static final int NOTINTREE = 0; private int x = -1; private int y = -1; private int flag = NOTINTREE; private Lattice father = null; public Lattice(int xx, int yy) &#123; x = xx; y = yy; &#125; public int getX() &#123; return x; &#125; public int getY() &#123; return y; &#125; public int getFlag() &#123; return flag; &#125; public Lattice getFather() &#123; return father; &#125; public void setFather(Lattice f) &#123; father = f; &#125; public void setFlag(int f) &#123; flag = f; &#125; public String toString() &#123; return new String("(" + x + "," + y + ")\n"); &#125;&#125;public class Maze extends JPanel &#123; private static final long serialVersionUID = -8300339045454852626L; private int NUM, width, padding;// width 每个格子的宽度和高度 private Lattice[][] maze; private int ballX, ballY; private boolean drawPath = false; Maze(int m, int wi, int p) &#123; NUM = m; width = wi; padding = p; maze = new Lattice[NUM][NUM]; for (int i = 0; i &lt;= NUM - 1; i++) for (int j = 0; j &lt;= NUM - 1; j++) maze[i][j] = new Lattice(i, j); createMaze(); setKeyListener(); this.setFocusable(true); &#125; private void init() &#123; for (int i = 0; i &lt;= NUM - 1; i++) for (int j = 0; j &lt;= NUM - 1; j++) &#123; maze[i][j].setFather(null); maze[i][j].setFlag(Lattice.NOTINTREE); &#125; ballX = 0; ballY = 0; drawPath = false; createMaze(); // setKeyListener(); this.setFocusable(true); repaint(); &#125; public int getCenterX(int x) &#123; return padding + x * width + width / 2; &#125; public int getCenterY(int y) &#123; return padding + y * width + width / 2; &#125; public int getCenterX(Lattice p) &#123; return padding + p.getY() * width + width / 2; &#125; public int getCenterY(Lattice p) &#123; return padding + p.getX() * width + width / 2; &#125; private void checkIsWin() &#123; if (ballX == NUM - 1 &amp;&amp; ballY == NUM - 1) &#123; JOptionPane.showMessageDialog(null, "YOU WIN !", "你走出了迷宫。", JOptionPane.PLAIN_MESSAGE); init(); &#125; &#125; synchronized private void move(int c) &#123; int tx = ballX, ty = ballY; // System.out.println(c); switch (c) &#123; case KeyEvent.VK_LEFT : ty--; break; case KeyEvent.VK_RIGHT : ty++; break; case KeyEvent.VK_UP : tx--; break; case KeyEvent.VK_DOWN : tx++; break; case KeyEvent.VK_SPACE : if (drawPath == true) &#123; drawPath = false; &#125; else &#123; drawPath = true; &#125; break; default : &#125; if (!isOutOfBorder(tx, ty) &amp;&amp; (maze[tx][ty].getFather() == maze[ballX][ballY] || maze[ballX][ballY].getFather() == maze[tx][ty])) &#123; ballX = tx; ballY = ty; &#125; &#125; private void setKeyListener() &#123; this.addKeyListener(new KeyAdapter() &#123; public void keyPressed(KeyEvent e) &#123; int c = e.getKeyCode(); move(c); repaint(); checkIsWin(); &#125; &#125;); &#125; private boolean isOutOfBorder(Lattice p) &#123; return isOutOfBorder(p.getX(), p.getY()); &#125; private boolean isOutOfBorder(int x, int y) &#123; return (x &gt; NUM - 1 || y &gt; NUM - 1 || x &lt; 0 || y &lt; 0) ? true : false; &#125; private Lattice[] getNeis(Lattice p) &#123; final int[] adds = &#123;-1, 0, 1, 0, -1&#125;;// 顺序为上右下左 if (isOutOfBorder(p)) &#123; return null; &#125; Lattice[] ps = new Lattice[4];// 顺序为上右下左 int xt; int yt; for (int i = 0; i &lt;= 3; i++) &#123; xt = p.getX() + adds[i]; yt = p.getY() + adds[i + 1]; if (isOutOfBorder(xt, yt)) continue; ps[i] = maze[xt][yt]; &#125; return ps; &#125; private void createMaze() &#123; Random random = new Random(); int rx = Math.abs(random.nextInt()) % NUM; int ry = Math.abs(random.nextInt()) % NUM; Stack&lt;Lattice&gt; s = new Stack&lt;Lattice&gt;(); Lattice p = maze[rx][ry]; Lattice neis[] = null; s.push(p); while (!s.isEmpty()) &#123; p = s.pop(); p.setFlag(Lattice.INTREE); neis = getNeis(p); int ran = Math.abs(random.nextInt()) % 4; for (int a = 0; a &lt;= 3; a++) &#123; ran++; ran %= 4; if (neis[ran] == null || neis[ran].getFlag() == Lattice.INTREE) continue; s.push(neis[ran]); neis[ran].setFather(p); &#125; &#125; // changeFather(maze[0][0],null); &#125; private void changeFather(Lattice p, Lattice f) &#123; if (p.getFather() == null) &#123; p.setFather(f); return; &#125; else &#123; changeFather(p.getFather(), p); &#125; &#125; private void clearFence(int i, int j, int fx, int fy, Graphics g) &#123; int sx = padding + ((j &gt; fy ? j : fy) * width), sy = padding + ((i &gt; fx ? i : fx) * width), dx = (i == fx ? sx : sx + width), dy = (i == fx ? sy + width : sy); if (sx != dx) &#123; sx++; dx--; &#125; else &#123; sy++; dy--; &#125; g.drawLine(sx, sy, dx, dy); &#125; protected void paintComponent(Graphics g) &#123; super.paintComponent(g); for (int i = 0; i &lt;= NUM; i++) &#123; g.drawLine(padding + i * width, padding, padding + i * width, padding + NUM * width); &#125; for (int j = 0; j &lt;= NUM; j++) &#123; g.drawLine(padding, padding + j * width, padding + NUM * width, padding + j * width); &#125; g.setColor(this.getBackground()); for (int i = NUM - 1; i &gt;= 0; i--) &#123; for (int j = NUM - 1; j &gt;= 0; j--) &#123; Lattice f = maze[i][j].getFather(); if (f != null) &#123; int fx = f.getX(), fy = f.getY(); clearFence(i, j, fx, fy, g); &#125; &#125; &#125; g.drawLine(padding, padding + 1, padding, padding + width - 1); int last = padding + NUM * width; g.drawLine(last, last - 1, last, last - width + 1); g.setColor(Color.RED); g.fillOval(getCenterX(ballY) - width / 3, getCenterY(ballX) - width / 3, width / 2, width / 2); if (drawPath == true) drawPath(g); &#125; private void drawPath(Graphics g) &#123; Color PATH_COLOR = Color.ORANGE, BOTH_PATH_COLOR = Color.PINK; if (drawPath == true) g.setColor(PATH_COLOR); else g.setColor(this.getBackground()); Lattice p = maze[NUM - 1][NUM - 1]; while (p.getFather() != null) &#123; p.setFlag(2); p = p.getFather(); &#125; g.fillOval(getCenterX(p) - width / 3, getCenterY(p) - width / 3, width / 2, width / 2); p = maze[0][0]; while (p.getFather() != null) &#123; if (p.getFlag() == 2) &#123; p.setFlag(3); g.setColor(BOTH_PATH_COLOR); &#125; g.drawLine(getCenterX(p), getCenterY(p), getCenterX(p.getFather()), getCenterY(p.getFather())); p = p.getFather(); &#125; g.setColor(PATH_COLOR); p = maze[NUM - 1][NUM - 1]; while (p.getFather() != null) &#123; if (p.getFlag() == 3) break; g.drawLine(getCenterX(p), getCenterY(p), getCenterX(p.getFather()), getCenterY(p.getFather())); p = p.getFather(); &#125; &#125; public static void main(String[] args) &#123; final int n = 30, width = 600, padding = 20, LX = 200, LY = 100; JPanel p = new Maze(n, (width - padding - padding) / n, padding); JFrame frame = new JFrame("MAZE(按空格键显示或隐藏路径)"); frame.getContentPane().add(p); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(width + padding, width + padding + padding); frame.setLocation(LX, LY); frame.setVisible(true); &#125;&#125; 程序完成于大三上学期。 随笔写于2016.5.8]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读文件错误]]></title>
      <url>2016%2F04%2F29%2F%E8%AF%BB%E6%96%87%E4%BB%B6%E9%94%99%E8%AF%AF%2F</url>
      <content type="text"><![CDATA[今天想写个小程序，但一开始就不顺利。 想从文件中读取数据，但使用 fscanf ，总是读不出任何信息。 最后无奈了，改用 fread 看一下能读出什么内容，发现除了开始几个字符是乱码，之后读取的数据都是正常的。 这个现象正是前一段时间遇到过的，因为文件编码是 UTF-8 ，所以无法读出正确的 ASCII 码。 马上将文件重新以 ANSI 格式编码。程序立刻正常了。 之所以每次新建一个文本文档都是 UTF-8 编码，是去年编写网页时设置的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[在文件夹中 的指定类型文件中 查找字符串（CodeBlocks+GCC编译，控制台程序，仅能在Windows上运行）]]></title>
      <url>2016%2F04%2F15%2Ffindstr%2F</url>
      <content type="text"><![CDATA[说明： 程序使用 io.h 中的_findfirst 和 _findnext 函数遍历文件夹，故而程序只能在 Windows 下使用。 程序遍历当前文件夹，对其中的文件夹执行递归遍历。同时检查遍历到的文件是否属于指定类型，如果是，则将在该文件中查找指定字符串。 在文件中查找字符串时，开辟一个与指定字符串 text （长度为len ）同样大小的字符串数组 temp 。数组上有两个指针：一个是字符串比较的开始位置 s ，一个是新字符写入的位置 d 。每从文件中读入一个字符，就写入 temp[d] ，之后 temp 从 s 到 d 与 text 从 0 到 len-1 比较，之后， s 与 d 均后移一位，再继续读入字符，写入，比较，后移。。。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;stdio.h&gt;#include&lt;vector&gt;#include&lt;string.h&gt;#include&lt;io.h&gt;using namespace std;vector&lt;char*&gt; types;char text[256];void ls_path(char * path);bool is_in_types(char* filename);void findtext(char * filename,char* text);void solve(char* name,struct _finddata_t *f) &#123; if(strcmp(f-&gt;name,".")==0)return ; if(strcmp(f-&gt;name,"..")==0)return ; char *fullpath=new char[256]; strcpy(fullpath,name); int len=strlen(name); fullpath[len-1]='\0'; strcat(fullpath,f-&gt;name); if(f-&gt;attrib&amp;_A_SUBDIR) &#123; strcat(fullpath,"/*"); ls_path(fullpath); &#125; else &#123; if(is_in_types(f-&gt;name)) &#123; findtext(fullpath,text); &#125; &#125; delete fullpath;&#125;void ls_path(char * path) &#123; struct _finddata_t f; int p; char *name=new char[260]; strcpy(name,path); if((p=_findfirst(name, &amp;f))!=-1) &#123; solve(name,&amp;f); while(_findnext(p, &amp;f)==0) &#123; solve(name,&amp;f); &#125; &#125; delete name;&#125;int strrncmp(char* a,const char* b,int n) &#123;//比较两字符串的最后n个字符 int len=strlen(a); int j=0; for(int i=len-n; i&lt;=len-1; i++) &#123; if(a[i]!=b[j])return false; j++; &#125; return j==n?true:false;&#125;bool is_in_types(char* filename) &#123; for(int i=0; i&lt;types.size(); i++) &#123; if(strrncmp(filename,types[i],strlen(types[i]))) &#123; return true; &#125; &#125; return false;&#125;bool cmp(const char* temp,const int len,const int s,const int d,const char* text) &#123; int j=0; for(int i=s;; i++,i%=len) &#123; if(temp[i]!=text[j])return false; if(i==d)break; j++; &#125; return true;&#125;void findtext(char * filename,char* text) &#123; FILE *f=fopen(filename,"r"); char c; int linenum=0; int len=strlen(text); char* temp=new char[len]; int s=0,d=len-1; while(c=fgetc(f),c!=EOF) &#123; temp[d]=c; if(cmp(temp,len,s,d,text))printf("文件名: %s \n行号: %d\n",filename,linenum+1); if(c=='\n'||c=='\r'||c=='\r\n') &#123; linenum++; &#125; d++; d%=len; s++; s%=len; &#125; delete temp; fclose(f);&#125;int main() &#123; printf("**************************************\n"); printf("本程序在其所在文件夹中查找指定类型文件\n中是否有指定字符串，并输出所在行号。\n"); printf(" CopyRight: maxuewei2\n"); printf("**************************************\n"); while(true) &#123; types.clear(); printf("\n请输入要查找的字符串:\n"); while(gets(text),strcmp(text,"")==0); printf("请输入文件类型，如‘txt’:(按两下ENTER开始查找)\n"); char t[30]; while(gets(t),strcmp(t,"")!=0) &#123; char* tt=new char[30]; strcpy(tt,"."); strcat(tt,t); types.push_back(tt); &#125; delete t; printf("查找结果:\n"); ls_path("*"); &#125; types.clear(); delete text; getchar(); return 0;&#125; 运行效果： 程序完成于2016.4.15 博客更新于2016.4.15]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Flappy Bird (Java实现)]]></title>
      <url>2016%2F04%2F12%2FFlappyBird%2F</url>
      <content type="text"><![CDATA[运行效果： 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256package bird;import java.awt.Graphics;import java.awt.Image;import java.awt.Toolkit;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.Random;import javax.swing.JFrame;import javax.swing.JOptionPane;import javax.swing.JPanel;public class Bird extends JPanel &#123; private final int WIDTH=288; private int HEIGHT=512+112;// Image img; private Image bg,land,pipe_up,pipe_down,bird,score_h,score_t,score_n; private int y=300,land_x=0,pipe_x=200,current_y=0,time=0,down=0,bg_x=0,t=0,score=0,yt=-1; private int a = 0, b = 0, c = 0; private int[] pipe_ys=new int[4]; private Image [] score_number=new Image[10]; private Random random; Bird()&#123; getBestScores() ; Toolkit tool = this.getToolkit(); bg= tool.getImage("images/bg_day.png"); land=tool.getImage("images/land.png"); pipe_up= tool.getImage("images/pipe_up.png"); pipe_down= tool.getImage("images/pipe_down.png"); bird= tool.getImage("images/bird0_01.png"); random = new Random(); for(int i=0;i&lt;=9;i++)&#123; score_number[i]= tool.getImage("images/number_score_0"+i+".png"); &#125; init(); this.addKeyListener( new KeyAdapter() &#123; public void keyPressed(KeyEvent e) &#123; int c = e.getKeyCode(); //System.out.print(c); switch (c) &#123; case KeyEvent.VK_LEFT : break; case KeyEvent.VK_RIGHT : break; case KeyEvent.VK_UP : System.exit(0); break; case KeyEvent.VK_DOWN : break; case KeyEvent.VK_SPACE : down=0; if(time&lt;=0)time=16; break; default : // System.out.print("hey"); &#125; &#125; &#125;); this.setFocusable(true); &#125; void init()&#123; y=300; land_x=0; pipe_x=200; current_y=0; time=0; down=0; bg_x=0; t=0; score=0; yt=-1; for(int i=0;i&lt;=3;i++)&#123; pipe_ys[i]=-1* Math.abs(random.nextInt()) % 150; &#125; &#125; public int get_Height()&#123;return HEIGHT;&#125; public int get_Width()&#123;return WIDTH;&#125; private void move()&#123; while(true)&#123; moveImg(); try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; moveBird(); repaint(); check(); t++; &#125; &#125; private void moveBird()&#123; time--; if(t%1==0)&#123;if(time&gt;0)&#123;y-=4;&#125;&#125; if(time&lt;=-5&amp;&amp;y&lt;=512-37)&#123;if(t%3==0)&#123;down+=1;y+=down;&#125;&#125; &#125; private void moveImg()&#123; bg_x--; if(bg_x&lt;-288)bg_x+=288; land_x-=1; if(land_x&lt;-20)land_x+=23; pipe_x-=1; if(pipe_x&lt;=-52)&#123; pipe_x+=200; int ran = Math.abs(random.nextInt()) % 200; ran=-ran; pipe_ys[current_y]=ran; current_y++; current_y%=4; &#125; &#125; private void check()&#123; int temp=current_y; for(int i=0;i&lt;=3;i++)&#123; if(80+34&gt;=pipe_x&amp;&amp;80&lt;=pipe_x+52)&#123; if(yt!=current_y)&#123;score++;yt=current_y;&#125; if(y&lt;=pipe_ys[temp]+320||y+25&gt;=pipe_ys[temp]+450)&#123; gameOver(); init(); &#125; &#125; &#125; &#125; private int gameOver() &#123; if (score &gt; a) &#123; c = b; b = a; a = score; save(); //System.exit(0); &#125; else if (score &gt; b) &#123; c = b; b = score; save(); //System.exit(0); return 0; &#125; else if (score &gt; c) &#123; c = score; save(); //System.exit(0); return 0; &#125; JOptionPane.showMessageDialog(null, "GAME OVER!\n\nBEST SCORE:\n"+a+"\n"+b+"\n"+c, "你死了(按任意键再来一次)", JOptionPane.PLAIN_MESSAGE); //System.exit(0); return 0; &#125; private void getBestScores() &#123; BufferedReader reader = null; try &#123; reader = new BufferedReader(new FileReader("score.txt")); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; try &#123; a = Integer.parseInt(reader.readLine()); b = Integer.parseInt(reader.readLine()); c = Integer.parseInt(reader.readLine()); &#125; catch (NumberFormatException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; /*String bestS = new String("Best Score: " + new Integer(a).toString() + " " + new Integer(b).toString() + " " + new Integer(c).toString());*/ return ; &#125; private int save() &#123; BufferedWriter writer = null; try &#123; writer = new BufferedWriter(new FileWriter("score.txt")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; String d = new Integer(a).toString(), e = new Integer(b).toString(), f = new Integer(c).toString(); try &#123; writer.write(d); writer.newLine(); writer.write(e); writer.newLine(); writer.write(f); writer.flush(); writer.close(); &#125; catch (NumberFormatException ev) &#123; ev.printStackTrace(); &#125; catch (IOException ev) &#123; ev.printStackTrace(); &#125; return 0; &#125; private void showScore(Graphics g)&#123; int score_h=score/100,score_t=score%100/10,score_n=score%10; if(score_h!=0)&#123;g.drawImage(score_number[score_h], 80,20,this);&#125; g.drawImage(score_number[score_t], 80+20,20,this); g.drawImage(score_number[score_n], 80+20+20,20,this); &#125; public void paint(Graphics g) &#123;//Component super.paintComponent(g); //g.drawLine(x,y,200,200); g.drawImage(bg, bg_x,0,this); g.drawImage(bg, bg_x+288,0,this); //g.drawImage(land_1, landx_1, HEIGHT-land_1.getHeight(this), WIDTH,WIDTH*land_1.getHeight(this)/land_1.getWidth(this), this); int temp=current_y; for(int i=0;i&lt;=3;i++)&#123; g.drawImage(pipe_down,pipe_x+i*200,pipe_ys[temp],this); g.drawImage(pipe_up,pipe_x+i*200,pipe_ys[temp]+450,this); g.drawImage(bird,80,y,this); temp++; temp%=4; &#125; g.drawImage(land, land_x,512,this); showScore(g); &#125; public static void main(String[] args) &#123; JFrame frame = new JFrame("（按UP键退出）"); Bird b=new Bird(); frame.getContentPane() .add(b); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(b.get_Width(),b.get_Height()); frame.setLocation(200, 100); frame.setVisible(true); b.move(); &#125;&#125; 素材：bg_day.png bird0_01.png land.png pipe_up.png pipe_down.png number_score_00.png~number_score_09.png (数字均为白色，图片背景为透明。为能够在博客中显示出来，特设置为灰色背景) 程序写于大三上学期。 2016.4.12更新博客。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[局域网象棋游戏（C++实现，使用Socket，界面使用Win32，CodeBlocks+GCC编译）]]></title>
      <url>2016%2F03%2F22%2F%E5%B1%80%E5%9F%9F%E7%BD%91%E8%B1%A1%E6%A3%8B%2F</url>
      <content type="text"><![CDATA[目录 成果 运行效果图 过程 1. 首先的问题是下棋的两端应该是什么样的？ 2. 接下来的问题是怎么表示，怎么存储？ 3. 然后应该怎么通信呢？ 代码 main.cpp chinese_chess.h Server.h Client.h END &ensp;&ensp;&ensp;&ensp; 成果 运行效果图 左边是在虚拟机里运行的，右边是在Host机上运行的。 过程 记不起自己为什么要写这个象棋游戏的，大概是因为刚学了点儿Socket ，所以想用用，于是就写个局域网对战的象棋吧。。。 1.首先的问题是下棋的两端应该是什么样的？ 我希望下棋的两个人使用相同的程序。所以就不能像FTP一样，一个客户端，一个服务器端，而只能每个程序都是一样的，既是客户端（Client），又是服务器端（Server）。在通信时，己方的Client 向对方的Server 发送信息，对方的Client 向己方的Server 发送信息。两端都存储棋盘信息，通过通信保持棋盘信息的一致。 然后呢，应该是一端点击界面移子之后，应该能通知对方进行相同的移动。 综合以上两点，运行过程应该是这样的： 当在界面上点击棋子时，先判断当前是否轮到自己落子，如果是，则进行移动，更新界面，并通过Client 向对方Server 发送移动信息。对方Server 收到后，进行同样的移动，更新界面。 这里要求Server能随时接到对方发来的消息，所以Server的监听应该是一个额外的线程。 2.接下来的问题是怎么表示，怎么存储？ 棋盘，应该用二维数组存储比较好，数组坐标（以下所说的”数组坐标 “是指该二维数组中的一个(x,y)数对）对应棋盘坐标。那么数组里存储什么呢，一共有車、马、象、士、将、砲、卒七种棋子，那么设置一个棋子类作为基类，然后设置七个类继承棋子类？基类有一个move函数，每个子类重写该函数？但是移动似乎只是我程序的一小部分，这样似乎没必要。 那么存储整型数值？不同的数值代表不同的棋子？似乎可以。 那么就用7个数代替七种棋子，但是棋子有黑白色，要用一个数表示棋子类型（即是車、马或其他）和棋子颜色两个信息，那就用BLANK =8代表空子，黑方的車、马、象、士、将、砲、卒分别为1到7，白方的車、马、相、士、帅、炮、兵分别为9到15。 这样判断某数组坐标上棋子的颜色，就把其值与BLANK 比较，大于BLANK为白色，否则为黑色。 判断某数组坐标上棋子的类型，则将其值模BLANK 。 另外，因为下棋双方的视角是相反的，所以，棋盘在存储时应该是相反的，移动时的坐标也应该进行转换。 3.然后应该怎么通信呢？ 我希望这个程序打开后，就能找到对方，并确定谁是黑色，谁是白色。 也许可以让Client 在运行之后就对局域网进行端口扫描，然后给出正在运行此程序的IP 地址列表，让用户选择要连接到哪个，如果对方已经有了连接，则对方会拒绝此连接，如果对方没有连接，则对方程序会向对方用户提示该连接请求，如果，对方用户同意，则连接建立，否则依然是拒绝此连接。 但是，我没有采用以上所述方法（因为太复杂，我还是先做好主体工作吧=_=）。 所以在程序开始运行后，会让用户输入对方的IP 地址，然后Server 开始监听。之后Client 开始向对方发出连接请求。 Server 监听时，如果收到连接请求，就看对方的IP 地址是否是用户输入的IP 地址，如果不是，说明连接请求不是用户所希望的对方发送的，那就继续监听。 Client 请求连接时，如果对方同意了，就要开始确定自己的颜色了。 确定颜色这里困扰了我很久，最后采用的解决方法是这样的：&gt; 核心思想就是谁先发出连接请求，谁就是黑色。&gt; 也就是在Client 连接上对方之后，要判断Server 是不是已经连接了对方，如果Server 已连接，就说明是对方先发出的连接请求，那么对方就是黑色，自己就设为白色。如果Server 没有连接，就说明自己先连接上了对方，也就是自己是黑色。 以上就是编码前及编码时的大致想法。代码main.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341#if defined(UNICODE) &amp;&amp; !defined(_UNICODE)#define _UNICODE#elif defined(_UNICODE) &amp;&amp; !defined(UNICODE)#define UNICODE#endif#include &lt;tchar.h&gt;#include &lt;windows.h&gt;#include &lt;pthread.h&gt;#include "chinese_chess.h"#include "Server.h"#include "Client.h"#define WIDTH 400 //界面宽度#define HEIGHT 400 //界面高度#define ZERO_X 50 //棋盘左边界#define ZERO_Y 50 //棋盘上边界#define PIECE_BKCOLOR RGB(175,143,89) //棋子背景色#define PIECE_WH 30 //棋盘每个格子的宽度和高度HWND hwnd; /* This is the handle for our window */char* ots_ip; //存储对方IP地址的字符串int port;bool is_connect_alive=false; //是否连接到对方Board * chess_board; //棋盘Server *server;Client *client;int chess_sx=-1; //移动起始位置的数组坐标int chess_sy=-1;int chess_dx=-1; //移动目标位置的数组坐标int chess_dy=-1;/* Declare Windows procedure */LRESULT CALLBACK WindowProcedure (HWND, UINT, WPARAM, LPARAM);/* Make the class name into a global variable */TCHAR szClassName[ ] = _T("Chinese Chess");int WINAPI WinMain (HINSTANCE hThisInstance, HINSTANCE hPrevInstance, LPSTR lpszArgument, int nCmdShow) &#123; MSG messages; /* Here messages to the application are saved */ WNDCLASSEX wincl; /* Data structure for the windowclass */ /* The Window structure */ wincl.hInstance = hThisInstance; wincl.lpszClassName = szClassName; wincl.lpfnWndProc = WindowProcedure; /* This function is called by windows */ wincl.style = CS_DBLCLKS; /* Catch double-clicks */ wincl.cbSize = sizeof (WNDCLASSEX); /* Use default icon and mouse-pointer */ wincl.hIcon = LoadIcon (NULL, IDI_APPLICATION); wincl.hIconSm = LoadIcon (NULL, IDI_APPLICATION); wincl.hCursor = LoadCursor (NULL, IDC_ARROW); wincl.lpszMenuName = NULL; /* No menu */ wincl.cbClsExtra = 0; /* No extra bytes after the window class */ wincl.cbWndExtra = 0; /* structure or the window instance */ /* Use Windows's default colour as the background of the window */ wincl.hbrBackground = (HBRUSH) COLOR_BACKGROUND; /* Register the window class, and if it fails quit the program */ if (!RegisterClassEx (&amp;wincl)) return 0; /* The class is registered, let's create the program*/ hwnd = CreateWindowEx ( 0, /* Extended possibilites for variation */ szClassName, /* Classname */ _T("Chinese Chess"), /* Title Text */ WS_OVERLAPPEDWINDOW, /* default window */ CW_USEDEFAULT, /* Windows decides the position */ CW_USEDEFAULT, /* where the window ends up on the screen */ WIDTH, /* The programs width */ HEIGHT, /* and height in pixels */ HWND_DESKTOP, /* The window is a child-window to desktop */ NULL, /* No menu */ hThisInstance, /* Program Instance handler */ NULL /* No Window Creation data */ ); /* Make the window visible on the screen */ ShowWindow (hwnd, nCmdShow); /* Run the message loop. It will run until GetMessage() returns 0 */ while (GetMessage (&amp;messages, NULL, 0, 0)) &#123; /* Translate virtual-key messages into character messages */ TranslateMessage(&amp;messages); /* Send message to WindowProcedure */ DispatchMessage(&amp;messages); &#125; /* The program return-value is 0 - The value that PostQuitMessage() gave */ return messages.wParam;&#125;//把数组坐标转换为界面坐标void xy_to_pixel(int x,int y,int*pixelx,int *pixely) &#123; *pixely=x*PIECE_WH+ZERO_Y; *pixelx=y*PIECE_WH+ZERO_X;&#125;//把界面坐标转换为数组坐标void pixel_to_xy(int pixelx,int pixely,int*x,int *y) &#123; int r=PIECE_WH/2; *y=(pixelx-(ZERO_X-r))/PIECE_WH; *x=(pixely-(ZERO_Y-r))/PIECE_WH;&#125;//以数组坐标画线void draw_line(HDC hdc,int sx,int sy,int dx,int dy) &#123; int psx,psy,pdx,pdy; xy_to_pixel(sx,sy,&amp;psx,&amp;psy); xy_to_pixel(dx,dy,&amp;pdx,&amp;pdy); MoveToEx (hdc, psx,psy, NULL) ; LineTo (hdc, pdx, pdy) ;&#125;//以数组坐标画棋子void paint_piece(HDC hdc,int x,int y,int color,int type) &#123; static HBRUSH piece_brush =CreateSolidBrush (PIECE_BKCOLOR); //棋子的背景色 if(type==0||color==BLANK)return ; int px,py; xy_to_pixel(x,y,&amp;px,&amp;py); int r=PIECE_WH/2; SelectObject (hdc,piece_brush ) ; Ellipse(hdc,px-r,py-r,px+r,py+r); char *text=new char[5]; switch(type) &#123; case JU: strcpy(text,"車"); break; case MA: strcpy(text,"马"); break; case XIANG: if(color==BLACK)strcpy(text,"象"); else strcpy(text,"相"); break; case SHI: strcpy(text,"士"); break; case JIANG: if(color==BLACK)strcpy(text,"将"); else strcpy(text,"帅"); break; case PAO: if(color==BLACK)strcpy(text,"砲"); else strcpy(text,"炮"); break; case ZU: if(color==BLACK)strcpy(text,"卒"); else strcpy(text,"兵"); break; default: strcpy(text,""); &#125; SetBkColor(hdc,PIECE_BKCOLOR);//设置文字背景色 if(color==BLACK) &#123; SetTextColor(hdc,RGB(0,0,0)); //设置文字颜色 &#125; else &#123; SetTextColor(hdc,RGB(255,255,255)); &#125; TextOut (hdc, px-r/2, py-r/2,text , strlen("马")) ; delete text;&#125;void* main_listen(void *) &#123; server-&gt;listen_message(); return 0;&#125;//创建线程，使server开始监听bool start_listen() &#123; pthread_t listen_p; int ret; ret= pthread_create( &amp;listen_p, NULL, main_listen,NULL ); // if( ret != 0 ) &#123; //创建线程成功返回0 //printf("pthread_create error:error_code=%d\n",ret ); handle_error(THREAD_ERROR,true,true); return false; &#125; return true;&#125;void* chess_connect(void *) &#123; server=new Server();//创建Server对象 client=new Client(); //创建Client对象， start_listen(); //创建线程，server开始监听 //Sleep(100); client-&gt;connect_to_ots(); //client开始连接对方server，连接成功后返回 InvalidateRect(hwnd,NULL,true);&#125;void init() &#123; pthread_t connect_p; int ret; ret= pthread_create( &amp;connect_p, NULL, chess_connect,NULL); // if( ret != 0 ) &#123; //创建线程成功返回0 //printf("pthread_create error:error_code=%d\n",ret ); handle_error(THREAD_ERROR,true,true); return ; &#125;&#125;/* This function is called by the Windows function DispatchMessage() */LRESULT CALLBACK WindowProcedure (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) &#123; static POINT mouse; static HDC hdc; static PAINTSTRUCT ps ; static int iofip=0; //index of ots_ip switch (message) &#123; /* handle the messages */ case WM_CREATE: &#123; port=35536; ots_ip=new char[20]; strcpy(ots_ip,""); &#125; break; case WM_KEYDOWN://识别按键，显示输入的内容（对方IP地址） if(wParam==13) &#123;//如果是ENTER，则初始化server、client，并开始连接，连接成功后初始化board init(); Sleep(100); InvalidateRect(hwnd,NULL,true); &#125; if(wParam==VK_BACK) &#123;//删除键 if(iofip==0)return 0; iofip--; ots_ip[iofip]='\0'; &#125; if(wParam&lt;106&amp;&amp;wParam&gt;95) &#123;//小键盘数字键 wParam-=48; &#125; if(wParam&lt;58&amp;&amp;wParam&gt;47) &#123;//主键盘数字键 ots_ip[iofip]='0'-48+wParam; iofip++; ots_ip[iofip]='\0'; &#125; if(wParam==110||wParam==229) &#123;//小数点键，小键盘110，主键盘229 ots_ip[iofip]='.'; iofip++; ots_ip[iofip]='\0'; &#125; InvalidateRect(hwnd,NULL,true); break; case WM_PAINT: &#123; hdc=BeginPaint (hwnd,&amp;ps) ; SetBkColor(hdc,RGB(200,200,200)); if(chess_board==NULL) &#123;//显示输入的IP地址 char tip[20]="请输入对方IP地址："; Rectangle(hdc,WIDTH/5-20,HEIGHT/2-10,WIDTH/5*4,HEIGHT/2+20); TextOut(hdc,WIDTH/5,HEIGHT/2-50,tip,strlen(tip)); TextOut(hdc,WIDTH/5,HEIGHT/2,ots_ip,strlen(ots_ip)); if(server!=NULL) &#123; //board==NULL而server!=NULL表示正在连接过程中 char tip[20]="正在连接......"; TextOut(hdc,WIDTH/5,HEIGHT/2+50,tip,strlen(tip)); &#125; EndPaint(hwnd,&amp;ps); break; &#125; char text[10]="你的颜色:"; if(chess_board-&gt;get_color()==BLACK) &#123; strcat(text," 黑"); &#125; else &#123; strcat(text," 白"); &#125; TextOut (hdc, 0, 0,text , strlen(text)) ; int M=chess_board-&gt;get_M(); int N=chess_board-&gt;get_N(); //画棋盘 for(int i=0; i&lt;M; i++) &#123; draw_line(hdc,i,0,i,N-1); &#125; for(int i=0; i&lt;N; i++) &#123; draw_line(hdc,0,i,N/2,i); &#125; for(int i=0; i&lt;N; i++) &#123; draw_line(hdc,N/2+1,i,N,i); &#125; draw_line(hdc,0,3,2,5); draw_line(hdc,0,5,2,3); draw_line(hdc,9,3,7,5); draw_line(hdc,7,3,9,5); draw_line(hdc,4,0,5,0); draw_line(hdc,4,8,5,8); //画棋子 for(int i=0; i&lt;M; i++) &#123; for(int j=0; j&lt;N; j++) &#123; paint_piece(hdc,i,j,chess_board-&gt;get_color(i,j),chess_board-&gt;get_type(i,j)); &#125; &#125; EndPaint(hwnd,&amp;ps); &#125; break; case WM_LBUTTONUP: &#123; if(chess_board==NULL)break; if(!chess_board-&gt;is_my_turn())break;//当前没轮到自己下棋 GetCursorPos(&amp;mouse);//获取鼠标的屏幕坐标 ScreenToClient(hwnd,&amp;mouse);//转换为界面坐标 int x,y; pixel_to_xy(mouse.x,mouse.y,&amp;x,&amp;y);//转换为数组坐标 if(chess_board-&gt;get_color(x,y)==chess_board-&gt;get_color()) &#123;//点击的是自己的棋子 chess_sx=x; chess_sy=y; break; &#125; if(chess_sx==-1||chess_sy==-1) &#123;//起始坐标未赋值且点击的不是自己的棋子，则break break; &#125; chess_dx=x; chess_dy=y; if(chess_board-&gt;my_move_piece(chess_sx,chess_sy,chess_dx,chess_dy)) &#123; //如果移动棋子合法 client-&gt;send_message("move",chess_sx,chess_sy,chess_dx,chess_dy); //向对方发送移子信息 InvalidateRect(hwnd,NULL,true); if(chess_board-&gt;get_is_win()==WIN) &#123; chess_board-&gt;init();//重新初始化棋盘，重下一盘 MessageBox(hwnd,"你赢了","获胜！",NULL); InvalidateRect(hwnd,NULL,true); &#125; &#125; chess_sx=-1; chess_sy=-1; break; &#125; case WM_DESTROY: if(server!=NULL)server-&gt;close(); if(client!=NULL)client-&gt;close(); PostQuitMessage (0); /* send a WM_QUIT to the message queue */ break; default: /* for messages that we don't deal with */ return DefWindowProc (hwnd, message, wParam, lParam); &#125; return 0;&#125; chinese_chess.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250#ifndef CHINESE_CHESS_H_INCLUDED#define CHINESE_CHESS_H_INCLUDED#define JU 1#define MA 2#define XIANG 3#define SHI 4#define JIANG 5#define PAO 6#define ZU 7#define BLANK 8 //空子#define BLACK -1#define WHITE 1#define WIN 1#define LOSE -1class Board &#123;private: bool turn; //是否轮到自己下棋 int color; //自己的颜色 int M,N; //棋盘行数、列数 int **b; //二维数组 int is_win; //是否胜利 bool is_out(int x,int y) &#123;//坐标是否出界 return x&gt;M||y&gt;N||x&lt;0||y&lt;0; &#125; bool is_same_color(int sx,int sy,int dx,int dy) &#123;//源坐标与目的坐标是否是同一颜色 return get_color(sx,sy)==get_color(dx,dy); &#125; void swap_num(int &amp; num1,int&amp; num2) &#123;//交换两个数 num1+=num2; num2=num1-num2; num1=num1-num2; &#125; int get_abs(int num) &#123;//取得绝对值 return num&gt;=0?num:-num; &#125; int num_of_not_blank_betweenn(int sx,int sy,int dx,int dy) &#123;//返回在起始坐标和目的坐标之间棋子的个数 if(!(sx==dx||sy==dy))return -1; int num=0; if(sy&gt;dy)swap_num(sy,dy); if(sx&gt;dx)swap_num(sx,dx); if(sx==dx) &#123; for(int i=sy+1; i&lt;dy; i++) &#123; if(b[sx][i]!=BLANK)num++; &#125; &#125; if(sy==dy) &#123; for(int i=sx+1; i&lt;dx; i++) &#123; if(b[i][sy]!=BLANK)num++; &#125; &#125; return num; &#125; bool is_correct_move_JU(int sx,int sy,int dx,int dy) &#123; return num_of_not_blank_betweenn(sx,sy,dx,dy)==0; &#125; bool is_correct_move_MA(int sx,int sy,int dx,int dy) &#123; int x=dx-sx,y=dy-sy; if(get_abs(x)==2&amp;&amp;get_abs(y)==1) &#123; if(get_color(sx+x/2,sy)==BLANK)return true;//硌马蹄检测 &#125; if(get_abs(x)==1&amp;&amp;get_abs(y)==2) &#123; if(get_color(sx,sy+y/2)==BLANK)return true;//硌马蹄检测 &#125; return false; &#125; bool is_correct_move_XIANG(int sx,int sy,int dx,int dy) &#123; int x=dx-sx,y=dy-sy; if(!(get_abs(x)==2&amp;&amp;get_abs(y)==2)) return false; if(get_color(sx+x/2,sy+y/2)==BLANK)return true;//硌象蹄检测 return false; &#125; bool is_correct_move_SHI(int sx,int sy,int dx,int dy) &#123; int x=dx-sx,y=dy-sy; if(!(get_abs(x)==1&amp;&amp;get_abs(y)==1)) return false; if(dx&lt;7)return false; if(dy&lt;3||dy&gt;5)return false; return true; &#125; bool is_correct_move_JIANG(int sx,int sy,int dx,int dy) &#123; int x=dx-sx,y=dy-sy; if(!((get_abs(x)==1&amp;&amp;get_abs(y)==0)||(get_abs(x)==0&amp;&amp;get_abs(y)==1))) return false; if(dx&lt;7)return false; if(dy&lt;3||dy&gt;5)return false; for(int i=0; i&lt;3; i++) &#123;//明将检测 if(get_type(i,dy)==JIANG) &#123; if(num_of_not_blank_betweenn(dx,dy,i,dy)==0) return false; return true; &#125; &#125; return true; &#125; bool is_correct_move_PAO(int sx,int sy,int dx,int dy) &#123; int n=get_color(dx,dy)==BLANK?0:1; return num_of_not_blank_betweenn(sx,sy,dx,dy)==n; &#125; bool is_correct_move_ZU(int sx,int sy,int dx,int dy) &#123; if(dx&gt;sx)return false; int x=dx-sx,y=dy-sy; if(get_abs(x)+get_abs(y)!=1)return false; if(sx&gt;4&amp;&amp;get_abs(x)!=1)return false;//过河前只能向前走 return true; &#125; bool is_correct_move(int sx,int sy,int dx,int dy) &#123; if(sx==dx&amp;&amp;sy==dy) &#123; return false; &#125; if(is_out(sx,sy)||is_out(dx,dy)) &#123; return false; &#125; if(get_color(sx,sy)!=color) &#123; return false; &#125; if(is_same_color(sx,sy,dx,dy)) &#123; return false; &#125; switch(get_type(sx,sy)) &#123; case JU: return is_correct_move_JU(sx,sy,dx,dy); case MA: return is_correct_move_MA(sx,sy,dx,dy); case XIANG: return is_correct_move_XIANG(sx,sy,dx,dy); case SHI: return is_correct_move_SHI(sx,sy,dx,dy); case JIANG: return is_correct_move_JIANG(sx,sy,dx,dy); case PAO: return is_correct_move_PAO(sx,sy,dx,dy); case ZU: return is_correct_move_ZU(sx,sy,dx,dy); default: return false; &#125; &#125; void move_s_to_d(int sx,int sy,int dx,int dy) &#123; //移动操作 if(get_type(dx,dy)==JIANG) &#123; //如果目的棋子是将 if(get_color(dx,dy)==color)set_win(LOSE);//如果是自己的将，则输 else set_win(WIN);//如果是对方的将，则赢 &#125; b[dx][dy]=b[sx][sy]; b[sx][sy]=BLANK; change_turn(); &#125; void init_pieces() &#123; for(int i=0; i&lt;M; i+=M-1) &#123;//第一行和最后一行（即车马象士将士象马车） for(int index=0; index&lt;N; index++) &#123; if(index&lt;N/2+1)b[i][index]=index+1; else b[i][index]=N-index; &#125; &#125; //卒所在的行 for(int index=0; index&lt;N; index+=2) &#123; b[3][index]=ZU; &#125; for(int index=0; index&lt;N; index+=2) &#123; b[6][index]=ZU; &#125; b[2][1]=PAO; b[M-1-2][1]=PAO; b[2][N-1-1]=PAO; b[M-1-2][N-1-1]=PAO; int s,d;//存储起始行和终点行 if(color==BLACK) &#123; s=0;//从0行到M/2行，即棋盘上半部分 d=M/2; &#125; else &#123; s=M/2;//棋盘下半部分 d=M; &#125; //从s行到d行，把非BLANK的值加BLANK，使小于BLANK的代表黑色棋，大于BLANK的代表白色棋 for(int index=s; index&lt;d; index++) &#123; for(int j=0; j&lt;N; j++) &#123; if(b[index][j]!=BLANK) &#123; b[index][j]+=BLANK; &#125; &#125; &#125; &#125;public: Board(int c) &#123; color=c; M=10; N=9; b=new int*[M]; for(int i=0; i&lt;M; i++) &#123; b[i]=new int[N]; &#125; init(); &#125; void init() &#123;//棋盘初始化 is_win=0; turn=color==BLACK?true:false; for(int i=0; i&lt;M; i++) &#123; for(int j=0; j&lt;N; j++) &#123; b[i][j]=BLANK; &#125; &#125; init_pieces(); &#125; int get_M() &#123; return M; &#125; int get_N() &#123; return N; &#125; int get_color() &#123;//获取己方的颜色 return color; &#125; int get_color(int x,int y) &#123;//获取棋盘某一坐标上棋子的颜色 return b[x][y]&gt;BLANK?WHITE:b[x][y]&lt;BLANK?BLACK:BLANK; &#125; int get_type(int x,int y) &#123;//获取棋子类型（空、车、马、象、士、将、炮、卒） return b[x][y]!=BLANK?b[x][y]%BLANK:BLANK; &#125; void set_win(int is) &#123; is_win=is; &#125; int get_is_win() &#123; return is_win; &#125; void change_turn() &#123; turn=turn==true?false:true; &#125; bool is_my_turn() &#123; return turn; &#125; void othside_move_piece(int sx,int sy,int dx,int dy) &#123;//对方移子 sx=M-1-sx;//先进行坐标转换，因对方视角与己方相反 sy=N-1-sy; dx=M-1-dx; dy=N-1-dy; move_s_to_d(sx,sy,dx,dy); &#125; bool my_move_piece(int sx,int sy,int dx,int dy) &#123; //己方主动移子 if(!is_correct_move(sx,sy,dx,dy))return false; move_s_to_d(sx,sy,dx,dy); return true; &#125;&#125;;#endif // CHINESE_CHESS_H_INCLUDED Server.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#ifndef SERVER_H_INCLUDED#define SERVER_H_INCLUDED#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;errno.h&gt;#include &lt;winsock2.h&gt;#include"chinese_chess.h"#define INIT_ERROR 1#define BIND_ERROR 2#define LISTEN_ERROR 3#define CONNECT_ERROR 4#define SEND_ERROR 5#define ACCEPT_ERROR 6#define ALIVE_ERROR 7#define THREAD_ERROR 8int error_num;extern HWND hwnd;extern Board* chess_board;extern char* ots_ip;extern int port;extern bool is_connect_alive;//线程参数结构体typedef struct server_args &#123; SOCKET* Com_Sock; char * rebuf;&#125; server_args;//校验检测，与客户端的添加校验是相反操作//最后一位之前的所有字符相加取模后，如果等于最后一个字符，则校验通过bool server_check(char * r) &#123; int len=strlen(r); len--; int s=0; for(int i=0; i&lt;len; i++) &#123; s+=r[i]; &#125; if(r[len]==(s%5+'0')) &#123; r[len]='\0'; return true; &#125; return false;&#125;//错误处理，is_tell控制是否显示错误信息，is_exit控制是否退出程序int handle_error(int err,bool is_tell,bool is_exit) &#123; error_num=err; if(!is_tell)return error_num; char error[30]=""; switch(error_num) &#123; case INIT_ERROR: strcpy(error,"初始化错误"); break; case BIND_ERROR: strcpy(error,"绑定端口错误"); break; case LISTEN_ERROR: strcpy(error,"监听错误"); break; case ACCEPT_ERROR: strcpy(error,"接受连接错误"); break; case CONNECT_ERROR: strcpy(error,"无法连接"); break; case ALIVE_ERROR: strcpy(error,"连接已断开"); break; case THREAD_ERROR: strcpy(error,"线程无法创建"); break; case SEND_ERROR: strcpy(error,"发送错误"); &#125; char error_message[50]; strcpy(error_message,"错误："); strcat(error_message,error); if(is_exit)strcat(error_message,"\n程序将退出。"); MessageBox(hwnd,error_message,"错误",MB_OK); if(is_exit)exit(0); return error_num;&#125;void* handle_message(void*ar) &#123; server_args * serarg=(server_args * )ar; char *recv=serarg-&gt;rebuf; SOCKET* CommandSock=serarg-&gt;Com_Sock; if(server_check(recv)) &#123;//校验通过发送okok（OK），不通过发送noto（NOTOK） send(*CommandSock,"okok",4,0); &#125; else &#123; send(*CommandSock,"noto",4,0); return ar; &#125; if(strncmp(recv,"move",4)==0) &#123; char * pch; //将recvBuf以逗号拆分 pch = strtok (recv,","); pch = strtok (NULL,","); int xys[4]; int index=0; while (pch != NULL) &#123; xys[index]=atoi(pch);//char* 转换为int index++; pch = strtok (NULL, ","); &#125; chess_board-&gt;othside_move_piece(xys[0],xys[1],xys[2],xys[3]); if(chess_board-&gt;get_is_win()==LOSE) &#123; chess_board-&gt;init();//如果输了，则重新初始化棋盘，再下一盘 MessageBox(hwnd,"你输了","失败！",NULL); &#125; InvalidateRect(hwnd,NULL,true); &#125; delete recv;&#125;class Server &#123;private: SOCKET Server_Sock; SOCKADDR_IN server_addr; SOCKADDR_IN client_addr; char recvBuf[20];public: Server() &#123; WSADATA wsa; /*初始化socket资源*/ if (WSAStartup(MAKEWORD(1,1),&amp;wsa) != 0) &#123; handle_error(INIT_ERROR,true,true); return; &#125; if((Server_Sock = socket(AF_INET, SOCK_STREAM, 0))==-1) &#123; handle_error(INIT_ERROR,true,true); return; &#125; ZeroMemory((char *)&amp;server_addr,sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port); /*本地监听端口*/ server_addr.sin_addr.s_addr = htonl(INADDR_ANY); /*有IP*/ if(bind(Server_Sock,(struct sockaddr *)&amp;server_addr,sizeof(server_addr))==-1) &#123; handle_error(BIND_ERROR,true,true); return; &#125; if(listen(Server_Sock,5)==-1) &#123; //其中第二个参数代表能够接收的最多的连接数 handle_error(LISTEN_ERROR,true,true); return; &#125; strcpy(recvBuf,""); &#125; void listen_message() &#123; int len=sizeof(SOCKADDR); while(true) &#123; SOCKET Command_Sock = accept(Server_Sock, (SOCKADDR*)&amp;client_addr,&amp;len); if(Command_Sock == INVALID_SOCKET) &#123; closesocket(Command_Sock); handle_error(ACCEPT_ERROR,false,false); continue; &#125; if(client_addr.sin_addr.s_addr!=inet_addr(ots_ip)) &#123;//如果接收的socket不是预期的对方的，则发送wron，继续等待 send(Command_Sock,"wron",4,0); closesocket(Command_Sock); continue; &#125; send(Command_Sock,"righ",4,0); is_connect_alive=true; while(true) &#123; if(recv(Command_Sock,recvBuf,20,0)&lt;=0) &#123;//recv返回小于等于0的值，则连接已断开 handle_error(ALIVE_ERROR,true,true); closesocket(Command_Sock); close(); return ; &#125; char *rbuf=new char[20]; strcpy(rbuf,recvBuf); server_args serarg; serarg.Com_Sock=&amp;Command_Sock; serarg.rebuf=rbuf; pthread_t handle_m; int ret; ret= pthread_create( &amp;handle_m, NULL, handle_message,&amp;serarg); // if( ret != 0 ) &#123; //创建线程成功返回0 // printf("pthread_create error:error_code=%d\n",ret ); handle_error(THREAD_ERROR,true,true); return ; &#125; strcpy(recvBuf,""); &#125; closesocket(Command_Sock); &#125; &#125; void close() &#123; closesocket(Server_Sock); WSACleanup(); &#125;&#125;;#endif // SERVER_H_INCLUDED Client.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#ifndef CLIENT_H_INCLUDED#define CLIENT_H_INCLUDED#include &lt;stdio.h&gt;#include &lt;winsock2.h&gt;#include"chinese_chess.h"//为字符串添加校验信息，对所有字符求和，模5之后转化为字符放在字符串最后void client_check(char* r) &#123; int len=strlen(r); int s=0; for(int i=0; i&lt;len; i++) &#123; s+=r[i]; &#125; r[len]=s%5+'0'; r[len+1]='\0';&#125;class Client &#123;private: SOCKET Client_Sock; SOCKADDR_IN server_addr; char sendBuf[20];public: Client() &#123; WSADATA wsa; /*初始化socket资源*/ if (WSAStartup(MAKEWORD(1,1),&amp;wsa) != 0) &#123; handle_error(INIT_ERROR,true,true); return; //代表失败 &#125; if((Client_Sock = socket(AF_INET, SOCK_STREAM, 0))==-1) &#123; handle_error(INIT_ERROR,true,true); return; //代表失败 &#125; server_addr.sin_addr.S_un.S_addr=inet_addr(ots_ip); server_addr.sin_family=AF_INET; server_addr.sin_port=htons(port); strcpy(sendBuf,""); &#125; void connect_to_ots() &#123; while(connect(Client_Sock,(SOCKADDR*)&amp;server_addr,sizeof(SOCKADDR)) ==-1) &#123; handle_error(CONNECT_ERROR,false,false); Sleep(100); //printf( "%d ", WSAGetLastError()); &#125; char rec[5]; recv(Client_Sock,rec,4,0); if(strncmp(rec,"wron",4)==0) &#123; //收到wrong，说明对方所输入的IP不是己方IP MessageBox(hwnd,"对方输入的IP不是你\n程序将退出","错误",NULL); exit(-1); &#125; //谁先连接谁是黑色 //如果server已经收到连接，则说明是对方先连接自己，则自己应为白色，否则自己是黑色 if(is_connect_alive) &#123; chess_board=new Board(WHITE); &#125; else &#123; chess_board=new Board(BLACK); &#125; &#125; void close() &#123; closesocket(Client_Sock); WSACleanup(); &#125; int send_message(char * message) &#123; strcpy(sendBuf,message); client_check(sendBuf); int len; int try_time=0; while(true) &#123; len=send(Client_Sock,sendBuf,strlen(sendBuf)+1,0); if(len!=(strlen(sendBuf)+1)) &#123; handle_error(SEND_ERROR,false,false); //printf( "%d ", WSAGetLastError()); &#125; char rec[5]; recv(Client_Sock,rec,4,0); if(strncmp(rec,"okok",4)==0) &#123;//收到OK说明数据已经正确被对方收到 break; &#125; if(try_time&gt;20) &#123; //尝试20次，数据仍无法正确送达，则退出 handle_error(SEND_ERROR,true,true); &#125; try_time++; &#125; return len; &#125; int send_message(const char * message,int sx,int sy,int dx,int dy) &#123; char* message_temp=new char[20]; sprintf(message_temp,"%s,%d,%d,%d,%d,",message,sx,sy,dx,dy); int len=send_message(message_temp); delete message_temp; return len; &#125;&#125;;#endif // CLIENT_H_INCLUDED 该程序从3.15晚开始，用了四天的空闲时间。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Socket服务端和客户端（C++，CodeBlocks+GCC编译）]]></title>
      <url>2016%2F03%2F20%2Fsocket%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
      <content type="text"><![CDATA[12345678910111213141516171819202122232425//main.cpp#include "j_socket.h"#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;static int port=21;j_server* ser;void* main_listen( void* args)&#123; ser=new j_server(port); ser-&gt;j_listen();&#125;int main()&#123; static pthread_t listen_p; int ret; ret= pthread_create( &amp;listen_p, NULL, main_listen, NULL ); //参数：创建的线程id，线程参数，线程运行函数的起始地址，运行函数的参数 if( ret != 0 ) //创建线程成功返回0 &#123; printf("pthread_create error:error_code=%d\n",ret ); &#125; static j_client* cli; cli =new j_client("127.0.0.1",port); cli-&gt;j_send(); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161//j_socket.h#ifndef J_SOCKET_H_INCLUDED#define J_SOCKET_H_INCLUDED#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;winsock2.h&gt;#include &lt;pthread.h&gt;#define INIT_ERROR 1#define BIND_ERROR 2#define LISTEN_ERROR 3struct rec_args&#123;int * l;SOCKET* s;&#125;;void* receive( void* args)&#123; char recvBuf[512]; rec_args *a=(rec_args*)args; while(true) &#123; recv(*(a-&gt;s),recvBuf,512,0); printf("receive message: %s\n",recvBuf); printf("111111\n"); if(strcmp(recvBuf,"end")==0)&#123;break;&#125; &#125; closesocket(*(a-&gt;s)); (*(a-&gt;l))--; printf("22222\n"); return NULL;&#125;class j_server&#123;private: SOCKET Server_Sock; SOCKADDR_IN server_addr; SOCKADDR_IN client_addr; int max_num; int link_num=0; int error_num;public: j_server(int port) &#123; WSADATA wsa; /*初始化socket资源*/ if (WSAStartup(MAKEWORD(1,1),&amp;wsa) != 0) &#123; error_num=INIT_ERROR; return; &#125; if((Server_Sock = socket(AF_INET, SOCK_STREAM, 0))==-1) &#123; error_num=INIT_ERROR; return; &#125; ZeroMemory((char *)&amp;server_addr,sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port); /*本地监听端口*/ server_addr.sin_addr.s_addr = htonl(INADDR_ANY); /*有IP*/ if(bind(Server_Sock,(struct sockaddr *)&amp;server_addr,sizeof(server_addr))==-1) &#123; error_num=BIND_ERROR; return; &#125; if(listen(Server_Sock,5)==-1) //其中第二个参数代表能够接收的最多的连接数 &#123; error_num=LISTEN_ERROR; return; &#125; max_num=20; &#125; int j_listen() &#123; int len=sizeof(SOCKADDR); while(true) &#123; if(link_num&gt;max_num) &#123; Sleep(100); continue; &#125; SOCKET Command_Sock = accept(Server_Sock, (SOCKADDR*)&amp;client_addr,&amp;len); if(Command_Sock == INVALID_SOCKET) &#123; printf("accept error !"); closesocket(Command_Sock); &#125; link_num++; pthread_t listen_p; int ret; rec_args a; a.l=&amp;link_num; a.s=&amp;Command_Sock; ret= pthread_create( &amp;listen_p, NULL, receive,(void *)&amp;a ); //参数：创建的线程id，线程参数，线程运行函数的起始地址，运行函数的参数 &#125; return 0; &#125;&#125;;class j_client&#123;private: SOCKET Client_Sock; SOCKADDR_IN server_addr; char sendBuf[512]; int error_num;public: j_client(char * server_addr_str,int port) &#123; WSADATA wsa; /*初始化socket资源*/ if (WSAStartup(MAKEWORD(1,1),&amp;wsa) != 0) &#123; error_num=INIT_ERROR; return; //代表失败 &#125; if((Client_Sock = socket(AF_INET, SOCK_STREAM, 0))==-1) &#123; error_num=INIT_ERROR; return; //代表失败 &#125; server_addr.sin_addr.S_un.S_addr=inet_addr(server_addr_str); server_addr.sin_family=AF_INET; server_addr.sin_port=htons(port); if(connect(Client_Sock,(SOCKADDR*)&amp;server_addr,sizeof(SOCKADDR)) ==-1) &#123; printf("connect error !"); //printf( "%d ", WSAGetLastError()); &#125; &#125; int j_send() &#123; while(true) &#123; printf("input message: "); scanf("%s",sendBuf); if(send(Client_Sock,sendBuf,strlen(sendBuf)+1,0)!=(strlen(sendBuf)+1)) &#123; printf("send error !"); //printf( "%d ", WSAGetLastError()); &#125; &#125; return 0; &#125; int j_close() &#123; closesocket(Client_Sock); WSACleanup(); &#125;&#125;;#endif // J_SOCKET_H_INCLUDED]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Shell（C++实现，CodeBlocks+GCC编译）]]></title>
      <url>2016%2F03%2F20%2FShell%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[程序效果： 只实现了login 、cd 、ls 、cat 四个命令。而且只能在 Windows 下运行。 代码：12345678910111213141516171819202122232425262728293031323334353637//main.cpp#include &lt;iostream&gt;#include "shell.h"using namespace std;int com_to_int(int com_num,char * command,char** coms)&#123; return -1;&#125;int main()&#123; const int COM_NUM=5; char command[MAX_LENGTH_OF_COMMAND]; char *coms[COM_NUM]=&#123;"login","ls","cd","cat","exit"&#125;; int (*func_ptrs[COM_NUM])(char *)=&#123;login,ls,cd,cat,shellexit&#125;; while(true)&#123; printf("%s%s%s%s%s","[",USER_NAME," ",GLOBLE_PATH,"]"); gets(command); if(strcmp(command,"")==0)&#123; continue; &#125; //printf("command: %s\n",command); //printf("command: %s\n",command); int i; for(i=0;i&lt;COM_NUM;i++)&#123; if(strncmp(coms[i],command,strlen(coms[i]))==0)&#123; func_ptrs[i](command); break; &#125; &#125; if(i==COM_NUM)&#123; printf("command not found.\n"); &#125; &#125; cd("C:/0"); ls(GLOBLE_PATH); return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178//shell.h#ifndef SHELL_H_INCLUDED#define SHELL_H_INCLUDED#include&lt;io.h&gt;#include&lt;string.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define MAX_LENGTH_OF_PATH 256#define MAX_LENGTH_OF_USERNAME 50#define MAX_LENGTH_OF_COMMAND 50#define MAX_LENGTH_OF_LINE 256char GLOBLE_PATH[MAX_LENGTH_OF_PATH]= &#123;'C',':','/','0','\0'&#125;;char USER_NAME[MAX_LENGTH_OF_USERNAME]= &#123;'g','u','e','s','t','\0'&#125;;int login(char * command)&#123; printf("user name:"); char username[MAX_LENGTH_OF_USERNAME]; gets(username); FILE * pwd; pwd = fopen ("pwd","r"); if (pwd!=NULL) &#123; char line[MAX_LENGTH_OF_LINE]; while (!feof(pwd)) &#123; if(fgets(line,MAX_LENGTH_OF_LINE,pwd)!=NULL) &#123; char * name=strtok(line," "); //printf("%s\n",name); if(strcmp(name,username)==0) &#123; char password[MAX_LENGTH_OF_USERNAME]; printf("password:"); gets(password); char * pasw=strtok(NULL," \n\r"); //printf("file password:%s\n",pasw); if(strcmp(pasw,password)==0) &#123; strcpy(USER_NAME,username); &#125; else &#123; printf("wrong password.\n"); &#125; fclose (pwd); return 0; &#125; &#125; &#125; printf("user not exist.\n"); fclose (pwd); &#125; else &#123; printf("login error.pwd file not exist or not able to open.\n"); &#125; return 0;&#125;int shellexit(char * command)&#123; exit(0); return 0;&#125;int cat_file(char * file_path)&#123; FILE* f=fopen(file_path,"r"); if(f==NULL) &#123; printf("file does not exist.\n"); return -1; &#125; char line[MAX_LENGTH_OF_LINE]; while(!feof(f)) &#123; fgets(line,MAX_LENGTH_OF_LINE,f); for(int i=0;i&lt;strlen(line);i++)&#123; if(line[i]=='\0')break; printf("%c",line[i]); &#125; &#125; printf("\n"); return 0;&#125;int cat(char * command)&#123; char * path=strtok(command," "); path=strtok(NULL," "); //printf("path:%s",path); cat_file(path); return 0;&#125;int cd_path(char *path)&#123; struct _finddata_t f; int p; //printf("1"); /* FILE * pFile; pFile = fopen (path,"r"); if (pFile!=NULL) &#123; printf("2"); &#125;printf("3");*/ if((p=_findfirst(path, &amp;f))!=-1) &#123; //printf("%d",p); //printf("2"); //printf(" %d ",f.attrib); if(f.attrib&amp;_A_SUBDIR) &#123; //printf("4"); strcpy(GLOBLE_PATH,path); return 0; &#125; else &#123; printf("destination path is not a folder.\n"); &#125; &#125; else &#123; printf("destination not exist.\n"); &#125; return -1;&#125;int cd(char * command)&#123; char * path=strtok(command," "); path=strtok(NULL," "); //printf("path:%s",path); cd_path(path); return 0;&#125;int ls_path(char * path)&#123; struct _finddata_t f; int p; char name[MAX_LENGTH_OF_PATH]; strcpy(name,path); strcat(name,"/*"); //printf("1"); if((p=_findfirst(name, &amp;f))!=-1) &#123; //read(p,filename,) //printf("2"); printf(f.name); printf("\n"); while(_findnext(p, &amp;f)==0) &#123; printf(f.name); printf("\n"); &#125; &#125; else &#123; &#125; return 0;&#125;int ls(char * command)&#123; char * path=strtok(command," "); path=strtok(NULL," "); //printf("path:%s",path); if(path==NULL||strcmp(path,"")==0) &#123; ls_path(GLOBLE_PATH); &#125; else &#123; ls_path(path); &#125; return 0;&#125;#endif // SHELL_H_INCLUDED 外部资源文件：pwd（login 命令使用）： 123ma 123456xue 123456wei 123456 程序写于大三下学期，2016年3月。 2016.4.12更新博客。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[GLine游戏（Win32GUI实现，CodeBlocks+GCC编译）]]></title>
      <url>2016%2F03%2F15%2FGlines%E6%B8%B8%E6%88%8F%2F</url>
      <content type="text"><![CDATA[游戏规则：在10X10的棋盘上有五种颜色的棋子。 点击一个棋子，再点击一个空格子，如果两者之间有一条路径的话，棋子会移动到空格子内。 每移动一次，棋盘上会增加三个棋子，其位置和颜色都是随机的。 当横向、竖向或斜向有五个或以上棋子有相同颜色时，这些棋子会消去。 当棋盘上没有空格子时，游戏结束。 得分为消去得棋子的个数。 程序效果： 代码：main.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280 //main.cpp#if defined(UNICODE) &amp;&amp; !defined(_UNICODE)#define _UNICODE#elif defined(_UNICODE) &amp;&amp; !defined(UNICODE)#define UNICODE#endif#include &lt;tchar.h&gt;#include &lt;windows.h&gt;#include "matrix.h"#include "matrix.cpp"#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;#define BKCOLOR RGB(200,200,200)int score=0;int WIDTH=400;int HEIGHT=440;Matrix ma;int width=40;//WIDTH/ma.getN();int height=40;//HEIGHT/ma.getN();PAINTSTRUCT ps ;static HBRUSH red_brush =CreateSolidBrush (RGB(230,90,90));static HBRUSH green_brush =CreateSolidBrush (RGB(90,230,90));static HBRUSH blue_brush =CreateSolidBrush (RGB(90,90,230));static HBRUSH yellow_brush =CreateSolidBrush (RGB(230,230,90));static HBRUSH purple_brush =CreateSolidBrush (RGB(230,90,230));static HBRUSH white_brush =CreateSolidBrush (BKCOLOR);Point * s_lattice=new Point(0,0),*d_lattice=new Point(0,0);bool paint_path=false;int path_color=0;Point* sou=new Point();Point* dest=new Point();Point* mouse=new Point(0,0);Point *position=new Point(0,0);Link&lt;Point *&gt;* path;HBRUSH hBrush ;HDC hdc;POINT pc;RECT client_rect;int score_height;/* Declare Windows procedure */LRESULT CALLBACK WindowProcedure (HWND, UINT, WPARAM, LPARAM);/* Make the class name into a global variable */TCHAR szClassName[ ] = _T("Game");int WINAPI WinMain (HINSTANCE hThisInstance, HINSTANCE hPrevInstance, LPSTR lpszArgument, int nCmdShow) &#123; HWND hwnd; /* This is the handle for our window */ MSG messages; /* Here messages to the application are saved */ WNDCLASSEX wincl; /* Data structure for the windowclass */ /* The Window structure */ wincl.hInstance = hThisInstance; wincl.lpszClassName = szClassName; wincl.lpfnWndProc = WindowProcedure; /* This function is called by windows */ wincl.style = CS_DBLCLKS; /* Catch double-clicks */ wincl.cbSize = sizeof (WNDCLASSEX); /* Use default icon and mouse-pointer */ wincl.hIcon = LoadIcon (NULL, IDI_APPLICATION); wincl.hIconSm = LoadIcon (NULL, IDI_APPLICATION); wincl.hCursor = LoadCursor (NULL, IDC_ARROW); wincl.lpszMenuName = NULL; /* No menu */ wincl.cbClsExtra = 0; /* No extra bytes after the window class */ wincl.cbWndExtra = 0; /* structure or the window instance */ /* Use Windows's default colour as the background of the window */ wincl.hbrBackground = (HBRUSH) COLOR_BACKGROUND; /* Register the window class, and if it fails quit the program */ if (!RegisterClassEx (&amp;wincl)) return 0; /* The class is registered, let's create the program*/ hwnd = CreateWindowEx ( 0, /* Extended possibilites for variation */ szClassName, /* Classname */ _T("GLine"), /* Title Text */ WS_OVERLAPPEDWINDOW, /* default window */ CW_USEDEFAULT, /* Windows decides the position */ CW_USEDEFAULT, /* where the window ends up on the screen */ WIDTH, /* The programs width */ HEIGHT, /* and height in pixels */ HWND_DESKTOP, /* The window is a child-window to desktop */ NULL, /* No menu */ hThisInstance, /* Program Instance handler */ NULL /* No Window Creation data */ ); /* Make the window visible on the screen */ ShowWindow (hwnd, nCmdShow); /* Run the message loop. It will run until GetMessage() returns 0 */ while (GetMessage (&amp;messages, NULL, 0, 0)) &#123; /* Translate virtual-key messages into character messages */ TranslateMessage(&amp;messages); /* Send message to WindowProcedure */ DispatchMessage(&amp;messages); &#125; /* The program return-value is 0 - The value that PostQuitMessage() gave */ return messages.wParam;&#125;int select_brush(int color,HDC hdc) &#123; switch(color) &#123; case RED: SelectObject (hdc, red_brush); break; case GREEN: SelectObject (hdc, green_brush); break; case BLUE: SelectObject (hdc, blue_brush); break; case YELLOW: SelectObject (hdc, yellow_brush); break; case PURPLE: SelectObject (hdc, purple_brush); break; default: SelectObject (hdc, white_brush); &#125; return color;&#125;void paint_lattice(Point * p,HDC hdc,int color) &#123; //-1 original color int left=p-&gt;y*width; int right=(p-&gt;y+1)*width; int top=p-&gt;x*height+score_height; int bottom=(p-&gt;x+1)*height+score_height; MoveToEx (hdc,left,top, NULL) ; LineTo (hdc,right,top) ; MoveToEx (hdc,left,top, NULL) ; LineTo (hdc,left,bottom) ; MoveToEx (hdc,right,top, NULL) ; LineTo (hdc,right,bottom) ; MoveToEx (hdc,left,bottom, NULL) ; LineTo (hdc,right,bottom) ; int paint_color; if(color!=-1) &#123; paint_color=select_brush(color,hdc); &#125; else &#123; paint_color=select_brush(ma.get_color(p),hdc); &#125; if(paint_color!=BLANK)Ellipse (hdc,left+3,top+3,right-3,bottom-3) ;&#125;void mouse_to_position() &#123; position-&gt;x=(mouse-&gt;y-score_height)/height; position-&gt;y=mouse-&gt;x/width;&#125;char *get_score_string(char* content)&#123; char *message=new char[50]; sprintf (message, "%s %d .",content,score); return message;&#125;int show_score(HWND hwnd,char* content,char* title) &#123; MessageBox(hwnd,get_score_string(content),title,NULL);&#125;void after_show_path(HWND hwnd) &#123; ma.set_flag(dest,ma.get_color(sou)); ma.set_blank(sou); ma.random_set(2); ma.eliminate(score); InvalidateRect (hwnd,NULL, true) ; if(ma.is_all_not_blank()) &#123; show_score(hwnd,"GAME OVER.Your score is","你输了"); &#125;&#125;struct args &#123; HWND hwnd; HDC hdc;&#125;;void* show_path(void* ar) &#123; path=new Link&lt;Point *&gt;(); ma.get_path(sou,dest,path); struct args* arg=(struct args*) ar; HWND hwnd=arg-&gt;hwnd; HDC hdc=arg-&gt;hdc; if(path-&gt;get_first()==NULL) &#123; return 0; &#125; //path-&gt;show_link(); path-&gt;seek_to_first(); Point* node=path-&gt;get_first(); path_color=ma.get_color(node); s_lattice=node; paint_path=true; while((node=path-&gt;get_next())!=NULL) &#123; d_lattice=node; InvalidateRect (hwnd,NULL, true) ; Sleep(300); &#125; paint_path=false; after_show_path(hwnd);&#125;void init_GUI(HWND hwnd,HDC hdc) &#123; SetBkColor(hdc,BKCOLOR); for(int i=0; i&lt;ma.getN(); i++) &#123; for(int j=0; j&lt;ma.getN(); j++) &#123; Point* p=new Point(i,j); paint_lattice(p,hdc,-1); delete p; &#125; &#125; char * score=get_score_string("You Score: "); TextOut(hdc,0,score_height/4,score,strlen(score));&#125;void sou_dest(HWND hwnd,HDC hdc) &#123; static pthread_t show_path_pth; static int ret; mouse_to_position(); if(sou!=NULL) &#123; if(ma.get_color(position)==BLANK) &#123; *dest=*position; struct args arg; arg.hdc=hdc; arg.hwnd=hwnd; ret= pthread_create( &amp;show_path_pth, NULL, &amp;show_path, &amp;arg ); //参数：创建的线程id，线程参数，线程运行函数的起始地址，运行函数的参数 if( ret != 0 ) &#123; //创建线程成功返回0 printf("pthread_create error:error_code=%d\n",ret ); &#125; &#125; else &#123; *sou=*position; &#125; &#125; else &#123; if(ma.get_color(position)!=BLANK) &#123; *sou=*position; &#125; &#125;&#125;/* This function is called by the Windows function DispatchMessage() */LRESULT CALLBACK WindowProcedure (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) &#123; switch (message) &#123; /* handle the messages */ case WM_CREATE: &#123; ma.init(); GetClientRect (hwnd, &amp;client_rect) ; WIDTH=client_rect.right-client_rect.left ; HEIGHT=client_rect.bottom-client_rect.top ; score_height=HEIGHT/10; width=WIDTH/ma.getN(); height=(HEIGHT-score_height)/ma.getN(); InvalidateRect (hwnd,NULL, true) ; &#125; break; case WM_DESTROY: PostQuitMessage (0); /* send a WM_QUIT to the message queue */ break; case WM_LBUTTONUP: &#123; GetCursorPos(&amp;pc); ScreenToClient(hwnd,&amp;pc); mouse-&gt;x=pc.x; mouse-&gt;y=pc.y; sou_dest(hwnd,hdc); &#125; break; case WM_RBUTTONUP: &#123; show_score(hwnd,"","得分"); &#125; break; case WM_PAINT: &#123; hdc = BeginPaint (hwnd, &amp;ps) ; init_GUI(hwnd,hdc); if(paint_path) &#123; paint_lattice(s_lattice,hdc,BLANK); paint_lattice(d_lattice,hdc,path_color); &#125; EndPaint (hwnd, &amp;ps) ; &#125; break; default: /* for messages that we don't deal with */ return DefWindowProc (hwnd, message, wParam, lParam); &#125; return 0;&#125; matrix.h1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//matrix.h#ifndef MATRIX_H_INCLUDED#define MATRIX_H_INCLUDED#pragma once#define BLANK 0#define RED 1#define GREEN 2#define BLUE 3#define YELLOW 4#define PURPLE 5class Point &#123;private :public: int x; int y; Point(int xx,int yy); Point(); bool operator ==(Point p); Point&amp; operator =(Point p); void show();&#125;;class node &#123;public : int x; int y; node* father; node(); node(int xx,int yy,node* f);&#125;;template&lt;class T&gt;class LinkNode &#123;private:public: T po; LinkNode* next; LinkNode(T pp); LinkNode&amp; operator=(LinkNode nn); void show_node();&#125;;template &lt;class T&gt;class Link &#123;private: LinkNode&lt;T&gt;* head=NULL; LinkNode&lt;T&gt;* p=NULL; LinkNode&lt;T&gt;* tail=NULL;public: friend class Matrix; void seek_to_first(); T get_first(); T remove_first(); T get_next(); void add_to_first(T t); void add_to_last(T t); void show_link();&#125;;class Matrix &#123;private: int N=10; int COLOR_NUM=5; int** matrix; int max_random_set_num=5; int get_random_num(int x); void print_matrix() ; bool random_set_one() ; bool is_out(int x,int y) ;public: int getN() ; Matrix() ; void init(); void set_flag(Point* p,int color) ; void set_blank(Point* p); bool is_in_que(int** in,int x,int y) ; void get_path(Point *s,Point* dest,Link&lt;Point *&gt; *&amp;l) ; void random_set(int n) ; int get_color(Point *p) ; int get_color(int x,int y); int sget_color(int dir,int x,int y,int n,int color); void test_line(int x,int y,int dir,int &amp;score); int eliminate(int &amp; score) ; bool is_all_not_blank();&#125;;#endif // MATRIX_H_INCLUDED matrix.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288 //matrix.cpp#include "matrix.h"#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;stdio.h&gt;Point::Point(int xx,int yy) &#123; x=xx; y=yy;&#125;Point::Point() &#123;&#125;bool Point::operator ==(Point p) &#123; return x==p.x&amp;y==p.y;&#125;Point&amp; Point::operator =(Point p) &#123; x=p.x; y=p.y;&#125;void Point::show() &#123; printf("(%d,%d)-&gt;",x,y);&#125;node::node() &#123;&#125;node::node(int xx,int yy,node* f) &#123; x=xx; y=yy; father=f;&#125;template&lt;class T&gt;LinkNode&lt;T&gt;::LinkNode(T pp) &#123; po=pp; next=NULL;&#125;template&lt;class T&gt;LinkNode&lt;T&gt;&amp; LinkNode&lt;T&gt;::operator=(LinkNode&lt;T&gt; nn) &#123; po=nn.p; next=nn.next;&#125;template&lt;class T&gt;void LinkNode&lt;T&gt;::show_node() &#123; po-&gt;show();&#125;template&lt;class T&gt;void Link&lt;T&gt;::seek_to_first() &#123; p=head;&#125;template&lt;class T&gt;T Link&lt;T&gt;::get_first() &#123; return head==NULL?NULL:head-&gt;po;&#125;template&lt;class T&gt;T Link&lt;T&gt;::remove_first() &#123; if(head==NULL)return NULL; T *temp=&amp;(head-&gt;po); head=head-&gt;next; return *temp;&#125;template&lt;class T&gt;T Link&lt;T&gt;::get_next() &#123; if(p==tail)return NULL; if(p==NULL)return NULL; if(p-&gt;next==NULL)return NULL; p=p-&gt;next; return p-&gt;po;&#125;template&lt;class T&gt;void Link&lt;T&gt;::add_to_first(T t) &#123; LinkNode&lt;T&gt;* x=new LinkNode&lt;T&gt;(t); x-&gt;next=head; head=x; if(tail=NULL) &#123; tail=head; return ; &#125;&#125;template&lt;class T&gt;void Link&lt;T&gt;::add_to_last(T t) &#123; LinkNode&lt;T&gt;* x=new LinkNode&lt;T&gt;(t); if(head==NULL) &#123; head=x; x-&gt;next=NULL; tail=x; return ; &#125; tail-&gt;next=x; x-&gt;next=NULL; tail=x;&#125;template&lt;class T&gt;void Link&lt;T&gt;::show_link() &#123; printf("show_link:\n"); p=head; while(p!=NULL) &#123; p-&gt;show_node(); p=p-&gt;next; &#125; printf("\n");&#125;int Matrix::get_random_num(int x) &#123; int n=rand()%x; return n;&#125;void Matrix::print_matrix() &#123; printf("matrix:\n"); for(int i=0; i&lt;N; i++) &#123; for(int j=0; j&lt;N; j++) &#123; printf("%d",matrix[i][j]); &#125; printf("\n"); &#125;&#125;bool Matrix::random_set_one() &#123; int x=get_random_num(N),y=get_random_num(N); if(matrix[x][y]!=BLANK) &#123; return false; &#125; Point *p=new Point(x,y); set_flag(p,get_random_num(COLOR_NUM)+1); return true;&#125;bool Matrix::is_out(int x,int y) &#123; return x&lt;0|x&gt;=N|y&lt;0|y&gt;=N;&#125;int Matrix::getN() &#123; return N;&#125;Matrix::Matrix() &#123; matrix=new int*[N]; for(int i=0; i&lt;N; i++) &#123; matrix[i]=new int[N]; for(int j=0; j&lt;N; j++) &#123; matrix[i][j]=BLANK; &#125; &#125; srand(time(0));&#125;void Matrix::init() &#123; random_set(N*N/4); //print_matrix();&#125;void Matrix::set_flag(Point* p,int color) &#123; matrix[p-&gt;x][p-&gt;y]=color;&#125;void Matrix::set_blank(Point* p) &#123; matrix[p-&gt;x][p-&gt;y]=BLANK;&#125;bool Matrix::is_in_que(int** in,int x,int y) &#123; return false;&#125;void Matrix::get_path(Point *s,Point* dest,Link&lt;Point *&gt; *&amp;l) &#123; if(!(get_color(s)!=BLANK&amp;&amp;get_color(dest)==BLANK))return ; static int xc[4]= &#123;-1,1,0,0&#125;; static int yc[4]= &#123;0,0,-1,1&#125;; int xt,yt; Link&lt;node*&gt; que; node* temp=new node(s-&gt;x,s-&gt;y,NULL); que.add_to_last(temp); node* dest_node; bool flag=true; bool** in=new bool*[N]; for(int i=0; i&lt;N; i++) &#123; in[i]=new bool[N]; for(int j=0; j&lt;N; j++) &#123; in[i][j]=false; &#125; &#125; in[temp-&gt;x][temp-&gt;y]=true; while(flag&amp;&amp;que.get_first()!=NULL) &#123; temp=que.remove_first(); if(temp==NULL) &#123; break; &#125; for(int i=0; i&lt;4; i++) &#123; xt=temp-&gt;x+xc[i]; yt=temp-&gt;y+yc[i]; if((!is_out(xt,yt))&amp;&amp;(!in[xt][yt])) &#123; node* new_node=new node(xt,yt,temp); if(xt==dest-&gt;x&amp;&amp;yt==dest-&gt;y) &#123; dest_node=new_node; flag=false; break; &#125; if(get_color(xt,yt)==BLANK) &#123; in[xt][yt]=true; que.add_to_last(new_node); &#125; &#125; &#125; &#125; if(flag) &#123; return ; &#125; node *n=dest_node; while(n!=NULL) &#123; Point *lp=new Point(n-&gt;x,n-&gt;y); l-&gt;add_to_first(lp); n=n-&gt;father; &#125;&#125;void Matrix::random_set(int n) &#123; int i=0; srand(time(0)); int try_time=0; while(i&lt;n&amp;&amp;try_time&lt;N*N*N) &#123; try_time++; if(random_set_one()) &#123; i++; &#125; &#125; return ;&#125;int Matrix::get_color(Point *p) &#123; return matrix[p-&gt;x][p-&gt;y];&#125;int Matrix::get_color(int x,int y) &#123; return matrix[x][y];&#125;int Matrix::sget_color(int dir,int x,int y,int n,int color) &#123; switch(dir) &#123; case 0: y+=n; break; case 1: x+=n; y+=n; break; case 2: x+=n; break; case 3: x+=n; y-=n; &#125; if(is_out(x,y)) &#123; return -1; &#125; if(color!=-1) &#123; matrix[x][y]=color; return -1; &#125; return get_color(x,y);&#125;void Matrix::test_line(int x,int y,int dir,int &amp;score) &#123; int color=get_color(x,y); if(color==BLANK)return ; for(int k=0; k&lt;5; k++) &#123; if(sget_color(dir,x,y,k,-1)!=color) &#123; return ; &#125; &#125; int k=0; for( ;; k++) &#123; if(sget_color(dir,x,y,k,-1)!=color)break; sget_color(dir,x,y,k,BLANK); &#125; score+=k;&#125;int Matrix::eliminate(int &amp; score) &#123; for(int i=0; i&lt;N; i++) &#123; for(int j=0; j&lt;N; j++) &#123; for(int k=0; k&lt;4; k++) &#123; test_line(i,j,k,score); &#125; &#125; &#125;&#125;bool Matrix::is_all_not_blank() &#123; for(int i=0; i&lt;N; i++) &#123; for(int j=0; j&lt;N; j++) &#123; if(matrix[i][j]==BLANK) &#123; return false; &#125; &#125; &#125; return true;&#125; 旧函数:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// int tree(node * n,node* father,Point* dest,node * temp)// &#123;// static int xc[4]= &#123;-1,1,0,0&#125;;// static int yc[4]= &#123;0,0,-1,1&#125;;// if(n==NULL)// &#123;// return -1;// &#125;// printf("n:(%d,%d) ",n-&gt;x,n-&gt;y);// n-&gt;father=father;// int xt,yt;// Link&lt;Point *&gt; nei;// printf("neis: ");// for(int i=0; i&lt;4; i++)// &#123;// xt=n-&gt;x+xc[i];// yt=n-&gt;y+yc[i];// if((!is_out(xt,yt))&amp;&amp;nn[xt][yt].father==NULL&amp;&amp;nn[xt][yt].father==temp)// &#123;//// if(xt==dest-&gt;x&amp;&amp;yt==dest-&gt;y)// &#123;// printf("(%d,%d) ",xt,yt);// nn[xt][yt].father=n;// return 0;// &#125;// if(get_color(xt,yt)==BLANK)// &#123;// printf("(%d,%d) ",xt,yt);// Point *ptemp=new Point(xt,yt);// nei.add_to_first(ptemp);// nn[xt][yt].father=n;// &#125;// &#125;// &#125;// printf("\n");// nei.seek_to_first();// Point *pp;// if((pp=nei.get_first())!=NULL)&#123;// if(tree(&amp;nn[pp-&gt;x][pp-&gt;y],n,dest,temp)==0)return 0;// &#125;// while((pp=nei.get_next())!=NULL)&#123;// if(tree(&amp;nn[pp-&gt;x][pp-&gt;y],n,dest,temp)==0)return 0;// &#125;// return 1;// &#125;// void get_path(Point *s,Point* dest,Link&lt;Point *&gt; *&amp;l)// &#123;// printf("1\n");// node* temp=new node;// tree(&amp;nn[s-&gt;x][s-&gt;y],temp,dest,temp);// printf("\n\nfathers:\n");//// for(int i=0; i&lt;N; i++)// &#123;// for(int j=0; j&lt;N; j++)// &#123;// if(nn[i][j].father!=NULL)&#123;// printf("(%d",nn[i][j].x);// printf(",%d)",nn[i][j].y);// printf("-&gt;(%d",nn[i][j].father-&gt;x);// printf(",%d)\n",nn[i][j].father-&gt;y);// &#125;// &#125;// printf("\n");// &#125;//// node* n=&amp;nn[dest-&gt;x][dest-&gt;y];//// while(n!=temp)// &#123;// Point *lp=new Point(n-&gt;x,n-&gt;y);// l-&gt;add_to_first(lp);// n=n-&gt;father;// &#125;// printf("3\n");// &#125; 程序写于大三下学期，2016年3月。 2016.4.12更新博客。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[科学计算器（JAVA实现）]]></title>
      <url>2016%2F03%2F13%2F%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97%E5%99%A8Java%2F</url>
      <content type="text"><![CDATA[前记： 大二学 Java 的时候写的，现在贴上来，只为留念。 再翻代码，自己看着都头疼。一重重的 if 嵌套，当时写得费劲，现在看着更费劲。 代码思想： 代码的大致思想是这样： 首先定义一个算式字符串。然后用户通过键盘或鼠标点击按钮输入字符，添加到算式字符串末尾。在每次用户输入字符之后，先判断该字符是否符合算式语法规则（如加号后不能再跟加号），不符合语法规则的字符不添加到算式字符串末尾。如果用户输入了等号，则进行计算并将计算结果显示出来。 其中计算过程如下：&gt; 首先将字符串转化为两个链表，一个存储浮点数，一个存储运算符。&gt; 如 3 + 2*4 - 4/2&gt; 会被转换为两个链表：3 2 4 4 2+ * - /&gt;之后循环以下过程：&gt; 在运算符链表中找到运算优先级最高的一个运算符（若有多个，取第一个）。假设其下标为 i（如在上例中，i = 1 ），然后在浮点数链表中找到下标为 i 和 i+1 的项，进行相应运算后，删除这两项，并把结果插入该位置。在运算符链表中删除该运算符。&gt;如上例中，执行一次运算后，链表为：3 8 4 2+ - /&gt;循环进行到浮点数链表中只有一个项目（也即操作符链表为空）。该项目即为算式计算结果。 经测试，程序能进行浮点数科学计算。能进行负数计算，如 3--3 。但是计算 3---3 时会出现异常。 代码： Calculator.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325package mycalculator;/* * * 计算3---3 会有异常 * * * * */import java.awt.*;import java.awt.event.*;import javax.swing.*;import java.util.*;public class Calculator extends JFrame implements ActionListener, KeyListener, MouseListener &#123; final int WIDTH = 440, HEIGHT = 350; GridLayout gridLayout = new GridLayout(4, 4, 5, 5); // 勿忘初始化 不初始化不会报错，但面板是空的 BorderLayout borderLayout = new BorderLayout(); FlowLayout flowLayout = new FlowLayout(); Container container; // Container cont; JPanel panel, buttonPanel; JButton[] buttons; String[] name; JTextField textField; boolean cleared = true; public Calculator() &#123; super("Calculator"); container = getContentPane(); // Cont = getContentPane(); // Cont.setLayout(borderLayout); buttonPanel = new JPanel(); panel = new JPanel(); // container = new Container(); // Cont.add(container, borderLayout.CENTER); // panel.setSize(380,380); buttonPanel.setLayout(gridLayout); textField = new JTextField(15); textField.setFont(textField.getFont().deriveFont(Font.BOLD, (float) 32.0)); textField.setEditable(false); textField.setHorizontalAlignment(JTextField.RIGHT); textField.setBackground(Color.GRAY); textField.setForeground(Color.WHITE); panel.add(textField); // textField.setSize(getBounds().width,getBounds().height/3); // textField.setFont(textField.getFont().deriveFont(99)); /* * container.setLayout(borderLayout); container.add(textField, * borderLayout.NORTH); container.add(cont, borderLayout.CENTER); */ container.setLayout(borderLayout); // container.add(textField); container.add(panel, borderLayout.NORTH); container.add(buttonPanel, borderLayout.CENTER); // container.setSize(getBounds().width,getBounds().height); // cont.setSize(getBounds().width,getBounds().height/3*2); buttons = new JButton[16]; name = new String[] &#123; "7", "8", "9", "/", "4", "5", "6", "*", "1", "2", "3", "-", "0", ".", "=", "+" &#125;; for (int index = 0; index &lt;= 15; index++) &#123; buttons[index] = new JButton(name[index]); buttons[index].addActionListener(this); buttons[index].setBackground(Color.GRAY); buttons[index].setForeground(Color.WHITE); buttons[index].addKeyListener(this); buttons[index].addMouseListener(this); buttons[index].setFont(buttons[index].getFont().deriveFont( Font.BOLD, (float) 32.0)); // buttons[index].setSize(200, 200); buttonPanel.add(buttons[index]); &#125; this.addKeyListener(this); setSize(WIDTH, HEIGHT); Toolkit kit = Toolkit.getDefaultToolkit(); // 定义工具包 Dimension screenSize = kit.getScreenSize(); // 获取屏幕的尺寸 int screenWidth = screenSize.width; // 获取屏幕的宽 int screenHeight = screenSize.height; // 获取屏幕的高 setLocation(screenWidth / 2 - WIDTH / 2, screenHeight / 2 - HEIGHT / 2);// 设置窗口居中显示 // setLocation(600, 250); setVisible(true); setFocusable(true); &#125; String calculate(String str) &#123; String result = "Wrong Expression"; String temp = ""; if (str.charAt(0) != '-' &amp;&amp; !(str.charAt(0) &lt;= '9' &amp;&amp; str.charAt(0) &gt;= '0')) &#123; return result; &#125; LinkedList&lt;Double&gt; list = new LinkedList&lt;Double&gt;(); LinkedList&lt;Character&gt; optList = new LinkedList&lt;Character&gt;(); Double doubleTemp; boolean isFormerOpt = true; for (int index = 0; index &lt;= str.length() - 1; index++) &#123; if (index == 0) &#123; isFormerOpt = true; &#125; else &#123; if (str.charAt(index - 1) &gt; '9' || str.charAt(index - 1) &lt; '0') &#123; isFormerOpt = true; &#125; else &#123; isFormerOpt = false; &#125; &#125; if (str.charAt(index) != '+' &amp;&amp; str.charAt(index) != '*' &amp;&amp; str.charAt(index) != '/' &amp;&amp; (!(str.charAt(index) == '-' &amp;&amp; isFormerOpt == false))) &#123; temp += str.charAt(index); &#125; else &#123; doubleTemp = new Double(temp); list.add(doubleTemp); temp = ""; optList.add(str.charAt(index)); &#125; &#125; doubleTemp = new Double(temp); list.add(doubleTemp); temp = ""; /* * for (int index = 0; index &lt;= list.size() - 1; index++) &#123; * System.out.println(list.get(index)); &#125; for (int index = 0; index &lt;= * optList.size() - 1; index++) &#123; * System.out.println(optList.get(index)); &#125; */ boolean isThereHigherOpt = true; while (isThereHigherOpt == true) &#123; /* * for (Iterator&lt;Character&gt; it = optList.iterator(); it.hasNext();) * &#123; if (it.next() == '*' || it.next() == '/') &#123; isThereHigherOpt = * true; int index = optList.indexOf(it.next()); * * break; &#125; &#125; */ isThereHigherOpt = false; for (int index = 0; index &lt;= optList.size() - 1; index++) &#123; if (optList.get(index) == '*') &#123; Double t = list.get(index) * list.get(index + 1); list.remove(index + 1); list.set(index, t); optList.remove(index); isThereHigherOpt = true; break; &#125; if (optList.get(index) == '/') &#123; Double t = list.get(index) / list.get(index + 1); list.remove(index + 1); list.set(index, t); optList.remove(index); isThereHigherOpt = true; break; &#125; &#125; &#125; while (optList.isEmpty() == false) &#123; for (int index = 0; index &lt;= optList.size() - 1; index++) &#123; if (optList.get(index) == '+') &#123; Double t = list.get(index) + list.get(index + 1); list.remove(index + 1); list.set(index, t); optList.remove(index); break; &#125; if (optList.get(index) == '-') &#123; Double t = list.get(index) + 0.0 - list.get(index + 1); list.remove(index + 1); list.set(index, t); optList.remove(index); break; &#125; &#125; &#125; /* * System.out.println("/////////////////////////////////"); for (int * index = 0; index &lt;= optList.size() - 1; index++) &#123; // * System.out.println(index); System.out.println(list.get(index)); * System.out.println(optList.get(index)); * System.out.println(list.get(index + 1)); &#125; */ if (list.size() == 1) &#123; result = list.get(0).toString(); &#125; return result; &#125; void addText(char ch) &#123; if (cleared == true &amp;&amp; ((ch &lt;= '9' &amp;&amp; ch &gt;= '0'))) &#123; textField.setText(""); cleared = false; &#125; String str = textField.getText(); if (ch != '=') &#123; if (str.length() &gt; 0) &#123; if (str.charAt(str.length() - 1) &lt;= '9' &amp;&amp; str.charAt(str.length() - 1) &gt;= '0') &#123; if (ch != '.') &#123; textField.setText(str + ch); &#125; else &#123; boolean isTherePoint = false; int i = str.length() - 1; while (i &gt;= 0) &#123; if (str.charAt(i) == '*' || str.charAt(i) == '/' || str.charAt(i) == '+' || str.charAt(i) == '-') &#123; break; &#125; if (str.charAt(i) == '.') &#123; isTherePoint = true; break; &#125; i--; &#125; if (isTherePoint == false) &#123; textField.setText(str + ch); &#125; &#125; &#125; else &#123; if ((ch &lt;= '9' &amp;&amp; ch &gt;= '0') || ch == '-') &#123; textField.setText(str + ch); &#125; &#125; &#125; else &#123; if (ch == '-' || (ch &lt;= '9' &amp;&amp; ch &gt;= '0')) textField.setText(str + ch); &#125; cleared = false; &#125; else &#123; if (cleared == true) &#123; textField.setText(""); &#125; else &#123; str = textField.getText(); //System.out.println(str); textField.setText(""); if (str.length() &gt; 0) &#123; if (str.charAt(str.length() - 1) &lt;= '9' &amp;&amp; str.charAt(str.length() - 1) &gt;= '0') &#123; textField.setText(calculate(str)); &#125; else &#123; textField.setText("Wrong Expression"); &#125; &#125; &#125; cleared = true; &#125; &#125; public void actionPerformed(ActionEvent event) &#123; Object source = event.getSource(); if (source.getClass() == JButton.class) &#123; JButton button = (JButton) source; char ch = button.getText().charAt(0); addText(ch); &#125; &#125; public void keyPressed(KeyEvent e) &#123; &#125; public void keyReleased(KeyEvent e) &#123; &#125; public void keyTyped(KeyEvent e) &#123; char ch = e.getKeyChar(); if (ch == ' ') &#123; System.exit(EXIT_ON_CLOSE); &#125; if (ch == KeyEvent.VK_ENTER) &#123; buttons[14].setBackground(Color.LIGHT_GRAY); for (int i = 0; i &lt;= name.length - 1; i++) &#123; if (i != 14) &#123; buttons[i].setBackground(Color.GRAY); &#125; &#125; addText('='); return; &#125; for (int index = 0; index &lt;= name.length - 1; index++) &#123; if (ch == name[index].charAt(0)) &#123; // System.out.println(ch); buttons[index].setBackground(Color.LIGHT_GRAY); for (int i = 0; i &lt;= name.length - 1; i++) &#123; if (i != index) &#123; buttons[i].setBackground(Color.GRAY); &#125; &#125; addText(ch); break; &#125; &#125; &#125; public void mouseClicked(MouseEvent event) &#123; &#125; public void mouseEntered(MouseEvent event) &#123; Object source = event.getSource(); if (source.getClass() == JButton.class) &#123; JButton button = (JButton) source; // System.out.println("hey"); button.setBackground(Color.LIGHT_GRAY); &#125; &#125; public void mousePressed(MouseEvent event) &#123; &#125; public void mouseReleased(MouseEvent event) &#123; &#125; public void mouseExited(MouseEvent event) &#123; Object source = event.getSource(); if (source.getClass() == JButton.class) &#123; JButton button = (JButton) source; // System.out.println("hey"); button.setBackground(Color.GRAY); &#125; &#125; public static void main(String[] args) &#123; Calculator c = new Calculator(); // c.addKeyListener(c); c.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125;&#125; 程序运行效果：计算9/3-1*2+-1 结果： 随笔写于2016.4.8。 程序写于大二下学期，Java程序设计 课程期间。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[抓鼠标的猫（Win32实现，Codeblocks+GCC编译）]]></title>
      <url>2016%2F03%2F13%2F%E6%8A%93%E9%BC%A0%E6%A0%87%E7%9A%84%E7%8C%AB%2F</url>
      <content type="text"><![CDATA[程序效果：猫的眼睛一直跟着鼠标移动： 鼠标经过猫的右脚附近时，猫会抓住鼠标。（未使用Hook） &ensp;&ensp;&ensp;&ensp; 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268 //main.cpp#include &lt;windows.h&gt;#include &lt;math.h&gt;//#include &lt;iostream&gt;//using namespace std;LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;double WIDTH=410,HEIGHT=430;double px=0.0,py=0.0;double ppx=0.0,ppy=0.0;POINT sp;int cat=0;double width,height;PAINTSTRUCT ps ;RECT rect ;POINT pts[3];double left_eye_px=0.0,right_eye_px=0.0;double eye_py=0.0;double eye_r=0.0;double k=0.0;double ball_hr=0.0;//半径double deltax=0.0;POINT p,pp;int initGraph=1;LPPOINT catp;RECT eye_rect;HBRUSH gray_brush =CreateSolidBrush (RGB(180,180,180));HBRUSH white_brush =CreateSolidBrush (RGB(255,255,255));HBRUSH black_brush =CreateSolidBrush (RGB(0,0,0));int drawRound(HDC hdc,int x,int y,int r) //r 直径&#123; Ellipse(hdc,x-r/2,y-r/2,x+r/2,y+r/2); return 0;&#125;int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)&#123; static TCHAR szAppName[] = TEXT ("HelloWin") ; HWND hwnd ; MSG msg ; WNDCLASS wndclass ; wndclass.style = CS_HREDRAW | CS_VREDRAW ; wndclass.lpfnWndProc = WndProc ; wndclass.cbClsExtra = 0 ; wndclass.cbWndExtra = 0 ; wndclass.hInstance = hInstance ; wndclass.hIcon = LoadIcon (NULL, IDI_APPLICATION) ; wndclass.hCursor = LoadCursor (NULL, IDC_ARROW) ; wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ; wndclass.lpszMenuName = NULL ; wndclass.lpszClassName = szAppName ; if (!RegisterClass (&amp;wndclass)) &#123; MessageBox (NULL, TEXT ("This program requires Windows NT!"), szAppName, MB_ICONERROR) ; return 0 ; &#125; hwnd = CreateWindow (szAppName, // window class name TEXT ("Mouse Hook"), // window caption WS_OVERLAPPEDWINDOW, // window style CW_USEDEFAULT, // initial x position CW_USEDEFAULT, // initial y position WIDTH, // initial x size HEIGHT, // initial y size NULL, // parent window handle NULL, // window menu handle hInstance, // program instance handle NULL) ; // creation parameters ShowWindow (hwnd, iCmdShow) ; UpdateWindow (hwnd) ; while (GetMessage (&amp;msg, NULL, 0, 0)) &#123; TranslateMessage (&amp;msg) ; DispatchMessage (&amp;msg) ; &#125; return msg.wParam ;&#125;int init(HWND hwnd)&#123; GetClientRect (hwnd, &amp;rect) ; width=rect.right-rect.left ; height=rect.bottom-rect.top ; left_eye_px=width*3/8-height/16; right_eye_px=width*5/8+height/16; eye_py=height*5/10-height/16; eye_r=height/8; ball_hr=eye_r/8;//半径 px=left_eye_px; py=eye_py; ppx=right_eye_px; ppy=eye_py; eye_rect.left=left_eye_px-eye_r/2; eye_rect.right=right_eye_px+eye_r/2; eye_rect.top=eye_py-eye_r/2; eye_rect.bottom=eye_py+eye_r/2; return 0;&#125;int drawHand(HDC hdc)&#123; /**&lt; 画嘴 */ if(cat==0) &#123; MoveToEx (hdc, width/4+width/10,height/48*33, NULL) ; LineTo (hdc, width*3/4-width/10, height/48*33) ; SelectObject (hdc,gray_brush ) ; Ellipse(hdc,width/4-width/20,height/4*3,width/4+width/20,height*1.1);//左胳膊 Ellipse(hdc,width/4*3-width/20,height/4*3,width/4*3+width/20,height*1.1);//右胳膊 return 0; &#125; SelectObject (hdc, gray_brush) ; Ellipse(hdc,width/4*3-width/20,height/4*3,width/4*3+width/20,height*1.1);//右胳膊 Ellipse(hdc,width/4-width/20,height-height/4,width/4+width/20,height);//左胳膊 /**&lt; 画脚掌 */ Ellipse(hdc,width/4-width/12,height-height/7,width/4+width/12,height); MoveToEx (hdc, width/4-width/15,height-height/9, NULL) ; LineTo (hdc, width/4-width/16, height-height/15) ; MoveToEx (hdc, width/4,height-height/7, NULL) ; LineTo (hdc, width/4, height-height/16) ; MoveToEx (hdc, width/4+width/15,height-height/9, NULL) ; LineTo (hdc, width/4+width/16, height-height/15) ; Arc( hdc, width/4-width/18, height-height/16,width/4+width/18, height,width/4+width/16, height,width/4-width/16, height); /**&lt; 画嘴 */ Arc( hdc, width*1/4+width/10, height/48*27,width*3/4-width/10, height/48*33,width*1/4, height/48*30, width*3/4, height/48*30); return 0;&#125;LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; POINT pc; HDC hdc; switch (message) &#123; case WM_CREATE: init(hwnd); initGraph =1; InvalidateRect (hwnd,NULL, true) ; return 0 ; case WM_SIZE: init(hwnd); initGraph =1; InvalidateRect (hwnd,NULL, true) ; return 0; case WM_MOVE: return 0; case WM_LBUTTONDOWN: GetCursorPos(&amp;pc); if(pc.x==sp.x&amp;&amp;pc.y==sp.y) &#123; cat=0; SetCursorPos(sp.x,sp.y-height/2); ReleaseCapture () ; initGraph=1; InvalidateRect (hwnd,NULL, true) ; &#125; return 0 ; case WM_MOUSEMOVE: if(cat==1) &#123; SetCursorPos(sp.x,sp.y); return 0; &#125; GetCursorPos(&amp;p); pp=p; ScreenToClient(hwnd,&amp;pp); if((pp.x&gt;width/4-width/12)&amp;&amp;(pp.x&lt;width/4+width/12)&amp;&amp;(pp.y&gt;height-height/7)&amp;&amp;(pp.y&lt;height)) &#123; SetCapture (hwnd) ; sp.x=width/4; sp.y=height-height/14; ClientToScreen(hwnd,&amp;sp); cat=1; initGraph=1; InvalidateRect (hwnd,NULL, true) ; return 0; &#125; k=999.0; if(pp.x-left_eye_px!=0) &#123; k=(pp.y-eye_py)/(pp.x-left_eye_px); &#125; deltax=(ball_hr/4)/(1+k*k); deltax=sqrt(deltax); if(!(pp.x&gt;left_eye_px)) &#123; deltax=(-1.0)*deltax; &#125; px=left_eye_px+deltax*8; deltax=(ball_hr/4)/(1+1/(k*k)); deltax=sqrt(deltax); if(!(pp.y&gt;eye_py)) &#123; deltax=(-1.0)*deltax; &#125; py=eye_py+deltax*8; k=999.0; if(pp.x-right_eye_px!=0) &#123; k=(pp.y-eye_py)/(pp.x-right_eye_px); &#125; deltax=(ball_hr/4)/(1+k*k); deltax=sqrt(deltax); if(!(pp.x&gt;right_eye_px)) &#123; deltax=(-1.0)*deltax; &#125; ppx=right_eye_px+deltax*8; deltax=(ball_hr/4)/(1+1/(k*k)); deltax=sqrt(deltax); if(!(pp.y&gt;eye_py)) &#123; deltax=(-1.0)*deltax; &#125; ppy=eye_py+deltax*8; InvalidateRect (hwnd, &amp;eye_rect, false) ; return 0 ; case WM_PAINT: hdc=BeginPaint (hwnd,&amp;ps) ; if(initGraph==1) &#123; SelectObject (hdc, gray_brush) ; Ellipse(hdc,width/6,height/2,width-width/6,height*3/2);//身体 /**&lt; 画脸 */ Ellipse(hdc,0,height/4,width*20/20,height*3/4); /**&lt; 画耳朵 */ pts[0].x =width/4; pts[0].y =height/10; pts[1].x =width/8; pts[1].y =height/9*3; pts[2].x =width/8*3; pts[2].y =height/33*9; Polygon (hdc, pts, 3) ; pts[0].x =width/4*3; pts[0].y =height/10; pts[1].x =width/8*7; pts[1].y =height/9*3; pts[2].x =width/8*5; pts[2].y =height/33*9; Polygon (hdc, pts, 3) ; /**&lt; 画胡子 */ MoveToEx (hdc, 0, height/48*27, NULL) ; LineTo (hdc, width/8*2,height/48*27) ; MoveToEx (hdc, 0, height/48*30, NULL) ; LineTo (hdc, width/8*2,height/48*30) ; MoveToEx (hdc, 0, height/48*33, NULL) ; LineTo (hdc, width/8*2,height/48*33) ; MoveToEx (hdc, width, height/48*27, NULL) ; LineTo (hdc, width/8*6,height/48*27) ; MoveToEx (hdc, width, height/48*30, NULL) ; LineTo (hdc, width/8*6,height/48*30) ; MoveToEx (hdc, width, height/48*33, NULL) ; LineTo (hdc, width/8*6,height/48*33) ; drawHand(hdc); initGraph=0; &#125; /**&lt; 画眼睛 */ SelectObject (hdc, white_brush) ; drawRound(hdc,left_eye_px,eye_py,eye_r); drawRound(hdc,right_eye_px,eye_py,eye_r); SelectObject (hdc, black_brush) ; drawRound(hdc,px,py,ball_hr*2); drawRound(hdc,ppx,ppy,ball_hr*2); EndPaint (hwnd, &amp;ps) ; return 0 ; case WM_DESTROY: PostQuitMessage (0) ; return 0 ; &#125; return DefWindowProc (hwnd, message, wParam, lParam) ;&#125; 程序写于大三上学期，Windows程序设计 课程考核作业。 2016.4.12更新博客。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[俄罗斯方块（Java实现）]]></title>
      <url>2016%2F03%2F13%2F%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97Java%2F</url>
      <content type="text"><![CDATA[程序效果： 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//Box.javapackage tetris;public class Box &#123; private final int M = 30, N = 12; private int[][] ls = new int[M][N]; private int score=0; int getM() &#123; return M; &#125; int getN() &#123; return N; &#125; int getScore() &#123; return score; &#125; boolean isOut(int x,int y)&#123; return x&lt;0|y&lt;0|x&gt;M-1|y&gt;N-1?true:false; &#125; int getFlag(int x, int y) &#123; return isOut(x,y)?2:ls[x][y]; &#125; int clearFlag(int x, int y) &#123; if(isOut(x,y))return -1; ls[x][y]=0; return 0; &#125; int setFlag_1(int x, int y) &#123; if(isOut(x,y))return -1; ls[x][y]=1; return 0; &#125; int setFlag_2(int x, int y) &#123; if(isOut(x,y))return -1; ls[x][y]=2; return 0; &#125; /*boolean isFlag_2(int x, int y) &#123; return isOut(x,y)?true:ls[x][y]== 2 ? true:false ; &#125;*/ void clear(int x, int maxX) &#123; if(isOut(x,0)||isOut(maxX,0))return ; for (int i = x; i &lt;= maxX; i++) &#123; boolean isAllNotBlank = true; for (int j = 0; j &lt;= N - 1; j++) &#123; if (ls[i][j]== 0) &#123; isAllNotBlank = false; break; &#125; &#125; if (isAllNotBlank) &#123; for (int k = i - 1; k &gt;= 0; k--) &#123; for (int j = 0; j &lt;= N - 1; j++) &#123; ls[k + 1][j]=ls[k][j]; &#125; &#125; score+=100; &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126//Shape.javapackage tetris;import java.awt.Point;import java.util.Random;public class Shape &#123; private final Box box; private Point[] ps = new Point[4]; private Point[] tps = new Point[5]; private final int[][][]shapes=&#123; &#123;&#123;-1,0,0,0,1,0,2,0&#125;,&#123;0,0,0,-1,0,2,0,1&#125;&#125;, &#123;&#123;- 1,0, 1, - 1,0,0,1,0&#125;,&#123;0,- 1,1,-1,1,1,1,0&#125;,&#123;-1,0,0,0,-1,1,1,0&#125;,&#123;0,0,0,-1,0,1,1,1&#125;&#125;, &#123;&#123;-1,0,0,0,1,1,1,0&#125;,&#123;0,1,1,-1,1,1,1,0&#125;,&#123;-1,0,-1,-1,0,0,1,0&#125;,&#123;0,0,0,-1,0,1,1,-1&#125;&#125;, &#123;&#123;0,0,1,-1,1,1,1,0&#125;,&#123;0,0,1,-1,1,0,2,0&#125;,&#123;0,0,0,-1,0,1,1,0&#125;,&#123;0,0,1,0,1,1,2,0&#125;&#125;, &#123;&#123;0,0,1,0,0,1,1,1&#125;&#125;, &#123;&#123;-1,0,0,-1,-1,1,0,0&#125;,&#123;-1,0,0,0,0,1,1,1&#125;&#125;, &#123;&#123;- 1,0, - 1,- 1,0, 1,0,0&#125;,&#123;- 1,1,0,0,0,1,1,0&#125;&#125; &#125;; private int change = 0,shape,x,y; int left,down; private Random random; boolean isPaused = false; Shape(Box b) &#123; box = b; for (int i = 0; i &lt;= 3; i++) &#123; ps[i] = new Point(); &#125; for (int i = 0; i &lt;= 4; i++) &#123; tps[i] = new Point(); &#125; random = new Random(); getNewShape(); &#125; private void clearTpsFlag()&#123; for (int i = 0; i &lt;= 3; i++) &#123; box.clearFlag(tps[i].x, tps[i].y); &#125; &#125; private int setPsFlag_1() &#123; for (int i = 0; i &lt;= 3; i++) &#123; box.setFlag_1(ps[i].x, ps[i].y); &#125; return 0; &#125; private int setPsFlag_2() &#123; for (int i = 0; i &lt;= 3; i++) &#123; box.setFlag_2(ps[i].x, ps[i].y); &#125; return 0; &#125; private synchronized int tps() &#123; for (int i = 0; i &lt;= 3; i++) &#123; tps[i].x = ps[i].x; tps[i].y = ps[i].y; &#125; tps[4].x=x; tps[4].y=y; return 0; &#125; private synchronized int backupChange() &#123; for (int i = 0; i &lt;= 3; i++) &#123; ps[i].x = tps[i].x; ps[i].y = tps[i].y; &#125; x=tps[4].x; y=tps[4].y; return 0; &#125; private synchronized int check() &#123; System.out.println(ps[0]+","+ps[1]+","+ps[2]+","+ps[3]); for (int i = 0; i &lt;= 3;i++) &#123; if (!(box.getFlag(ps[i].x, ps[i].y)==0||box.getFlag(ps[i].x, ps[i].y)==1))&#123; backupChange(); return 5;&#125; &#125; return 0; &#125; private void getNewShape()&#123; System.out.println("lll"); int i = Math.abs(random.nextInt()) % 7; shape=i; x=1; y=box.getN()/2; for(int j=0;j&lt;=3;j++)&#123; ps[j].setLocation(x+shapes[i][0][j*2], y+shapes[i][0][j*2+1]); &#125; left=0; down=0; change=0; &#125; void changeShape()&#123; tps(); change++; change%=shapes[shape].length; for(int j=0;j&lt;=3;j++)&#123; ps[j].setLocation(x+shapes[shape][change][j*2], y+shapes[shape][change][j*2+1]); &#125; int g=check(); if(g==0)&#123; clearTpsFlag(); setPsFlag_1(); &#125; &#125; synchronized int move(int dir) &#123; tps(); switch(dir)&#123; case 0:for (int i = 0; i &lt;= 3; i++) &#123;ps[i].y--;&#125;y--;break; case 1:for (int i = 0; i &lt;= 3; i++) &#123;ps[i].y++;&#125;y++;break; case 2:for (int i = 0; i &lt;= 3; i++) &#123;ps[i].x++;&#125;x++;break; default: &#125; int g = check(); if(g!=0&amp;&amp;dir==2)&#123; int x = ps[0].x; int maxX = ps[3].x;// x+4&gt;M-1?M-1:x+4; setPsFlag_2(); box.clear(x, maxX); if(x==1)&#123;return -1;&#125; getNewShape(); &#125; if(g==0)&#123; clearTpsFlag(); setPsFlag_1(); &#125; return 0; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206//Tetris.javapackage tetris;import java.awt.BorderLayout;import java.awt.Color;import java.awt.Container;import java.awt.Graphics;import java.awt.GridLayout;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JOptionPane;import javax.swing.JPanel;import javax.swing.JTextField;public class Tetris extends JFrame implements Runnable&#123; private static final long serialVersionUID = 279494108361487144L; final Color BC = Color.GRAY; final Color FC = Color.LIGHT_GRAY; Box box; Shape shape; int a = 0, b = 0, c = 0; JPanel panel, scorePanel; JTextField scoreField, bestScoreField; JButton[][] bs; Tetris(Box b) &#123; super("Tetris"); box = b; shape =new Shape(b); bs = new JButton[box.getM()][box.getN()]; for (int i = 0; i &lt;= box.getM() - 1; i++) &#123; for (int j = 0; j &lt;= box.getN() - 1; j++) &#123; bs[i][j] = new JButton(); bs[i][j].setBackground(BC); &#125; &#125; Container container = getContentPane(); container.setLayout(new BorderLayout()); scorePanel = new JPanel(); scorePanel.setLayout(new BorderLayout()); scoreField = new JTextField(10); bestScoreField = new JTextField(20); bestScoreField.setText(getBestScores()); bestScoreField.setEditable(false); scoreField.setText("SCORE: " + new Integer(box.getScore()).toString()); scoreField.setEditable(false); scorePanel.add(scoreField, BorderLayout.NORTH); scorePanel.add(bestScoreField, BorderLayout.SOUTH); container.add(scorePanel, BorderLayout.NORTH); panel = new JPanel(); panel.setLayout(new GridLayout(box.getM(), box.getN())); for (int i = 0; i &lt;= box.getM() - 1; i++) &#123; for (int j = 0; j &lt;= box.getN() - 1; j++) &#123; panel.add(bs[i][j]); &#125; &#125; container.add(panel, BorderLayout.CENTER); this.addKeyListener(new KeyAdapter() &#123; public void keyPressed(KeyEvent e) &#123; int c = e.getKeyCode(); // System.out.print(c); switch (c) &#123; case KeyEvent.VK_LEFT : //shape.left++; shape.move(0); break; case KeyEvent.VK_RIGHT : //shape.left--; shape.move(1); break; case KeyEvent.VK_UP : shape.changeShape(); break; case KeyEvent.VK_DOWN : shape.down++; break; case KeyEvent.VK_SPACE : if (shape.isPaused == true) &#123; shape.isPaused = false; &#125; else &#123; shape.isPaused = true; &#125; break; default : &#125; &#125; &#125;); this.setFocusable(true); setLocation(200, 10); setSize(20 * box.getN(), 20 * box.getM() + 20); setVisible(true); &#125; private int down() throws InterruptedException &#123; System.out.println("ddd"); int dd=shape.move(2); scoreField.setText("Score: " + new Integer(box.getScore()).toString()); if(dd==-1)&#123;gameOver();&#125; return 0; &#125; public void run() &#123; while (true) &#123; try &#123; if (shape.isPaused == true) &#123; // System.out.println("PAUSED"); Thread.sleep(500); &#125; else &#123; //System.out.println("start1"); down(); for (int i = 0; i &lt;= box.getM() - 1; i++) &#123; for (int j = 0; j &lt;= box.getN() - 1; j++) &#123; if(box.getFlag(i, j)==0) bs[i][j].setBackground(BC); else bs[i][j].setBackground(FC); &#125; &#125; if (shape.down &gt;=1) &#123; shape.down--; Thread.sleep(50); continue; &#125; Thread.sleep(250); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; String getBestScores() &#123; BufferedReader reader = null; try &#123; reader = new BufferedReader(new FileReader("score.txt")); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; try &#123; a = Integer.parseInt(reader.readLine()); b = Integer.parseInt(reader.readLine()); c = Integer.parseInt(reader.readLine()); &#125; catch (NumberFormatException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; String bestS = new String("Best Score: " + new Integer(a).toString() + " " + new Integer(b).toString() + " " + new Integer(c).toString()); return bestS; &#125; int gameOver() &#123; JOptionPane.showMessageDialog(null, "你死了~~~.", "GAME OVER", JOptionPane.PLAIN_MESSAGE); if (box.getScore() &gt; a) &#123; c = b; b = a; a = box.getScore(); &#125; else if (box.getScore() &gt; b) &#123; c = b; b = box.getScore(); &#125; else if (box.getScore()&gt; c) &#123; c = box.getScore(); &#125; save(); System.exit(0); return 0; &#125; int save() &#123; BufferedWriter writer = null; try &#123; writer = new BufferedWriter(new FileWriter("score.txt")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; String d = new Integer(a).toString(), e = new Integer(b).toString(), f = new Integer(c).toString(); try &#123; writer.write(d); writer.newLine(); writer.write(e); writer.newLine(); writer.write(f); writer.flush(); writer.close(); &#125; catch (NumberFormatException ev) &#123; ev.printStackTrace(); &#125; catch (IOException ev) &#123; ev.printStackTrace(); &#125; return 0; &#125; public static void main(String[] args) &#123; Box box = new Box(); Tetris tetris = new Tetris(box); tetris.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); Thread thread1 = new Thread(tetris); thread1.start(); &#125;&#125; 程序写于大三上学期。 2016.4.12更新博客。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[爬虫（Java实现）]]></title>
      <url>2016%2F03%2F13%2F%E7%88%AC%E8%99%AB%2F</url>
      <content type="text"><![CDATA[说明：使用了htmlparser库。 运行过程： 从某个网址开始，摘取网页中的链接，并通过广度搜索，对这些链接递归执行上述操作。 在以上过程中把网址存入数据库中。以防止搜索中出现环路。 但是，程序经常进入某个网站后，会一直扫描其中的二级域名。 于是数据库中会出现这种情况：&gt;jack.art.comhan.art.combob.art.comalice.art.comrose.art.com…… 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126//Robot.javapackage robot;import java.net.*;import java.sql.SQLException;import java.util.Random;import javax.swing.JOptionPane;import org.htmlparser.*;import org.htmlparser.filters.TagNameFilter;import org.htmlparser.tags.LinkTag;import org.htmlparser.util.NodeList;import org.htmlparser.util.ParserException;import mydb.DB;public class Robot &#123; int ff=0; int num=0; //DB db; Robot() throws MalformedURLException, SQLException&#123; DB.getConnect("localhost","3306","robot","root","142365"); DB.getSta(); String url0="http://www.youku.com";//"http://localhost"; /* DB.rs= DB.s.executeQuery("select count(*) from urls"); if(DB.rs.next()) &#123;int n=DB.rs.getInt(1); System.out.println(n ); Random random = new Random(); int ran = random.nextInt(); ran%=n; ran=ran&gt;0?ran:-ran; System.out.println(ran ); DB.rs= DB.s.executeQuery("select * from urls"); int x=0; while(DB.rs.next()&amp;&amp;x&lt;ran)&#123; System.out.println(DB.rs.getString(1)+"000" ); url0=DB.rs.getString(1); x++; &#125; &#125;*/ //catchHref("http://localhost",num); catchHref(url0,num); &#125; boolean isEndLegal(String str)&#123; if(str.endsWith("php")||str.endsWith("net/")||str.endsWith("com/")||str.endsWith("cn/")||str.endsWith("gov/")||str.endsWith("edu/")||str.endsWith("org/")||str.endsWith("net")||str.endsWith("com")||str.endsWith("cn")||str.endsWith("gov")||str.endsWith("edu")||str.endsWith("org"))&#123; return true; &#125; return false; &#125; boolean catchHref(String hreft ,int num) throws MalformedURLException &#123; Parser parser =null; NodeList nodelist=null; String href = "http://www.baidu.com"; //db=new DB(); if(ff!=0) if (!(hreft.startsWith("http")&amp;&amp;isEndLegal(hreft)&amp;&amp;!isInDatabase(hreft))) &#123; return false; &#125; ff=1; add(hreft); System.out.println(num); try &#123; parser = new Parser(hreft); if(parser==null)return false; &#125; catch (ParserException e) &#123; return false; //e.printStackTrace(); &#125; try &#123; nodelist = parser.parse(null); &#125; catch (ParserException e1) &#123; e1.printStackTrace(); &#125; if(nodelist==null)return false; NodeFilter filter = new TagNameFilter("A"); if(filter==null)return false; nodelist = nodelist.extractAllNodesThatMatch(filter, true); if(nodelist==null)return false; for (int i = 0; i &lt; nodelist.size(); i++) &#123; LinkTag link = (LinkTag) nodelist.elementAt(i); href = link.getAttribute("href"); if(href==null)return false; System.out.println(href ); catchHref(href,num); &#125; num++; return true; &#125;void add(String str)&#123; try &#123; DB.s.execute("insert into urls2(url)values('"+str+"');"); DB.commit(); System.out.println("add"); &#125; catch (SQLException e) &#123; //e.printStackTrace();return ; //JOptionPane.showMessageDialog(null, "数据库添加失败"); //System.exit(-1); &#125; return ; &#125; boolean isInDatabase(String str)&#123; try &#123; DB.rs= DB.s.executeQuery("select * from urls where url like'"+str+"%';"); if(DB.rs.next())&#123;System.out.println(DB.rs);return true;&#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); JOptionPane.showMessageDialog(null, "数据库查找失败"); System.exit(-1); &#125; return false; &#125; public static void main(String[] args) throws MalformedURLException, ParserException, SQLException &#123; Robot robot = new Robot(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137//DB.javapackage mydb;import java.sql.*;import java.util.ArrayList;import javax.swing.*;//import com.mysql.jdbc.Driver;public class DB &#123; public static Connection conn = null; public static ResultSet rs = null; public static Statement s = null; public DB() &#123; conn = null; s = null; rs=null; &#125; /* String getResult(ResultSet rs) &#123; String str = "Book\t\tOwnerID\tOwnerName\n"; // System.out.println("\nno\tname\tsex\tsalary"); try &#123; while (rs.next()) &#123; StringBuilder builder = new StringBuilder(rs.getString(1)); builder.append("\t\t"); builder.append(rs.getString(2)); builder.append("\t"); builder.append(rs.getString(3)); builder.append("\n"); str += builder.toString(); &#125; &#125; catch (Throwable e) &#123; &#125; // System.out.println(); return str; &#125;*/ public static Connection getConnect(String IP,String port,String database,String user,String password)&#123; try &#123; // Class.forName("org.gjt.mm.mysql.Driver").newInstance(); Class.forName("com.mysql.jdbc.Driver"); &#125; catch (ClassNotFoundException e1) &#123; e1.printStackTrace(); JOptionPane.showMessageDialog(null, "数据库包未找到"); System.exit(-1); &#125; // .newInstance(); try &#123; conn = DriverManager.getConnection( "jdbc:mysql://"+IP+":"+port+"/"+database+"?useUnicode=true&amp;characterEncoding=utf8", user, password);//autoReconnect=true&amp;useUnicode=true&amp;characterEncoding=utf8 &#125; catch (SQLException e1) &#123; e1.printStackTrace(); JOptionPane.showMessageDialog(null, "数据库无法连接"); System.exit(-1); &#125; try &#123; conn.setAutoCommit(false); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; return conn; &#125; public static Statement getSta()&#123; try &#123; s = conn.createStatement(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); JOptionPane.showMessageDialog(null, "无法建立数据库语句"); System.exit(-1); &#125; return s; &#125; public static int commit()&#123; try &#123; conn.commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); JOptionPane.showMessageDialog(null, "对数据库更改无法应用"); &#125; return 0; &#125; public static void closeConnect() &#123; try &#123; rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); JOptionPane.showMessageDialog(null, "数据库结果集无法关闭"); &#125; try &#123; s.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); JOptionPane.showMessageDialog(null, "数据库语句无法关闭"); &#125; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace(); JOptionPane.showMessageDialog(null, "与数据库的连接无法关闭"); &#125;/* try &#123; // perform a clean shutdown DriverManager.getConnection("jdbc:derby:;shutdown=true"); &#125; catch (SQLException se) &#123; if (((se.getErrorCode() == 50000) &amp;&amp; ("XJ015".equals(se.getSQLState())))) &#123; // we got the expected exception System.out.println("Derby shut down normally"); // Note that for single database shutdown, the expected // SQL state is "08006", and the error code is 45000. &#125; else &#123; System.err.println("Derby did not shut down normally"); // JOptionPane.showMessageDialog(null, "数据库关闭错误"); se.printStackTrace(); &#125; &#125;*/ &#125;&#125; 程序写于大三上学期。 2016.4.12更新博客。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[贪吃蛇（C++实现，VC6.0编译，使用了EasyX图形库）]]></title>
      <url>2016%2F03%2F13%2F%E8%B4%AA%E5%90%83%E8%9B%87%2F</url>
      <content type="text"><![CDATA[程序效果： &ensp;&ensp;&ensp;&ensp; 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404 //main.cpp#include &lt;iostream&gt;#include&lt;fstream&gt;#include &lt;graphics.h&gt;#include &lt;conio.h&gt;#include&lt;ctime&gt;#include&lt;windows.h&gt;#include&lt;mmsystem.h&gt;#pragma comment(lib,"Winmm.lib")#define IMGWIDTH 20#define IMGHEIGHT 20#define WIDTH 1100#define HEIGHT 650#define UP 72#define DOWN 80#define LEFT 75#define RIGHT 77#define HEADUP "headup.jpg"#define HEADDOWN "headdown.jpg"#define HEADLEFT "headleft.jpg"#define HEADRIGHT "headright.jpg"#define BODYLR "bodylr.jpg"#define BODYUD "bodyud.jpg"#define TAILL "taill.jpg"#define TAILR "tailr.jpg"#define TAILU "tailu.jpg"#define TAILD "taild.jpg"#define WALL "wall.jpg"#define FOOD "food.jpg"#define GAMEOVER "gameover.jpg"#define SNAKE "snake.jpg"#define L 60 //左#define U 80 //上#define R 900 //右#define D 600 //下using namespace std;IMAGE wallimg;int score=0,grade=1,rec[4];class Food;class BodyNode&#123;private: IMAGE img; int x; int y; BodyNode* next; BodyNode()&#123;&#125; friend class Body; friend bool check(Body&amp; snake,Food&amp; food);public: BodyNode(char* str,int X,int Y)&#123; x=X; y=Y; loadimage(&amp;img, _T(str)); next=NULL; &#125; BodyNode(BodyNode&amp; bodynode)&#123; x=bodynode.x; y=bodynode.y; next=bodynode.next; img=bodynode.img; &#125;&#125;;class Body&#123;private: BodyNode* head; BodyNode* tail; int length;public: friend bool check(Body&amp; snake,Food&amp; food); Body()&#123; head=new BodyNode(HEADRIGHT,L+(10*(IMGWIDTH)),U+(10*(IMGHEIGHT))); head-&gt;next=new BodyNode(BODYLR,head-&gt;x-head-&gt;img.getwidth(),head-&gt;y); head-&gt;next-&gt;next=new BodyNode(TAILR,head-&gt;next-&gt;x-head-&gt;img.getwidth(),head-&gt;y); tail=head-&gt;next-&gt;next; length=2; &#125; int Length()&#123;return length;&#125; bool IsDead()&#123; BodyNode* p=head-&gt;next; while(p!=NULL)&#123; if(head-&gt;x==p-&gt;x&amp;&amp;head-&gt;y==p-&gt;y)&#123; return true; &#125; p=p-&gt;next; &#125; return false; &#125; int Move(int dir)&#123; //1 上 2下 3左 4 右 BodyNode* p=head-&gt;next; int tempx=head-&gt;x,tempy=head-&gt;y,temp_x,temp_y; while(p!=tail-&gt;next)&#123; temp_x=p-&gt;x; temp_y=p-&gt;y; p-&gt;x=tempx;; p-&gt;y=tempy; tempx=temp_x; tempy=temp_y; p=p-&gt;next; &#125; if(dir==1)&#123; loadimage(&amp;(head-&gt;img), _T(HEADUP)); head-&gt;y=head-&gt;next-&gt;y-head-&gt;img.getheight(); &#125; if(dir==2)&#123; loadimage(&amp;(head-&gt;img), _T(HEADDOWN)); head-&gt;y=head-&gt;next-&gt;y+head-&gt;img.getheight(); &#125; if(dir==3)&#123; loadimage(&amp;(head-&gt;img), _T(HEADLEFT)); head-&gt;x=head-&gt;next-&gt;x-head-&gt;img.getwidth(); &#125; if(dir==4)&#123; loadimage(&amp;(head-&gt;img), _T(HEADRIGHT)); head-&gt;x=head-&gt;next-&gt;x+head-&gt;img.getwidth(); &#125; if((head-&gt;x+head-&gt;img.getwidth())&gt;R)&#123;head-&gt;x=L;&#125; if(head-&gt;x&lt;L)&#123;head-&gt;x=R-head-&gt;img.getwidth();&#125; if((head-&gt;y+head-&gt;img.getheight())&gt;D)&#123;head-&gt;y=U;&#125; if(head-&gt;y&lt;U)&#123;head-&gt;y=D-head-&gt;img.getheight();&#125; p=head; while(p-&gt;next!=tail)&#123; p=p-&gt;next; &#125; if(p-&gt;x-tail-&gt;x&gt;0)&#123;loadimage(&amp;(tail-&gt;img), _T(TAILR));&#125; if(p-&gt;x-tail-&gt;x&lt;0)&#123;loadimage(&amp;(tail-&gt;img), _T(TAILL));&#125; if(p-&gt;y-tail-&gt;y&gt;0)&#123;loadimage(&amp;(tail-&gt;img), _T(TAILD));&#125; if(p-&gt;y-tail-&gt;y&lt;0)&#123;loadimage(&amp;(tail-&gt;img), _T(TAILU));&#125; return 0; &#125; int Grow()&#123; BodyNode*p=head; while(p-&gt;next!=tail)&#123; p=p-&gt;next; &#125; tail-&gt;img=p-&gt;img; tail-&gt;next=new BodyNode(&amp;(TAILL[0]),tail-&gt;x-(p-&gt;x-tail-&gt;x),tail-&gt;y-(p-&gt;y-tail-&gt;y)); tail=tail-&gt;next; if(p-&gt;x-tail-&gt;x&gt;0)&#123;loadimage(&amp;(tail-&gt;img), _T(TAILR));&#125; if(p-&gt;x-tail-&gt;x&lt;0)&#123;loadimage(&amp;(tail-&gt;img), _T(TAILL));&#125; if(p-&gt;y-tail-&gt;y&gt;0)&#123;loadimage(&amp;(tail-&gt;img), _T(TAILD));&#125; if(p-&gt;y-tail-&gt;y&lt;0)&#123;loadimage(&amp;(tail-&gt;img), _T(TAILU));&#125; tail-&gt;next=NULL; length++; return 0; &#125; int Show()&#123; BodyNode* p=head; while(p!=NULL)&#123; putimage(p-&gt;x, p-&gt;y, &amp;(p-&gt;img)); p=p-&gt;next; &#125; return 0; &#125;&#125;;class Food&#123;private: int x; int y; IMAGE rat;public: friend bool check(Body&amp; snake,Food&amp; food); Food()&#123; x=400; y=300; loadimage(&amp;(rat), _T(FOOD)); &#125; int givefood(Body&amp; snake)&#123; srand((unsigned)time(0)); while(check(snake,*this)==true)&#123; x=0;y=0; while(!(x&gt;L&amp;&amp;y&gt;U))&#123; x= rand()%900; y= rand()%600; &#125; x=x-(x%20); y=y-(y%20); &#125; return 0; &#125; int Show()&#123; putimage(x,y,&amp;(rat)); return 0; &#125;&#125;;int showgame(Body&amp; snake,Food food)&#123; cleardevice(); BeginBatchDraw(); setbkcolor(RGB(0,0,0)); //设置背景色 setcolor(YELLOW); //设置绘图色 outtextxy((WIDTH/2)-80, 10, "贪吃蛇"); outtextxy(L+300, U-IMGHEIGHT-20, "按空格 暂停"); outtextxy(R+IMGWIDTH+20, U+IMGHEIGHT+20, "最高记录：");char rec1[10];//,rec2[10],rec3[10];for(int index=0;index&lt;=2;index++)&#123; sprintf(rec1, "%d",rec[index]); outtextxy(R+IMGWIDTH+20, U+IMGHEIGHT+20+(index+1)*30, rec1);&#125; int i,j; for(i=L-IMGWIDTH;i&lt;=R;i=i+IMGWIDTH)&#123; j=U-IMGHEIGHT; putimage(i,j,&amp;(wallimg)); &#125; for(j=U;j&lt;=D;j=j+IMGHEIGHT)&#123; i=L-IMGWIDTH; putimage(i,j,&amp;(wallimg)); &#125; for(j=U;j&lt;=D;j=j+IMGHEIGHT)&#123; i=R; putimage(i,j,&amp;(wallimg)); &#125; for(i=L-IMGWIDTH;i&lt;=R;i=i+IMGWIDTH)&#123; j=D; putimage(i,j,&amp;(wallimg)); &#125; outtextxy(L-10, U-IMGHEIGHT-20, "得分:"); char s[10]; sprintf(s, "%d",score); outtextxy(L+60, U-IMGHEIGHT-20, s); outtextxy(L+120, U-IMGHEIGHT-20, "长度:"); char l[10]; sprintf(l, "%d",snake.Length()); outtextxy(L+180, U-IMGHEIGHT-20, l); snake.Show(); food.Show(); FlushBatchDraw(); Sleep(50*grade); return 0;&#125;bool check(Body&amp; snake,Food&amp; food)&#123; BodyNode* pl=snake.head; bool flag=false; while(pl!=snake.tail-&gt;next)&#123; if((pl-&gt;x==food.x)&amp;&amp;(pl-&gt;y==food.y))&#123;flag=true;break;&#125; pl=pl-&gt;next; &#125; return flag;&#125;DWORD WINAPI Fun1Proc(LPVOID IpParameter)&#123; mciSendString("play yeah.mp3 repeat", NULL, 0, NULL);//播放 return 0;&#125;int menu()&#123; //cleardevice(); outtextxy((WIDTH/2)-80, 120, "贪吃蛇"); outtextxy((WIDTH/2)-180, 230, "按↑和↓选择难度"); outtextxy((WIDTH/2)-180, 250, "按空格键确定选择"); return 0;&#125;int record()&#123; fstream f1("record.txt"); //打开文件，若文件不存在就创建它 if(!f1) return -1; //int a=0,b=0,c=0; f1&gt;&gt;rec[0]&gt;&gt;rec[1]&gt;&gt;rec[2]; f1.close(); return 0;&#125;int saverecord()&#123; system("del record.txt "); ofstream f1("record.txt"); //打开文件，若文件不存在就创建它 if(!f1) return -1; int flag=1; int temp; rec[3]=score; while(flag==1)&#123; flag=0; for(int i=0;i&lt;=2;i++)&#123; if(rec[i]&lt;rec[i+1])&#123; flag=1; temp=rec[i]; rec[i]=rec[i+1]; rec[i+1]=temp; &#125; &#125; &#125; f1&lt;&lt;rec[0]&lt;&lt;"\n"&lt;&lt;rec[1]&lt;&lt;"\n"&lt;&lt;rec[2]; f1.close(); if(score!=rec[3])&#123; settextstyle(50, 0, _T("宋体")); outtextxy(WIDTH/2-(50*5),U+40, "恭喜你创造了新纪录！");&#125; return 0;&#125;int main()&#123; for(int i=0;i&lt;=3;i++)&#123; rec[i]=0; &#125; record(); IMAGE snakeimg; HANDLE hThread1; hThread1 = CreateThread(NULL,0,Fun1Proc,NULL,0,NULL); char key; int movekey=4; int movekeyold=movekey; initgraph(WIDTH,HEIGHT); char temp=0,choose; while(temp!=' ')&#123; cleardevice(); if(kbhit())&#123; choose=getch(); fflush(stdin); switch(choose)&#123; case UP:&#123; grade++; &#125;;break; case DOWN:&#123; grade--; &#125;; &#125; &#125; if(grade==4)&#123;grade=3;&#125; if(grade==0)&#123;grade=1;&#125; outtextxy(420,350,"简单"); outtextxy(420,380,"中等"); outtextxy(420,410,"难"); // cleardevice(); menu(); outtextxy(300,300,"请选择难度："); if(grade==3)&#123; outtextxy(390,350,"→"); &#125; if(grade==2)&#123; outtextxy(390,380,"→"); &#125; if(grade==1)&#123; outtextxy(390,410,"→"); &#125; temp=getch(); &#125; loadimage(&amp;(wallimg), _T(WALL)); Body snake; Food food; showgame(snake,food); while(snake.IsDead()==false)&#123; while(snake.IsDead()==false&amp;&amp;(!kbhit()))&#123; if(movekey==1&amp;&amp;movekeyold==2||movekey==2&amp;&amp;movekeyold==1||movekey==3&amp;&amp;movekeyold==4||movekey==4&amp;&amp;movekeyold==3)&#123; movekey=movekeyold;&#125; movekeyold=movekey; snake.Move(movekey); showgame(snake,food); if(check(snake,food)==true)&#123; mciSendString("play yeah.wav", NULL, 0, NULL);//播放 cout&lt;&lt;'\a'; score+=10; food.givefood(snake); snake.Grow(); snake.Grow(); snake.Grow(); &#125; &#125; if(kbhit())&#123; key=getch(); switch(key)&#123; case UP:&#123;movekey=1; &#125;;break; case DOWN:&#123;movekey=2; &#125;;break; case LEFT:&#123;movekey=3; &#125;;break; case RIGHT:&#123;movekey=4; &#125;;break; case ' ':&#123;int t=0; while(t==0)&#123; if(kbhit())&#123; key=getch(); if(key==' ')&#123; t=1; &#125; &#125; &#125; &#125;; &#125; &#125; &#125; CloseHandle(hThread1); BeginBatchDraw(); showgame(snake,food); IMAGE gameoverimg; loadimage(&amp;(gameoverimg), _T(GAMEOVER)); putimage(WIDTH/2-(gameoverimg.getwidth()/2),HEIGHT/2-(gameoverimg.getheight()/2),&amp;(gameoverimg)); saverecord(); FlushBatchDraw(); while(1) &#123; Sleep(3000); &#125; saverecord(); return 0;&#125; &ensp; &ensp; &ensp; &ensp; 素材：wall.jpg tailu.jpg tailr.jpg taill.jpg taild.jpg headup.jpg headright.jpg headleft.jpg headdown.jpg food.jpg bodylr.jpg gameover.jpg &ensp;record.txt 内容： 123330140110 yeah.mp3 ：游戏背景音乐。 yeah.wav ：蛇吃到食物时的哔声。 &ensp;&ensp; 程序写于大二上学期。 2016.4.12更新博客。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[贪吃蛇（Java实现）]]></title>
      <url>2016%2F03%2F13%2F%E8%B4%AA%E5%90%83%E8%9B%87Java%2F</url>
      <content type="text"><![CDATA[程序效果： 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268//Snake.javapackage snake;import javax.swing.*;import java.awt.*;import java.awt.event.*;import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;import java.util.Iterator;import java.util.LinkedList;import java.util.Random;class go implements Runnable &#123; Snake s; Random random; int foodX = 15, foodY = 15;int N; go(Snake snake) &#123; s = snake; random = new Random(); N=s.N; &#125; Point getFood() &#123; Point p = new Point(); Iterator&lt;Point&gt; it = s.list.iterator(); Point temp = it.next(); boolean isFoodinBody = true; while (isFoodinBody) &#123; foodX = Math.abs(random.nextInt()) % N; foodY = Math.abs(random.nextInt()) % N; isFoodinBody = false; while (it.hasNext()) &#123; temp = (Point) it.next(); if (foodX == temp.x &amp;&amp; temp.y == foodY) &#123; isFoodinBody = true; break; &#125; &#125; &#125; return p; &#125; public void run() &#123; while (true) &#123; Point first = s.list.getFirst(); int x = first.x, y = first.y; int gotfood = 0; if (foodX == x &amp;&amp; foodY == y) &#123; if (!s.isDead) &#123; s.SCORE += 100; s.scoreField.setText("SCORE: "+new Integer(s.SCORE).toString()); s.list.add(s.list.getLast()); &#125; gotfood = 1; foodX = Math.abs(random.nextInt()) % N; foodY = Math.abs(random.nextInt()) % N; s.bs[foodX][foodY].setBackground(Color.PINK); &#125; Iterator&lt;Point&gt; it = s.list.iterator(); Point temp = it.next(); while (it.hasNext()) &#123; temp = (Point) it.next(); if (temp.x == x &amp;&amp; temp.y == y) &#123; s.gameOver(); &#125; if (gotfood == 1 &amp;&amp; foodX == temp.x &amp;&amp; temp.y == foodY) &#123; Point food = getFood(); foodX = food.x; foodY = food.y; s.bs[foodX][foodY].setBackground(Color.PINK); gotfood=0; &#125; &#125; switch (s.dir) &#123; case 2 : y =( (y - 1)+N )% N; /*if (y == -1) y = 29;*/ break; case 0 : y = (y + 1) % N; break; case 3 : x = ((x - 1)+N) % N; /*if (x == -1) x = 29;*/ break; case 1 : x = (x + 1) % N; break; &#125; Point head = new Point(x, y); s.bs[x][y].setBackground(Color.LIGHT_GRAY); s.list.addFirst(head); Point lastP = s.list.removeLast(); s.bs[lastP.x][lastP.y].setBackground(Color.GRAY); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; /* * for (int i = 0; i &lt;= list.size() - 1; i++) &#123; System.out.print( * "(" + list.get(i).x + "," + list.get(i).y + ") "); * * &#125; */ // System.out.println(); &#125; &#125;&#125;public class Snake extends JFrame &#123; private static final long serialVersionUID = -6494984874207734357L; int N = 30; int dir = 0;// 0 右 1下 2左 3上 int SCORE = 0; int a=0,b=0,c=0; boolean isDead = false; JButton[][] bs = new JButton[N][N]; JPanel panel,scorePanel; JTextField scoreField,bestScoreField; LinkedList&lt;Point&gt; list; Snake() &#123; super("Snake"); Container container = getContentPane(); container.setLayout(new BorderLayout()); scorePanel = new JPanel(); scorePanel .setLayout(new BorderLayout()); scoreField = new JTextField(20); bestScoreField= new JTextField(50); bestScoreField.setText(getBestScores()); bestScoreField.setEditable(false); scoreField.setText("SCORE: "+new Integer(SCORE).toString()); scoreField.setEditable(false); scorePanel.add(scoreField,BorderLayout.WEST); scorePanel.add(bestScoreField,BorderLayout.EAST); container.add(scorePanel, BorderLayout.NORTH); panel = new JPanel(); panel.setLayout(new GridLayout(N, N)); for (int i = 0; i &lt;= N - 1; i++) &#123; for (int j = 0; j &lt;= N - 1; j++) &#123; bs[i][j] = new JButton(); bs[i][j].setBackground(Color.GRAY); panel.add(bs[i][j]); &#125; &#125; container.add(panel, BorderLayout.CENTER); list = new LinkedList&lt;Point&gt;(); list.add(new Point(15, 15)); list.add(new Point(15, 14)); list.add(new Point(15, 13)); list.add(new Point(15, 12)); list.add(new Point(15, 11)); for (int i = 0; i &lt;= list.size() - 1; i++) &#123; bs[list.get(i).x][list.get(i).y].setBackground(Color.LIGHT_GRAY); &#125; /*for (int i = 0; i &lt;= list.size() - 1; i++) &#123; System.out.print("(" + list.get(i).x + "," + list.get(i).y + ") "); &#125;*/ /*System.out.println();*/ this.addKeyListener(new KeyAdapter() &#123; public void keyPressed(KeyEvent e) &#123; int c = e.getKeyCode(); //System.out.print(c); int dir1 = dir; switch (c) &#123; case KeyEvent.VK_LEFT : dir1 = 2; break; case KeyEvent.VK_RIGHT : dir1 = 0; break; case KeyEvent.VK_UP : dir1 = 3; break; case KeyEvent.VK_DOWN : dir1 = 1; break; default : System.out.print("hey"); break; &#125; if (!(dir1 - dir == -2 | dir1 - dir == 2)) dir = dir1; &#125; &#125;); this.setFocusable(true); setLocation(200, 10); setSize(800, 700); setVisible(true); &#125; String getBestScores() &#123; BufferedReader reader=null; try &#123; reader=new BufferedReader(new FileReader("score.txt")); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; try &#123; a=Integer.parseInt(reader.readLine()); b=Integer.parseInt(reader.readLine()); c=Integer.parseInt(reader.readLine()); &#125; catch (NumberFormatException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; String bestS=new String("Best Score: "+new Integer(a).toString()+" "+new Integer(b).toString()+" "+new Integer(c).toString()); return bestS; &#125;int gameOver()&#123; isDead = true; JOptionPane.showMessageDialog(null, "你死了~~~.", "GAME OVER", JOptionPane.PLAIN_MESSAGE); if(SCORE&gt;a)&#123;c=b;b=a;a=SCORE;save();System.exit(0);&#125; if(SCORE&gt;b)&#123;c=b;b=SCORE;save();System.exit(0);&#125; if(SCORE&gt;c)&#123;c=SCORE;save();System.exit(0);&#125; System.exit(0); return 0;&#125;int save()&#123; BufferedWriter writer=null; try &#123; writer=new BufferedWriter(new FileWriter("score.txt")); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; String d=new Integer(a).toString(),e=new Integer(b).toString(),f=new Integer(c).toString(); try &#123; writer.write(d); writer.newLine(); writer.write(e); writer.newLine(); writer.write(f); writer.flush(); writer.close(); &#125; catch (NumberFormatException ev) &#123; ev.printStackTrace(); &#125; catch (IOException ev) &#123; ev.printStackTrace(); &#125; return 0;&#125; public static void main(String[] args) &#123; Snake snake = new Snake(); snake.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); Thread thread = new Thread(new go(snake)); thread.start(); &#125;&#125; 程序写于大三上学期。 2016.4.12更新博客。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[校园导游系统（C++实现，VC6.0编译，使用EasyX图形库）]]></title>
      <url>2016%2F03%2F13%2F%E6%A0%A1%E5%9B%AD%E5%AF%BC%E6%B8%B8%E7%B3%BB%E7%BB%9F%2F</url>
      <content type="text"><![CDATA[&ensp;运行效果： &ensp;&ensp;&ensp; 说明: 由于当年还不会使用多线程，所以很多获取用户点击的地方都是使用循环实现的。。。CPU占用率会比较高。 &ensp;&ensp;&ensp;&ensp; 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722//校园导游系统.cpp#include &lt;graphics.h&gt;#include &lt;conio.h&gt;#include &lt;stdio.h&gt;#include &lt;io.h&gt;#include &lt;stdlib.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;fstream&gt;#include "Stack.h"#include "functions.h"#include "Graph_List.h"#define WIDTH (1000+(LEFTBORDER*2))#define HEIGHT (574+TOPBORDER+LEFTBORDER)#define UP 72#define DOWN 80#define LEFT 75#define RIGHT 77#define BACKGROUND "background.jpg"#define BKCOLOR RGB(240,240,240) //原RGB(240,240,240)#define SELECTCOLOR RGB(255,0,0) //原RED#define TEXTCOLOR RGB(7,102,198)//GREEN// //原BLUE#define MENUCOLOR RGB(208,161,227)//RGB(77,197,131)//RGB(112,112,112)//RGB(117,75,144)//RGB(7,102,198) //原GREEN#define CheckCancel if(iscancel)&#123;return -1;&#125;using namespace std;Graph_List graph;int choose;int menunum = 11;int menutop1 = 10;int menutop = (menutop1 + 3);#define left (LEFTBORDER)int menuwidth = ((WIDTH - 2 * LEFTBORDER) / (menunum ));int menuheight = 30;int GetChoose();int FrontMenu(Graph_List &amp;graph );int ShowAllVertex(Graph_List &amp;graph);int ShowAllPath(Graph_List &amp;graph);int printroad(int dx, int dy, int sx, int sy) &#123; LINESTYLE linestyle; getlinestyle(&amp;linestyle); setlinestyle(PS_SOLID,3,NULL,0); setlinecolor(BLUE); line(sx,sy,dx,dy); setlinestyle(&amp;linestyle); double x1 = (sx + dx) / 2; double y1 = (sy + dy) / 2; double x2 = ((3.0 / 8.0) * sx + (5.0 / 8.0) * dx); double y2 = ((3.0 / 8.0) * sy + (5.0 / 8.0) * dy); //double x1=sx,x2=(sx+dx)/2,y1=sy,y2=(sy+dy)/2; double k1 = (y2 - y1) / (x2 - x1); double k2 = (-1) / k1; double delta = 1600; //=(y2-y1)*(y2-y1)+(x2-x1)*(x2-x1); double a = sqrt((delta / 16) / (1 + k2 * k2)); double b = a * fabs(k2); if(((x1 &gt; x2) &amp;&amp; (y1 &lt; y2)) || ((x1 &lt; x2) &amp;&amp; (y1 &gt; y2))) &#123; &#125; else &#123; b = -1 * b; &#125; if(x1 == x2) &#123; a = 5; b = 0; &#125; if(y1 == y2) &#123; a = 0; b = 3; &#125; POINT pts[] = &#123; &#123;x1, y1&#125;, &#123;x2 + a, y2 + b&#125;, &#123;(x1 + x2) / 2, (y1 + y2) / 2&#125;, &#125;; POINT pts1[] = &#123; &#123;x1, y1&#125;, &#123;x2 * 2 - (x2 + a), y2 * 2 - (y2 + b)&#125;, &#123;(x1 + x2) / 2, (y1 + y2) / 2&#125;, &#125;; setfillcolor(BLUE); solidpolygon(pts1, 3); solidpolygon(pts, 3); return 0;&#125;int GetMouseXY(int&amp; mousex,int&amp; mousey) &#123; MOUSEMSG temp; temp.mkLButton = false; bool kick = false; while(!kick) &#123; // if(MouseHit()) &#123; temp = GetMouseMsg(); FlushMouseMsgBuffer(); if(temp.mkLButton == false) &#123; mousex = temp.x; mousey = temp.y; &#125; else &#123; kick = temp.mkLButton ; &#125; // &#125; &#125; return 0;&#125;int AddVertex(Graph_List &amp;graph) &#123; LOGFONT font; gettextstyle(&amp;font); settextstyle(10, 0, _T("宋体")); BeginBatchDraw(); setlinecolor(GREEN); for(int lx = LEFTBORDER; lx &lt;= WIDTH; lx += 50) &#123; //outtextxy(lx, TOPBORDER - 10, &amp;int_to_str(lx - LEFTBORDER)[0]); line(lx, TOPBORDER, lx, HEIGHT - LEFTBORDER); &#125; for(int ly = TOPBORDER; ly &lt;= HEIGHT - LEFTBORDER; ly += 50) &#123; //outtextxy(10, ly - 5, &amp;int_to_str(ly - TOPBORDER)[0]); line(LEFTBORDER, ly, WIDTH - LEFTBORDER, ly); &#125; FlushBatchDraw(); setlinecolor(MENUCOLOR); settextstyle(&amp;font); ::MessageBox(GetHWnd(), "请在您要添加景点的位置点击", "添加景点", MB_OK); int mousex,mousey; GetMouseXY(mousex,mousey); char name[30]; bool iscancel = false; iscancel = !InputBox(&amp;(name[0]), 30, "输入名称" , "添加景点", "0", 0, 0, 0); CheckCancel char describe[1000]; iscancel = !InputBox(&amp;(describe[0]), 1000, "输入简介：(按Ctrl+Enter确认输入)" , "添加景点", "0", 0, 10, 0); CheckCancel char mark[10]; int marki; while(1) &#123; iscancel = !InputBox(&amp;(mark[0]), 10, "输入代号" , "添加景点", 0, 0, 0, 0); CheckCancel marki = str_to_num(mark); if(marki &gt; 0 &amp;&amp; graph.GetIndex(marki) == -1) &#123; break; &#125; ::MessageBox(GetHWnd(), "此代号已存在，请重输", "添加景点", MB_OK); &#125; string namestr = "", describestr = ""; graph.InsertVertex((string)(namestr + name), (string)(describestr + describe), marki, mousex, mousey); ::MessageBox(GetHWnd(), "添加成功", "添加景点", MB_OK); return 0;&#125;int AddPath(Graph_List &amp;graph) &#123; bool iscancel = false; int v1, v2; string source = "0000000000", destination = "0000000000", weightstr = "0000000000"; while(1) &#123; iscancel = !InputBox(&amp;(source[0]), 10, "输入起点代号" , "添加边", "0", 0, 0, 0); CheckCancel v1 = str_to_num(source); if(graph.GetIndex(v1) != -1) &#123; break; &#125; ::MessageBox(GetHWnd(), "该位置不存在，请重输", "添加边", MB_OK); &#125; while(1) &#123; iscancel = !InputBox(&amp;(destination[0]), 10, "输入终点代号", "添加边", "0", 0, 0, 0); CheckCancel v2 = str_to_num(destination); if(graph.GetIndex(v2) != -1) &#123; break; &#125; ::MessageBox(GetHWnd(), "该位置不存在，请重输", "添加边", MB_OK); &#125; double dx = graph.GetHead()[graph.GetIndex(v2)].GetX(); double sx = graph.GetHead()[graph.GetIndex(v1)].GetX(); double dy = graph.GetHead()[graph.GetIndex(v2)].GetY(); double sy = graph.GetHead()[graph.GetIndex(v1)].GetY(); double weight = (double)sqrt(((dx - sx) * (dx - sx) + (dy - sy) * (dy - sy)) / 24250.0) * 300.0; int retop=graph.InsertEdge(graph.GetIndex(v1), graph.GetIndex(v2), weight); if(retop==-3)&#123;::MessageBox(GetHWnd(), "起点与终点相同！", "添加边", MB_OK);return -3;&#125; if(retop==-4)&#123;::MessageBox(GetHWnd(), "边已存在！", "添加边", MB_OK);return -4;&#125; ::MessageBox(GetHWnd(), "添加成功", "添加边", MB_OK); return 0;&#125;int DeleteVertex(Graph_List &amp;graph)&#123; bool iscancel = false; char v[10]; int v1; while(1) &#123; iscancel = !InputBox(&amp;(v[0]), 10, "输入代号" , "删除景点", "0", 0, 0, 0); CheckCancel v1 = str_to_num(v); if(graph.GetIndex(v1)!= -1) &#123; break; &#125; ::MessageBox(GetHWnd(), "此代号不存在，请重输", "删除景点", MB_OK); &#125; graph.DeleteVertex(graph.GetIndex(v1)); return 0;&#125;int DeletePath(Graph_List &amp;graph) &#123; bool iscancel = false; int v1, v2; string source = "0000000000", destination = "0000000000"; while(1) &#123; iscancel = !InputBox(&amp;(source[0]), 10, "输入起点代号" , "删除边", "0", 0, 0, 0); CheckCancel v1 = str_to_num(source); if(graph.GetIndex(v1) != -1) &#123; break; &#125; ::MessageBox(GetHWnd(), "该位置不存在，请重输", "删除边", MB_OK); &#125; while(1) &#123; iscancel = !InputBox(&amp;(destination[0]), 10, "输入终点代号", "删除边", "0", 0, 0, 0); CheckCancel v2 = str_to_num(destination); if(graph.GetIndex(v2) != -1) &#123; break; &#125; ::MessageBox(GetHWnd(), "该位置不存在，请重输", "删除边", MB_OK); &#125; int retop=graph.DeleteEdge(graph.GetIndex(v1), graph.GetIndex(v2)); if(retop==-1)&#123;::MessageBox(GetHWnd(), "边不存在！", "删除边", MB_OK);return -1;&#125; ::MessageBox(GetHWnd(), "删除成功", "删除边", MB_OK); return 0;&#125;int DrawShortestPath(Graph_List &amp;graph, int v1, int v2) &#123; Vertex *Head = graph.GetHead(); int *path = new int [graph.NumberOfVertices()]; graph.DShortestPath(v1, path); LStack&lt;int &gt; stack; //stack.Push(v2); if(path[v2] == -1) &#123; ::MessageBox(GetHWnd(), "*** 无路径 ***", "查询路径", MB_OK); return -1; &#125; int i = v2; while(i != path[v1]) &#123; stack.Push(i); i = path[i]; &#125; delete []path; //stack.Push(v1); int temp = v1, temppre = v1, length = 0; string pathstr,tempstr; BeginBatchDraw(); while(!stack.IsEmpty()) &#123; stack.Pop(temp); printroad(Head[temppre].GetX(), Head[temppre].GetY(), Head[temp].GetX(), Head[temp].GetY()); int pathweight=graph.GetWeight(temppre, temp); length += pathweight; tempstr=tempstr+"从"+int_to_str(Head[temppre].GetMark())+"到"+int_to_str(Head[temp].GetMark())+" : "+int_to_str(pathweight)+" 米"+"\n"; temppre = temp; &#125; FlushBatchDraw(); setbkcolor(BKCOLOR); settextcolor(TEXTCOLOR); string str = "最短路径长度为："; str = str + int_to_str(length) + " 米\n"+"步行所需时间："+int_to_str(length/90)+"分钟\n"; str+=tempstr; ::MessageBox(GetHWnd(), &amp;str[0], "查询路径", MB_OK); return 0;&#125;int FindPath(Graph_List &amp;graph) &#123; bool iscancel = false; int v1, v2; string source = "0000000000", destination = "0000000000"; while(1) &#123; iscancel = !InputBox(&amp;(source[0]), 10, "输入起点代号" , "查询路径", "0", 0, 0, 0); CheckCancel v1 = str_to_num(source); if(graph.GetIndex(v1) != -1) &#123; break; &#125; ::MessageBox(GetHWnd(), "该位置不存在，请重输", "查询路径", MB_OK); &#125; while(1) &#123; iscancel = !InputBox(&amp;(destination[0]), 10, "输入终点代号", "查询路径", "0", 0, 0, 0); CheckCancel v2 = str_to_num(destination); if(graph.GetIndex(v2) != -1) &#123; break; &#125; ::MessageBox(GetHWnd(), "该位置不存在，请重输", "查询路径", MB_OK); &#125; DrawShortestPath(graph, graph.GetIndex(v1), graph.GetIndex(v2)); return 0;&#125;void ShowVertex(Graph_List &amp;graph, int i) &#123; Vertex *Head = graph.GetHead(); if(i &lt; 0 || i &gt; graph.NumberOfVertices() - 1) &#123; ::MessageBox(GetHWnd(), "查询位置不存在", "景点查询", MB_OK); //GetHWnd()获得窗口句柄 return ; &#125; string str = "代号：" +int_to_str(Head[i].GetMark()) + "\n" + "简介: " + Head[i].GetDescribe(); str = "名称：" + Head[i].GetVerName() + "\n" + str; ::MessageBox(GetHWnd(), &amp;str[0], "景点查询", MB_OK); //GetHWnd()获得窗口句柄&#125;int ModifyMenu() &#123; int choose1 = 1; char temp = 0, key; while(temp != '\r') &#123; if(kbhit()) &#123; key = getch(); fflush(stdin); switch(key) &#123; case UP: &#123; choose1--; &#125;; break; case DOWN: &#123; choose1++; &#125;; &#125; &#125; if(choose1 == 6) &#123; choose1 = 5; &#125; if(choose1 == 0) &#123; choose1 = 1; &#125; cleardevice(); outtextxy((WIDTH / 2) - 80, 120, "修改景点"); outtextxy((WIDTH / 2) - 180, 230, "按↑和↓选择选项"); outtextxy((WIDTH / 2) - 180, 250, "按ENTER键确定选择"); outtextxy(300, 300, "请选择选项："); outtextxy(420, 350, "修改名称"); outtextxy(420, 380, "修改简介"); outtextxy(420, 410, "修改代号"); outtextxy(420, 440, "修改坐标"); outtextxy(420, 470, "返回"); outtextxy(390, 350 + (choose1 - 1) * 30, "→"); FlushBatchDraw(); temp = getch(); &#125; return choose1;&#125;int ModifyVertex(Graph_List &amp;graph) &#123; bool iscancel = false; int v1; char v1str[10] = &#123;'a'&#125;; while(1) &#123; iscancel = !InputBox(&amp;(v1str[0]), 10, "输入代号" , "修改景点", "0", 0, 0, 0); CheckCancel v1= str_to_num(v1str); if(graph.GetIndex(v1) != -1) &#123; break; &#125; ::MessageBox(GetHWnd(), "该位置不存在，请重输", "修改景点", MB_OK); &#125; int v=graph.GetIndex(v1); Vertex *Head = graph.GetHead(); string name=Head[v].GetVerName(); string describe=Head[v].GetDescribe(); int marki=Head[v].GetMark(),x=Head[v].GetX()-LEFTBORDER,y=Head[v].GetY()-TOPBORDER; bool isreturn = false; while(!isreturn ) &#123; int in = ModifyMenu(); switch(in) &#123; case 1: &#123; iscancel = !InputBox(&amp;(name[0]), 30, "输入名称" , "修改景点", "0", 0, 0, 0); CheckCancel &#125;; break; case 2: &#123; iscancel = !InputBox(&amp;(describe[0]), 1000, "输入简介：(按Ctrl+Enter确认输入)" , "修改景点", "0", 0, 10, 0); CheckCancel &#125;; break; case 3: &#123; char mark[10]; while(1) &#123; iscancel = !InputBox(&amp;(mark[0]), 10, "输入代号" , "修改景点", 0, 0, 0, 0); CheckCancel marki = str_to_num(mark); if(marki &gt; 0 &amp;&amp; (marki == Head[v].GetMark() || graph.GetIndex(marki) == -1)) &#123; break; &#125; ::MessageBox(GetHWnd(), "输入有误或代号已存在，请重输", "修改景点", MB_OK); &#125; &#125;; break; case 4: &#123; char xstr[10], ystr[10]; while(1) &#123; iscancel = !InputBox(&amp;(xstr[0]), 10, "输入X坐标" , "修改景点", "0", 0, 0, 0); CheckCancel x = str_to_num(xstr); if(x &gt; 0 &amp;&amp; x &lt; WIDTH) &#123; break; &#125; ::MessageBox(GetHWnd(), "您所输入的坐标不在图像范围内", "修改景点", MB_OK); &#125; while(1) &#123; iscancel = !InputBox(&amp;(ystr[0]), 10, "输入Y坐标" , "修改景点", "0", 0, 0, 0); CheckCancel y = str_to_num(ystr); if(y &gt; 0 &amp;&amp; y &lt; HEIGHT) &#123; break; &#125; ::MessageBox(GetHWnd(), "您所输入的坐标不在图像范围内", "修改景点", MB_OK); &#125; &#125;; break; case 5: &#123; graph.ModifyVertex(v, name,describe, marki, x, y); ShowVertex(graph, v); isreturn = true; &#125;; break; default: &#123;&#125;; break; &#125; &#125; return 0;&#125;int ShowAllVertex(Graph_List &amp;graph)&#123; Vertex *Head = graph.GetHead(); //putimage(LEFTBORDER, TOPBORDER, graph.GetMap()); setbkcolor(RGB(240, 240, 240)); settextcolor(RED); setfillcolor(RGB(255,0,0)); LOGFONT font1; gettextstyle(&amp;font1); settextstyle(font1.lfHeight - 2, 0, _T("宋体")); for(int i = 0; i &lt;= graph.NumberOfVertices() - 1; i++) &#123; int x = Head[i].GetX(), y = Head[i].GetY(); string str = ""; str += int_to_str(Head[i].GetMark()); if(Head[i].GetVerName() != "*") str = str + " " + Head[i].GetVerName(); solidcircle(x,y,4); outtextxy( x, y, &amp;str[0]); &#125; settextstyle(&amp;font1); FlushBatchDraw(); return 0;&#125;int ShowAllPath(Graph_List &amp;graph) &#123; LINESTYLE linestyle; getlinestyle(&amp;linestyle); setlinestyle(PS_SOLID,3,NULL,0); setlinecolor(BLUE); for(int i=0;i&lt;=graph.NumberOfVertices()-1;i++)&#123; Edge* p=graph.GetHead()[i].Getadj(); while(p!=NULL)&#123; line(graph.GetHead()[i].GetX(),graph.GetHead()[i].GetY(),graph.GetHead()[p-&gt;GetVerAdj()].GetX(),graph.GetHead()[p-&gt;GetVerAdj()].GetY()); p=p-&gt;Getlink(); &#125; &#125; setlinestyle(&amp;linestyle); FlushBatchDraw(); return 0;&#125;int FindMenu() &#123; int choose1 = 1; char temp = 0, key; while(temp != '\r') &#123; if(kbhit()) &#123; key = getch(); fflush(stdin); switch(key) &#123; case UP: &#123; choose1--; &#125;; break; case DOWN: &#123; choose1++; &#125;; &#125; &#125; if(choose1 == 4) &#123; choose1 = 3; &#125; if(choose1 == 0) &#123; choose1 = 1; &#125; cleardevice(); outtextxy((WIDTH / 2) - 80, 120, "查询景点"); outtextxy((WIDTH / 2) - 180, 230, "按↑和↓选择选项"); outtextxy((WIDTH / 2) - 180, 250, "按ENTER键确定选择"); outtextxy(300, 300, "请选择选项："); outtextxy(420, 350, "按代号查询"); outtextxy(420, 380, "按名称查询"); outtextxy(420, 410, "返回"); outtextxy(390, 350 + (choose1 - 1) * 30, "→"); FlushBatchDraw(); temp = getch(); &#125; return choose1;&#125;int FindVertex(Graph_List &amp;graph) &#123; bool iscancel = false; bool isreturn = false; while(!isreturn ) &#123; int in = FindMenu(); switch(in) &#123; case 1: &#123; char v1str[10] = &#123;'a'&#125;; int v1; iscancel = !InputBox(&amp;(v1str[0]), 10, "输入代号" , "查询景点", "0", 0, 0, 0); CheckCancel v1 = str_to_num(v1str); ShowVertex(graph, graph.GetIndex(v1)); &#125;; break; case 2: &#123; char v1str[10] = &#123;'a'&#125;; string v1; iscancel = !InputBox(&amp;(v1str[0]), 10, "输入名称" , "查询景点", "0", 0, 0, 0); CheckCancel v1 = ""; v1 += v1str; ShowVertex(graph, graph.GetIndex(v1)); &#125;; break; case 3: &#123; isreturn = true; &#125;; break; default: &#123;&#125;; break; &#125; &#125; return 0;&#125;int Open(Graph_List &amp;graph, bool isfirstopen) &#123; fstream filestr; char mapname[256] = &#123;'a'&#125;; if(isfirstopen) &#123; filestr.open ("map.txt"); strcpy(mapname, "map.jpg"); &#125; else &#123; bool iscancel = false; char filename[256] = &#123;'a'&#125;; while(1) &#123; iscancel = !InputBox(&amp;(filename[0]), 10, "输入文本文件名(不需输'.txt')" , "打开", "0", 0, 0, 0); CheckCancel strcat(filename, ".txt"); filestr.open (filename); if (filestr.is_open()) &#123; break; &#125; ::MessageBox(GetHWnd(), "无此文件，请重输", "打开", MB_OK); &#125; while(1) &#123; iscancel = !InputBox(&amp;(mapname[0]), 10, "输入图片文件名(不需输'.jpg')" , "打开", "0", 0, 0, 0); CheckCancel strcat(mapname, ".jpg"); if( (_access(mapname, 0 )) != -1 ) &#123; break; &#125; ::MessageBox(GetHWnd(), "无此文件，请重输", "打开", MB_OK); &#125; &#125; graph.graph_con(filestr, mapname); filestr.close(); putimage(LEFTBORDER, TOPBORDER, graph.GetMap()); return 0;&#125;int Save(Graph_List &amp;graph) &#123; bool iscancel = false; Vertex *Head = graph.GetHead(); char filename[256] = &#123;'a'&#125;; iscancel = !InputBox(&amp;(filename[0]), 10, "输入文本文件名(不需输'.txt')" , "保存", "0", 0, 0, 0); CheckCancel strcat(filename, ".txt"); graph.SaveFile(filename); ::MessageBox(GetHWnd(), "保存成功", "保存", MB_OK); return 0;&#125;int GetChoose() &#123; FlushMouseMsgBuffer(); MOUSEMSG temp; temp.mkLButton = false; bool kick = false; while(!kick) &#123; // if(MouseHit()) &#123; temp = GetMouseMsg(); FlushMouseMsgBuffer(); if(temp.mkLButton == false) &#123; &#125; else &#123; if(temp.y &lt; menutop + menuheight &amp;&amp;temp. y &gt; menutop) &#123; kick = true; &#125; &#125; // &#125; &#125; choose = (temp.x - left) / menuwidth; return 0;&#125;int FrontMenu(Graph_List &amp;graph) &#123; fflush(stdin); settextcolor(TEXTCOLOR); setfillcolor(BKCOLOR); solidrectangle(5, TOPBORDER, WIDTH, HEIGHT); //以背景色刷新 setfillcolor(MENUCOLOR); solidrectangle(5, 0, WIDTH - 5, menutop1); //画最上方的绿色条 putimage(LEFTBORDER, TOPBORDER, graph.GetMap()); setfillcolor(BKCOLOR); solidrectangle(LEFTBORDER, menutop + textheight('a'), WIDTH - LEFTBORDER, menutop + textheight('a') + 5); //去掉选中的菜单下方的小绿块 setfillcolor(TEXTCOLOR); setfillcolor(MENUCOLOR); solidrectangle(choose * menuwidth + left, menutop + textheight('a'), (choose + 1)*menuwidth + left, menutop + textheight('a') + 5); //画选中的菜单下方的小绿块 roundrect(5, menutop + textheight('a') + 5, WIDTH - 5, HEIGHT - 5, 5, 3); //画图片周围的绿色边框 solidrectangle(5, menutop + textheight('a') + 5, WIDTH - 5, menutop + textheight('a') + 10); //画图片上方与小绿块相连的绿色条 setfillcolor(TEXTCOLOR); LOGFONT font1; gettextstyle(&amp;font1); settextstyle(font1.lfHeight, 0, _T("宋体")); string menu[11] = &#123;" 打开", " 显示", " 查询路径", " 查询景点", " 修改景点", " 添加景点", " 删除景点", " 添加边", " 删除边"," 保存", " 退出"&#125;; for(int index = 0; index &lt;= menunum - 1; index++) &#123; if(index == choose)settextcolor(SELECTCOLOR); const char *p = menu[index].c_str(); outtextxy(left + index * menuwidth, menutop, p); if(index == choose)settextcolor(TEXTCOLOR); &#125; settextstyle(&amp;font1); setlinecolor(MENUCOLOR); for(int index1 = 0; index1 &lt;= menunum + 1; index1++) &#123; line(left + index1 * menuwidth, menutop, left + index1 * menuwidth, menutop + textheight('a')); &#125; LOGFONT font; gettextstyle(&amp;font); settextstyle(10, 0, _T("宋体")); settextcolor(TEXTCOLOR); for(int lx = LEFTBORDER; lx &lt;= WIDTH; lx += 50) &#123; outtextxy(lx, TOPBORDER - 10, &amp;int_to_str(lx - LEFTBORDER)[0]); &#125; for(int ly = TOPBORDER; ly &lt;= HEIGHT - LEFTBORDER; ly += 50) &#123; outtextxy(10, ly - 5, &amp;int_to_str(ly - TOPBORDER)[0]); &#125; settextstyle(&amp;font); settextcolor(TEXTCOLOR); FlushBatchDraw(); setbkcolor(BKCOLOR); settextcolor(TEXTCOLOR); return choose;&#125;int main() &#123; graph; initgraph(WIDTH, HEIGHT); //,0);//SHOWCONSOLE|NOMINIMIZE setbkcolor(BKCOLOR); cleardevice(); //int in = INT_MIN; //FrontMenu(graph); bool isfirstopen = true; while(1) &#123; FrontMenu(graph); //ShowAllVertex( graph); if(isfirstopen) &#123; choose = 0; &#125; else &#123; GetChoose( ); &#125; FrontMenu(graph); //ShowAllVertex( graph); switch(choose) &#123; case 0: &#123; Open(graph, isfirstopen); isfirstopen = false; &#125; break; case 1: &#123; ShowAllPath(graph); ShowAllVertex( graph); int vertexnum =graph.NumberOfVertices(),edgenum=graph.NumberOfEdges(); string numofvertices; numofvertices = "图中共有景点 " + int_to_str(vertexnum) + " 个\n"+"共有边 " + int_to_str(edgenum) + " 条\n"; ::MessageBox(GetHWnd(), &amp;numofvertices[0], "显示", MB_OK); &#125; break; case 2: &#123; ShowAllVertex( graph); FindPath(graph); ShowAllVertex( graph); &#125;; break; case 3: &#123; ShowAllVertex( graph); FindVertex(graph); &#125;; break; case 4: &#123; ShowAllVertex( graph); ModifyVertex(graph ); &#125;; break; case 5: &#123; ShowAllVertex( graph); AddVertex(graph); &#125;; break; case 6: &#123; ShowAllVertex( graph); DeleteVertex(graph); &#125;; break; case 7: &#123; ShowAllPath(graph); ShowAllVertex( graph); AddPath( graph); &#125; break; case 8: &#123; ShowAllPath(graph); ShowAllVertex( graph); DeletePath(graph); &#125; break; case 9: &#123; Save(graph); &#125; break; case 10: &#123; WinExec(_T("taskkill /f /im conhost.exe /t"), 1); //WinExec(_T("taskkill /f /im 校园导游系统.exe /t"), 1); exit(0); &#125; break; default: &#123; &#125; break; &#125; &#125; return 0;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474//Graph_List.h//******************************** 类定义 ***************************************//#ifndef _MYGraph_List_h_#define _MYGraph_List_h_#define LEFTBORDER 30#define TOPBORDER 50#include&lt;string&gt;#include &lt;fstream&gt;#include &lt;graphics.h&gt;class Edge&#123;private: int VerAdj; int cost; Edge *link;public: Edge() &#123; VerAdj = -1; cost = -1; link = NULL; &#125; Edge(int VerAdji, int costi,Edge *linki): VerAdj(VerAdji), cost(costi),link(linki) //初始化 &#123; &#125; int &amp;GetVerAdj() &#123; return VerAdj; &#125; int &amp;Getcost() &#123; return cost; &#125; Edge *&amp;Getlink() &#123; return link; &#125;&#125;;class Vertex&#123;private: string VerName; string Describe; Edge *adjacent; int mark; int x; int y;public: Vertex() &#123; VerName = "*"; Describe = "*"; adjacent = NULL; mark=-1; x=-1; y=-1; &#125; string &amp;GetVerName() &#123; return VerName; &#125; string &amp;GetDescribe () &#123; return Describe; &#125; Edge *&amp;Getadj() &#123; return adjacent; &#125; int &amp; GetMark() &#123; return mark; &#125; int &amp; GetX() &#123; return x; &#125; int &amp; GetY() &#123; return y; &#125;&#125;;class Graph_List&#123;private: Vertex *Head; int graphsize; int MaxCost; IMAGE* map; int InsertEdge_Do(const int &amp;v1, const int &amp;v2, int weight) //插入时尽量保证顺序排列 &#123; if(Head[v1].Getadj() == NULL) &#123; Head[v1].Getadj() = new Edge(v2, weight, NULL); //若邻接表为空 直接在adjacent后添加边 return 0; &#125; Edge *p = Head[v1].Getadj(); Edge *pt = p; while((p != NULL)&amp;&amp;(p-&gt;GetVerAdj() &lt; v2)) &#123; pt = p; p = p-&gt;Getlink(); &#125; if(p == NULL) &#123; //到邻接表末端仍然比v2小 pt-&gt;Getlink() = new Edge(v2, weight, NULL); return 0; &#125; if(p == Head[v1].Getadj() &amp;&amp; p-&gt;GetVerAdj() &gt; v2) &#123; //邻接表第一个就比v2大 Edge *q = new Edge(v2, weight, NULL); q-&gt;Getlink() = p; Head[v1].Getadj() = q; return 0; &#125; if(p-&gt;GetVerAdj() == v2) &#123; return -4; //插入边已存在 返回-4 &#125; if(p != Head[v1].Getadj() &amp;&amp; p-&gt;GetVerAdj() &gt; v2) &#123; //正常在邻接表中间添加的情况 Edge *q = new Edge(v2, weight, NULL); pt-&gt;Getlink() = q; q-&gt;Getlink() = p; return 0; &#125; return 0; &#125; int DeleteEdge_Do(const int &amp;v1, const int &amp;v2) &#123; Edge *p = Head[v1].Getadj(); if(p == NULL) &#123; return -1; //返回-1表示所删除的边不存在 &#125; if(p-&gt;GetVerAdj() == v2) //邻接表第一个就是v2的情况 &#123; Head[v1].Getadj() = p-&gt;Getlink(); delete p; return 0; &#125; Edge *pt = p; while(p != NULL) &#123; if(p-&gt;GetVerAdj() == v2) &#123; pt-&gt;Getlink() = p-&gt;Getlink(); delete p; break; &#125; pt = p; p = p-&gt;Getlink(); &#125; if(p == NULL) //到邻接表末端仍未找到v2 则边不存在 &#123; return -1; //返回-1表示所删除的边不存在 &#125; return 0; &#125; int DeleteGraph_List() &#123; for(int i = 0; i &lt;= graphsize - 1; i++) &#123; Edge *p = Head[i].Getadj(); Edge *q = p; while(p != NULL) &#123; p = p-&gt;Getlink(); delete q; q = p; &#125; &#125; delete [] Head; delete map; return 0; &#125;public: int&amp; GetMaxCost() &#123; return MaxCost; &#125; Vertex*&amp; GetHead() &#123; return Head; &#125; IMAGE *&amp; GetMap() &#123; return map; &#125; int GetIndex(int marki) //按代号查找在顶点表中的位置 &#123; for(int i = 0; i &lt;= graphsize - 1; i++) &#123; if(marki == Head[i].GetMark()) &#123; return i; &#125; &#125; return -1; //找不到则返回-1 &#125; int GetIndex(string name) //按名称查找在顶点表中的位置 &#123; for(int i = 0; i &lt;= graphsize - 1; i++) &#123; if(name == Head[i].GetVerName()) &#123; return i; &#125; &#125; return -1; //找不到则返回-1 &#125; int graph_con(fstream &amp;file,char* mapname) //插入边创建 &#123; DeleteGraph_List();//先把类里面之前的内容删除掉 map=new IMAGE; loadimage(map, _T(mapname)); file &gt;&gt; MaxCost; file &gt;&gt; graphsize; Head = new Vertex[graphsize]; for(int i = 0; i &lt;= graphsize - 1; i++) &#123; file &gt;&gt; Head[i].GetVerName(); file &gt;&gt; Head[i].GetDescribe(); file &gt;&gt; Head[i].GetMark(); file &gt;&gt; Head[i].GetX(); Head[i].GetX()+=LEFTBORDER; //加左边界 file &gt;&gt; Head[i].GetY(); Head[i].GetY()+=TOPBORDER; //加上边界 Head[i].Getadj() = NULL; &#125; int edgenum; file &gt;&gt; edgenum; for(int j = 0; j &lt;= edgenum - 1; j++) &#123; int v1, v2, weight; file &gt;&gt; v1; file &gt;&gt; v2; double dx=Head[GetIndex(v2)].GetX(); double sx=Head[GetIndex(v1)].GetX(); double dy=Head[GetIndex(v2)].GetY(); double sy=Head[GetIndex(v1)].GetY();weight=(double)sqrt(((dx-sx)*(dx-sx)+(dy-sy)*(dy-sy))/24250.0)*300.0; //通过坐标计算边长度 赋给weight InsertEdge(GetIndex(v1),GetIndex(v2), weight); &#125; return 0; &#125; Graph_List() //构造函数 构造一个空图 &#123; Head=NULL; map=NULL; map=new IMAGE; graphsize=0; MaxCost=0; &#125; ~Graph_List()&#123; DeleteGraph_List(); &#125; int SaveFile(char* filename)&#123; system("del filename "); //删除文件 ofstream fl(filename);//打开文件用于写，若文件不存在就创建它 if(!fl)return -1;//打开文件失败则结束运行 fl &lt;&lt; GetMaxCost() &lt;&lt; endl; fl &lt;&lt; NumberOfVertices() &lt;&lt; endl; for(int i = 0; i &lt;= NumberOfVertices() - 1; i++) &#123; fl &lt;&lt; Head[i].GetVerName() &lt;&lt; "\t\t\t" &lt;&lt; Head[i].GetDescribe() &lt;&lt; "\t\t\t\t\t\t" &lt;&lt; Head[i].GetMark() &lt;&lt; "\t" &lt;&lt; Head[i].GetX() - LEFTBORDER &lt;&lt; "\t" &lt;&lt; Head[i].GetY() - TOPBORDER &lt;&lt; endl; &#125; //用制表符对齐 fl &lt;&lt; endl; int numofedges =NumberOfEdges() * 2; fl &lt;&lt; numofedges &lt;&lt; endl; int num = 0; for(int j = 0; j &lt;= NumberOfVertices() - 1; j++) &#123; Edge *p = Head[j].Getadj(); while(p != NULL) &#123; if(num == 5) &#123; fl &lt;&lt; endl; num = 0; &#125; fl &lt;&lt; GetHead()[j].GetMark() &lt;&lt; "\t" &lt;&lt; GetHead()[p-&gt;GetVerAdj()].GetMark() &lt;&lt; endl; p = p-&gt;Getlink(); num++; &#125; &#125; fl.close(); return 0; &#125; bool GraphEmpty()const &#123; return graphsize == 0; &#125; int NumberOfVertices ()const &#123; return graphsize; &#125; int NumberOfEdges ()const &#123; int n = 0; for(int i = 0; i &lt;= graphsize - 1; i++) &#123; Edge *p = Head[i].Getadj(); while(p != NULL) &#123; n++; p = p-&gt;Getlink(); &#125; &#125; return n / 2; //返回边的数目 不计重复边 &#125; int GetWeight(const int &amp;v1, const int &amp;v2) &#123; if(v1 &gt; graphsize - 1 || v2 &gt; graphsize - 1 || v1 &lt; 0 || v2 &lt; 0) &#123; //cout &lt;&lt; "查找元素超界！" &lt;&lt; endl; return -1; &#125; if(v1 == v2) /////// &#123; return 0; &#125; Edge *p = Head[v1].Getadj(); while(p != NULL &amp;&amp; p-&gt;GetVerAdj() != v2) &#123; p = p-&gt;Getlink(); &#125; if(p != NULL) &#123; return p-&gt;Getcost(); &#125; else return MaxCost + 1; //两点之间没有边则返回 MaxCost + 1 &#125; void InsertVertex(string name,string describe,int mark,int x,int y) &#123; Vertex *head = new Vertex[graphsize + 1]; //创建一个新的顶点表 大小为现有大小再加1 for(int i = 0; i &lt;= graphsize - 1; i++) //复制现有顶点表的内容到新顶点表 &#123; head[i] = Head[i]; &#125; head[graphsize].GetVerName() = name; //把新添加的顶点加在新顶点表最后一个位置 head[graphsize].GetDescribe() = describe; head[graphsize].GetMark() = mark; head[graphsize].GetX() = x; head[graphsize].GetY() = y; head[graphsize].Getadj() = NULL; delete [] Head; //删除原顶点表 Head = head; //把Head指针指向新顶点表 graphsize++; //更新顶点数目 &#125; int InsertEdge(int v1,int v2, int weight) &#123; if(v1 &gt; graphsize - 1 || v2 &gt; graphsize - 1 || v1 &lt; 0 || v2 &lt; 0) &#123; //cerr &lt;&lt; "插入元素超界！无法完成操作！" &lt;&lt; endl; return -1; //插入元素超界返回-1 &#125; if(weight &gt; MaxCost) &#123; //cerr &lt;&lt; "插入权值超出最大权值！无法完成操作！" &lt;&lt; endl; return -2; //返回-2表示权值过大 &#125; if(v1 == v2) &#123; //cerr &lt;&lt; "操作不合法" &lt;&lt; endl; return -3; &#125; int i=InsertEdge_Do(v1, v2, weight); if(i==-4)&#123; //边已存在 return i; &#125; InsertEdge_Do(v2, v1, weight); return i; &#125; int DeleteVertex(const int &amp;v) &#123; if(v &gt; graphsize - 1 || v &lt; 0) &#123; //cerr &lt;&lt; "删除元素超界！" &lt;&lt; endl; return -1; //超界返回-1 &#125; for(int i = 0; i &lt;= graphsize - 1; i++) &#123; DeleteEdge(i, v); //删除指向该顶点的所有边 &#125; for(int j = v; j &lt;= graphsize - 2; j++) &#123; Head[j] = Head[j + 1]; //把该顶点后边的元素向前挪一个位置 &#125; graphsize--; //更新graphsize for(int k = 0; k &lt;= graphsize - 1; k++) &#123; Edge *p = Head[k].Getadj(); while(p != NULL) &#123; if(p-&gt;GetVerAdj() &gt; v) &#123; p-&gt;GetVerAdj()--; //所有边之中指向所删除顶点之后位置的 都要减1 &#125; p = p-&gt;Getlink(); &#125; &#125; return 0; &#125; int ModifyVertex(int v,string&amp; name,string&amp; describe,int&amp; marki,int&amp; x,int&amp; y)&#123; if(v &lt; 0 || v &gt; NumberOfVertices() - 1) &#123; return -1; &#125; Head[v].GetVerName() = name; Head[v].GetDescribe() = describe; Head[v].GetMark() = marki; Head[v].GetX() = x; Head[v].GetX() += LEFTBORDER; Head[v].GetY() = y; Head[v].GetY() += TOPBORDER; return 0; &#125; int DeleteEdge(int v2, int v1) &#123; if(v1 &gt; graphsize - 1 || v2 &gt; graphsize - 1 || v1 &lt; 0 || v2 &lt; 0) &#123; //cerr &lt;&lt; "删除元素超界！" &lt;&lt; endl; return -1; &#125; if(v1 == v2) &#123; return -1; &#125; int i=DeleteEdge_Do(v1,v2); if(i==-1)&#123;return i;&#125; DeleteEdge_Do(v2,v1); return i; &#125; int DShortestPath(const int v,int*&amp; path) &#123; int n = graphsize; int *s = new int[n]; int *dist = new int[n]; int i = 0, temp = 0; for (i = 0; i &lt; n; i++) &#123; s[i] = 0; dist[i] = MaxCost*graphsize*(graphsize-1)/2; path[i] = -1; &#125; int u = v; Edge *p = NULL; dist[u] = 0; s[u] = 1; path[u] = u; for (i = 0; i &lt; n; i++) &#123; s[u] = 1; p = Head[u].Getadj(); while (p != NULL) &#123; temp = p-&gt;GetVerAdj(); if (dist[u] + p-&gt;Getcost ()&lt; dist[temp]) &#123; dist[temp] = dist[u] + p-&gt;Getcost(); path[temp] = u; &#125; p = p-&gt;Getlink(); &#125; temp =MaxCost*graphsize*(graphsize-1)/2;; for (int j = 0; j &lt; n; j++) &#123; if (s[j] == 0 &amp;&amp; dist[j] &lt; temp) &#123; temp = dist[j]; u = j;//未访问中最小 &#125; &#125; &#125; delete[]s; delete[]dist; return 0; &#125;&#125;;#endif 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091//Stack.h#ifndef _MYStack_h_#define _MYStack_h_template&lt;class TL&gt;class LStack;//结点定义template&lt;class TL&gt;class LStackNode&#123;private: TL data; LStackNode&lt;TL&gt;* next;public: friend class LStack&lt;TL&gt;; LStackNode() &#123; next=NULL; &#125; LStackNode(TL item,LStackNode&lt;TL&gt;* nextnode=NULL) &#123; data=item; next=nextnode; &#125; LStackNode(LStackNode&lt;TL&gt;&amp; node) &#123; data=node.data; // 为什么必须是引用&amp;才行 next=node.next; &#125;&#125;;//栈定义template&lt;class TL&gt;class LStack&#123;private: LStackNode&lt;TL&gt; * top;public: LStack() &#123; top=NULL; &#125; bool Push(const TL&amp; item) &#123; LStackNode&lt;TL&gt;* p=top; top=new LStackNode&lt;TL&gt;; top-&gt;data=item; top-&gt;next=p; return true; &#125; bool Pop( TL&amp; item) &#123; if(top==NULL) &#123; return false; &#125; else &#123; item=top-&gt;data; LStackNode&lt;TL&gt; * p=top; top=top-&gt;next; delete p; &#125; return true; &#125; bool Peek( TL&amp; item) &#123; if(top==NULL) &#123; return false; &#125; else &#123; item=top-&gt;data; &#125; &#125; ~LStack() &#123; LStackNode&lt;TL&gt;* p=top; while(top!=NULL) &#123; top=top-&gt;next; delete p; p=top; &#125; top=p=NULL; &#125; bool IsEmpty() &#123; return top==NULL; &#125;&#125;; #endif 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//functions.h#ifndef _Functions_h_#define _Functions_h_#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;math.h&gt;#include &lt;sstream&gt;using namespace std;string int_to_str(int n)&#123; std::stringstream ss; std::string str; ss&lt;&lt;n; ss&gt;&gt;str; return str;&#125;int str_to_num1(const char*&amp; str)&#123; if(!(str[0]=='-'||(str[0]&gt;='0'&amp;&amp;str[0]&lt;='9')))&#123; return INT_MIN; &#125; int n=0; while(str[n]!='\0')&#123; n++; &#125; int number=0; if(str[0]!='-')&#123; for(int i=0;i&lt;n;i++)&#123; if(!(str[i]&gt;='0'&amp;&amp;str[i]&lt;='9'))&#123; return INT_MIN; &#125; number+=(str[i]-'0')*pow(10,n-i-1); &#125; &#125; if(str[0]=='-')&#123; for(int i=1;i&lt;n;i++)&#123; if(!(str[i]&gt;='0'&amp;&amp;str[i]&lt;='9'))&#123; return INT_MIN; &#125; number+=(str[i]-'0')*pow(10,n-i-1); &#125; number*=-1; &#125; return number;&#125;int str_to_num(const string&amp; str)&#123; const char* data=str.c_str(); int number=str_to_num1(data); return number;&#125;#endif &ensp;&ensp;&ensp;&ensp; 资源文件：map.txt内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837994东门 学校正门 1 974 182图书馆 一楼可自习，可通宵 2 693 210计算机楼 计算机学院和软件学院公用实验教学楼 3 665 335第三教学楼 一教二教不在本校区╮(╯_╰)╭ 4 739 277逸夫楼 公共教学楼 5 585 147北门 最繁忙的学校大门 6 528 25办公楼 行政人员办公楼 7 528 219四食堂 最小食堂，却居于最重要位置 8 420 252体育馆 大型活动举办地 9 440 300体育运动场 主体育场 10 325 277南苑 学生公寓 11 380 460小北门 小校门 12 365 129经信教学楼 经济信息学院教学楼 13 149 448北苑 学生公寓 14 215 169新食堂 食堂，有两层 15 252 383李四光楼 地质教学楼 16 34 343* * 17 202 427* * 18 213 245* * 19 261 237* * 20 249 194* * 21 475 235* * 22 346 200* * 23 388 183* * 24 399 321* * 25 299 362* * 26 447 157* * 27 497 276* * 28 529 352* * 29 649 297* * 30 759 210* * 31 651 211* * 32 545 256* * 33 978 10* * 34 439 140音乐厅 音乐厅 35 489 125逸夫图书馆 校史陈列馆 36 496 147麦克德尔米德实验室 实验室 37 568 115* * 38 21 303* * 39 760 182唐敖庆楼 唐敖庆楼 40 757 125* * 41 758 151* * 42 650 154* * 43 597 175* * 44 521 205外语楼 外语学院教学楼 45 550 115篮球场 新食堂篮球场 46 231 340匡亚明楼 匡亚明楼 47 614 375* * 48 596 321南门 南门 49 479 521* * 50 517 324莘子园食堂 莘子园食堂 51 365 369* * 52 354 340* * 53 572 459* * 54 432 397* * 55 446 430* * 56 453 451* * 57 551 410* * 58 637 420* * 59 688 389* * 60 274 276* * 61 239 299* * 62 114 303* * 63 136 338* * 64 72 383* * 65 170 363* * 66 202 404* * 67 648 176* * 68 464 205* * 69 315 422* * 70 373 395* * 71 419 375* * 72 330 478* * 73 272 488* * 74 260 441* * 75 201 507* * 76 201 459经信公寓 经信公寓 77 277 525* * 78 658 317* * 79 132 453西门 西门 80 66 488物理楼 物理楼 81 644 83生科楼 生命科学楼 82 859 81* * 83 861 180* * 84 862 259东荣 0 85 804 211数学楼 数学学院数学楼 86 913 259* * 87 711 85* * 88 718 56* * 89 789 57* * 90 796 80* * 91 861 207* * 92 861 150* * 93 410 226* * 94 511 1841 33 83 30 31 59 78 29 30 78 85 37 43 12 33 35 37 81 21 32 44 9 21 93 8 24 27 50 19 22 24 25 55 72 6 20 23 34 17 79 20 38 25 66 20 38 62 64 13 66 76 19 62 10 18 20 22 60 12 14 16 19 7 8 26 27 10 19 23 24 12 22 26 93 9 10 22 52 71 10 15 52 60 69 21 23 34 9 21 32 50 48 50 53 54 4 31 32 48 78 2 4 39 85 2 29 32 43 67 7 27 29 31 1 6 12 26 35 6 34 36 35 45 94 5 6 45 81 14 16 30 40 41 67 83 39 39 42 92 41 43 67 81 5 31 42 44 67 7 43 94 36 37 61 66 48 58 28 29 47 53 56 9 27 28 52 70 24 25 51 28 49 58 28 55 71 11 54 56 49 55 57 56 47 53 59 3 58 19 25 61 46 60 65 16 18 63 62 64 65 16 63 79 61 63 66 15 17 46 65 31 39 42 43 93 94 25 70 72 74 51 69 71 24 54 70 11 69 73 72 74 75 77 69 73 76 73 76 17 74 75 73 3 4 29 13 64 80 79 6 37 42 87 90 92 1 39 91 92 86 91 4 30 91 84 81 88 87 89 88 90 82 89 83 84 85 41 82 83 8 23 68 36 44 68 map.jpg 大二上学期数据结构课程设计写此程序。 2016.4.12更新博客。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[五子棋估值算法]]></title>
      <url>2015%2F09%2F21%2F%E4%BA%94%E5%AD%90%E6%A3%8B%2F</url>
      <content type="text"><![CDATA[目录 程序布局 估值算法 成果 完整代码 &ensp;&ensp;&ensp;&ensp; 程序布局首先说明整个五子棋程序的整体布局。（用Java实现）1234567891011121314151617181920212223242526class Chess&#123; //界面类 Player player1 ; Player player2; ChessBox box; //其余界面显示相关函数;&#125;class Player&#123; int code; //代号 1:选手1 2:选手2 ChessBox box; abstract Point play(); //落子操作 int getLine(Point p, int i, int j) ;&#125;class Person extends Player&#123; Point play(int x,int y );&#125;class Robot extends Player&#123; //机器 int evaluate(Point, int, int); int Evaluate(Point); Point play();&#125;class ChessBox&#123; int chess_flag[15][15] //0:空 1:选手1 2:选手2&#125; &ensp;&ensp;&ensp;&ensp; 估值算法要求分析 估值算法。要求给定棋盘上一个点，求出该点在当前棋局下的权值。若在该点落子后更容易接近胜利，则该点权值就高，越接近5子相连，权值越高。 则函数的形式为int Evaluate(Point p); 首先考虑每个点有8个方向可以连子，每个方向上又有多种连子棋型，如活四、活三、死三等，而这些子又可能属于己方或者对方。活四与活三的权值自然不同。而同样是活三，己方的活三与对方的活三权值也不同，这样才能实现攻守的策略。假如现在棋局上同时有己方的活三和对方的活三，此时轮到我方落子，则正常情况下应当在己方活三上落子，使之成为活四，从而获胜。则计算机在判断棋局时，遇到己方活三，权值应当较高，遇到对方活三，权值应当较低。 以上即是对于估值函数所应达到的要求的分析。 方向问题 由于着眼处在于对棋型的判断，而不是方向，所以首先应该想个方法把方向问题先解决掉，这样在棋型判断时就能够对各个方向进行比较统一的处理，不至于棋型判断时对每个方向都写一段代码。 继续分析，在判断棋型时，着眼点在于棋子的相对位置，而常见棋型都呈线形排列，所以这个相对位置也就是顺序。相对位置、顺序，很容易想到要用一维的坐标解决。若取某一斜列（行、列），假设当前点的坐标为0，取右下（下、右、右上）为正方向，则在该斜列（行、列）上各点都能得到相应的坐标。如下图。 但若是同样的一维坐标，不同的方向，又会对应棋盘上不同的位置，也就是说，一维坐标转换到棋盘上的二维坐标，还需要一个方向。（额，想到这里，突然发现自己的思路明明就是极坐标啊。。。￣□￣｜｜………） 由此，我们需要达到这么一种要求：给定一个点、一个方向、一个相对坐标值，就能得到一个二维坐标，对应棋盘上一个点，进而可以获得任意一点的落子情况。所以我写了这么一个函数：1int getLine(Point p,int i,int j); 其中p为当前点，i为方向，取值为从1到8的整数，对应8个方向，j为相对于p点的坐标值。在函数体内要依据方向对p的x、y的值进行处理。返回该点的落子情况，0表示无子，1或2分别表示两个player，-1表示超出棋盘界。 代码如下： 12345678910111213141516171819202122int getLine(Point p, int i, int j) &#123; // p：当前点 i：方向 j：坐标相对值 int x = p.x, y = p.y; switch (i) &#123; //对8个方向的处理 case 1 : x = x + j; break; case 2 : x = x + j; y = y + j; break; ... ... case 8 : x = x + j; y = y - j; &#125; if (x &lt; 0 || y &lt; 0 || x &gt; 14 || y &gt; 14) &#123; // 越界处理 返回-1 return -1; &#125; return box.getFlag(x,y); &#125; &#125; 棋型判断 对于方向的处理完成后，就是棋型的判断。判断棋型时需要区分当前所判断的棋型是哪一方的，假设当前所判断的棋型所属方的代号为plyer，则它的值可以是1或2，而要确定这个plyer是自己还是对方，就需要和自己的代号比对一下，假设自己的代号是me。则这个判断棋型的函数应该满足以下要求：给出一个点p，自己的代号me，一个plyer，能得出当前点对应plyer的权值。于是函数形式如下：1int evaluate(Point p, int me,int plyer); 然后结合已有的算法结构，参考下图（网上找到的） 将棋型分为以下几种：&gt; 棋型|编码 —-|—-活四 |01111死四A |21111死四B |1111死四C |1111活三（近三位置） |1110活三（远三位置） |1110死三 |111&gt;其中代号及含义如下：&gt;代号|含义—-|— \ | 当前空位置; 0 | 其他空位置; 1 | plyer(当前所计算的player的代号); 2 |3 - plyer (对方的代号); 此外由于两个或多个方向上都有活二的棋型较为常见且胜率较高（见下图）。所以又增加对此种棋型的判断。 即在每一个方向的棋型判断中扫描011*0或111*0并计数，若最终计数值大于等于2，则权值增加一个较大的数值，否则不增加。 至此只要循环8次，每次循环中扫描各个棋型，并更新权值（设为value）即可。 代码如下：1234567891011121314151617181920212223242526272829int evaluate(Point p, int me,int plyer) &#123; /* me:我的代号; plyer:当前计算的player的代号;*/ int value = 0; int numoftwo=0; for (int i = 1; i &lt;= 8; i++) &#123; // 8个方向 // 活四 01111* *代表当前空位置 0代表其他空位置 if (getLine(p, i, -1) == plyer &amp;&amp; getLine(p, i, -2) == plyer &amp;&amp; getLine(p, i, -3) == plyer &amp;&amp; getLine(p, i, -4) == plyer &amp;&amp; getLine(p, i, -5) == 0) &#123; value += 300000; if(me!=plyer)&#123;value-=500;&#125; System.out.print("+ 300000"); continue; &#125; ... //计算011*0或111*0的个数 if (getLine(p, i, -1) == plyer &amp;&amp; getLine(p, i, -2) == plyer &amp;&amp; getLine(p, i, -3) != 3-plyer&amp;&amp;getLine(p,i,1)!=3-plyer) &#123; numoftwo++; &#125; ... &#125; if(numoftwo&gt;=2)&#123; value+=3000; if(me!=plyer)&#123; value-=100; &#125; &#125; return value;&#125; 其中每种棋型对value值所做的贡献要依据实际情况不断调整优化，优化不当就可能造成计算机放着活三不堵跑去堵活二了。。。 最终的估值函数int Evaluate(Point p)只要调用int evaluate(Point p, int me,int plyer)函数就可以获得p点的权值。 代码如下：1234int Evaluate(Point p)&#123; //code是调用者的代号 return evaluate(p,code,1)+ evaluate(p,code,2); &#125; &ensp;&ensp;&ensp;&ensp; 成果 最终程序核心算法只运用该估值算法，没有进行深度搜索。界面如下： 可见估值算法即便非常完美（当然这个算法离完美还差得远￣□￣｜｜），依然无法做到立于不败之地，因为往往会出现对方有多个接近连五，以至于堵都堵不住。所以博弈还是必须要深度搜索的。 &ensp;&ensp;&ensp;&ensp; 完整代码 最后贴出自己写的估值算法完整的代码（仅供参考，正确性未经严格验证）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145int Evaluate(Point p)&#123; return evaluate(p, code,1) + evaluate(p, code,2); &#125;int evaluate(Point p, int me,int plyer) &#123; // me:我的代号 plyer:当前计算的player的代号 int value = 0; int numoftwo=0; for (int i = 1; i &lt;= 8; i++) &#123; // 8个方向 // 活四 01111* *代表当前空位置 0代表其他空位置 下同 if (getLine(p, i, -1) == plyer &amp;&amp; getLine(p, i, -2) == plyer &amp;&amp; getLine(p, i, -3) == plyer &amp;&amp; getLine(p, i, -4) == plyer &amp;&amp; getLine(p, i, -5) == 0) &#123; value += 300000; if(me!=plyer)&#123;value-=500;&#125; continue; &#125; // 死四A 21111* if (getLine(p, i, -1) == plyer &amp;&amp; getLine(p, i, -2) == plyer &amp;&amp; getLine(p, i, -3) == plyer &amp;&amp; getLine(p, i, -4) == plyer &amp;&amp; (getLine(p, i, -5) == 3 - plyer||getLine(p, i, -5) == -1)) &#123; value += 250000; if(me!=plyer)&#123;value-=500;&#125; continue; &#125; // 死四B 111*1 if (getLine(p, i, -1) == plyer &amp;&amp; getLine(p, i, -2) == plyer &amp;&amp; getLine(p, i, -3) == plyer &amp;&amp; getLine(p, i, 1) == plyer) &#123; value += 240000; if(me!=plyer)&#123;value-=500;&#125; continue; &#125; // 死四C 11*11 if (getLine(p, i, -1) == plyer &amp;&amp; getLine(p, i, -2) == plyer &amp;&amp; getLine(p, i, 1) == plyer &amp;&amp; getLine(p, i, 2) == plyer) &#123; value += 230000; if(me!=plyer)&#123;value-=500;&#125; continue; &#125; // 活三 近3位置 111*0 if (getLine(p, i, -1) == plyer &amp;&amp; getLine(p, i, -2) == plyer &amp;&amp; getLine(p, i, -3) == plyer) &#123; if (getLine(p, i, 1) == 0) &#123; value += 750; if (getLine(p, i, -4) == 0) &#123; value += 3150; if(me!=plyer)&#123;value-=300;&#125; &#125; &#125; if ((getLine(p, i, 1) == 3 - plyer||getLine(p, i, 1) == -1) &amp;&amp; getLine(p, i, -4) == 0) &#123; value += 500; &#125; continue; &#125; // 活三 远3位置 1110* if (getLine(p, i, -1) == 0 &amp;&amp; getLine(p, i, -2) == plyer &amp;&amp; getLine(p, i, -3) == plyer &amp;&amp; getLine(p, i, -4) == plyer) &#123; value += 350; continue; &#125; // 死三 11*1 if (getLine(p, i, -1) == plyer &amp;&amp; getLine(p, i, -2) == plyer &amp;&amp; getLine(p, i, 1) == plyer) &#123; value += 600; if (getLine(p, i, -3) == 0 &amp;&amp; getLine(p, i, 2) == 0) &#123; value += 3150; continue; &#125; if ((getLine(p, i, -3) == 3 - plyer||getLine(p, i, -3) == -1) &amp;&amp; (getLine(p, i, 2) == 3 - plyer||getLine(p, i, 2) == -1)) &#123; continue; &#125; else &#123; value += 700; continue; &#125; &#125; //活二的个数 if (getLine(p, i, -1) == plyer &amp;&amp; getLine(p, i, -2) == plyer &amp;&amp; getLine(p, i, -3) != 3-plyer&amp;&amp;getLine(p,i,1)!=3-plyer) &#123; numoftwo++; &#125; //其余散棋 int numOfplyer = 0; // 因为方向会算两次？ for (int k = -4; k &lt;= 0; k++) &#123; // ++++* +++*+ ++*++ +*+++ *++++ int temp = 0; for (int l = 0; l &lt;= 4; l++) &#123; if (getLine(p, i, k + l) == plyer) &#123; temp++; &#125; else if (getLine(p, i, k + l) == 3 - plyer || getLine(p, i, k + l) == -1) &#123; temp = 0; break; &#125; &#125; numOfplyer += temp; &#125; value += numOfplyer * 15; if (numOfplyer != 0) &#123; &#125; &#125; if(numoftwo&gt;=2)&#123; value+=3000; if(me!=plyer)&#123; value-=100; &#125; &#125; return value; &#125;int getLine(Point p, int i, int j) &#123; // i:方向 j:相对p的顺序值（以p为0） p:当前点 int x = p.x, y = p.y; switch (i) &#123; case 1 : x = x + j; break; case 2 : x = x + j; y = y + j; break; case 3 : y = y + j; break; case 4 : x = x - j; y = y + j; break; case 5 : x = x - j; break; case 6 : x = x - j; y = y - j; break; case 7 : y = y - j; break; case 8 : x = x + j; y = y - j; &#125; if (x &lt; 0 || y &lt; 0 || x &gt; 14 || y &gt; 14) &#123; // 越界处理 return -1; &#125; return box.getFlag(x,y); &#125; 2015.9.21 10:53]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Notepad++编译运行Java(自定义包)]]></title>
      <url>2015%2F06%2F23%2FNotepad%2B%2B%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8CJava(%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85)%2F</url>
      <content type="text"><![CDATA[最近用Notepad++写汇编，感觉用起来挺顺手，于是想能不能也在这个好用的编辑器下编写Java并编译运行呢，因为每次启动eclipse都要挺长时间，而且eclipse实在太占内存。。。 于是各种百度之后，看网上的教程，使用Notepad++的NppExec(Notepad++的一个插件)实现了这一点。 附网址：Notepad++直接编译运行java代码 Notepad++ 配合JDK直接编译运行java代码 教程里基本都是用到了这两个命令： 123javac -encoding UTF-8 "$(FULL_CURRENT_PATH)"java -cp "$(CURRENT_DIRECTORY)" "$(NAME_PART)" Notepad++的环境变量: 变量名称 含义 FULL_CURRENT_PATH 文件路径名称 CURRENT_DIRECTORY 文件目录 FILE_NAME 文件全名称 NAME_PART 文件名称 EXT_PART 文件扩展名 然而，我写的Java代码里大都使用了package语句，使用这两个命令运行时就会出现“找不到或无法加载主类”的错误。 最后实在没办法，我就用C++写了两个程序。 12345678910111213141516171819//myjavac.cpp#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;using namespace std;int main(int argc,char* args[])&#123; string s1(args[1]),s2(args[2]); string j; j="javac -d "+s1+" "+s2; //javac -d directory_name file_name cout&lt;&lt;j&lt;&lt;endl; system(&amp;j[0]); system("Pause"); return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//myjava.cpp#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;using namespace std;int main(int argc,char* args[])&#123; string name,name1; stringstream tp,tp1; string ss(args[1]); int index=0; for( int ind=0;ind&lt;=ss.length();ind++)&#123; if(ss[ind]=='\\'||ss[ind]=='\\\\')&#123; index=ind; &#125; &#125; for(int in=index+1;in&lt;=ss.length();in++)&#123; tp&lt;&lt;ss[in]; &#125; tp&gt;&gt;name1; for( in=0;in&lt;=name1.length()-1;in++)&#123; if(name1[in]=='.')&#123; break; &#125; tp1&lt;&lt;name1[in]; &#125; tp1&gt;&gt;name; cout&lt;&lt;"class:"&lt;&lt;name&lt;&lt;endl; fstream filestr(args[1],fstream::in|fstream::out); string s="",t=""; filestr&gt;&gt;s; string j; stringstream ss1; if(s=="package")&#123; filestr&gt;&gt;t; int x=t.length(); t[x-1]='\0'; cout&lt;&lt;"package:"&lt;&lt;t&lt;&lt;endl; ss1&lt;&lt;"java "&lt;&lt;t&lt;&lt;"."&lt;&lt;name; //java package_name.main_class_name &#125; else&#123; ss1&lt;&lt;"java "&lt;&lt;name; //java main_class_name &#125; filestr.close(); j=ss1.str(); cout&lt;&lt;j&lt;&lt;endl; system(&amp;j[0]); system("Pause"); return 0;&#125; 把生成的两个EXE文件放在一个文件夹（比如F:\\myshell）里，然后再把这个文件夹添加到系统的PATH环境变量里， 然后打开Notepad++，点击运行菜单中的运行 输入exe的文件名,myjavac后面的两个参数是$(CURRENT_DIRECTORY) $(FULL_CURRENT_PATH) myjava后面的两个参数是$(FULL_CURRENT_PATH) $(NAME_PART) （参数之间用空格隔开） 然后点击保存，输入名称，选择快捷键（不选也可以），就可以把自己的命令添加到运行菜单了。 还可以通过修改C++代码或是使用批处理把两个命令合并为一个命令。 2015.6.27更新 发现自己的程序无法应付多个java文件的编译。所以又改写了myjavac.cpp的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546//myjavac.cpp#include &lt;iostream&gt;#include &lt;windows.h&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;fstream&gt;using namespace std;int main(int argc,char* args[])&#123; string s1(args[1]); string dir="dir "+s1+" /b &gt;java_files.txt"; cout&lt;&lt;dir&lt;&lt;endl; system(&amp;dir[0]); string filenames[30]; for(int i=0;i&lt;=29;i++)&#123; filenames[i]=""; &#125; fstream file("java_files.txt"); int index=0; while(file.eof()==false)&#123; file&gt;&gt;filenames[index]; index++; &#125; file.close(); system("del java_files.txt"); stringstream ss; ss&lt;&lt;"javac -d "&lt;&lt;s1&lt;&lt;" "; for(int in=0;in&lt;=29;in++)&#123; if(filenames[in]!="")&#123; string temp=filenames[in]; if(temp.compare(temp.length()-5, temp.length()-1,string(".java"))==0)&#123; ss&lt;&lt;filenames[in]&lt;&lt;" "; &#125; &#125; else&#123; break; &#125; &#125; string j; j=ss.str(); cout&lt;&lt;j&lt;&lt;endl; system(&amp;j[0]); system("Pause"); return 0;&#125; 此时myjavac的参数就只需要$(CURRENT_DIRECTORY)了。 至此就实现了123javac -d directory_name file_name1 file_name2 file_name3...java package_name.main_class_name 这两个命令。也就能实现绝大多数情况下的 Java 编译和运行了。 2015.7.2更新 后天期末考试，这两天紧张复习中。。。压力山大 发现程序似乎依然有小错误，当文件名长度小于5的时候。。。有空再改]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java cmd（即Java的JDK配置及相关常用命令）]]></title>
      <url>2015%2F05%2F28%2FJava%E7%9A%84cmd%E9%85%8D%E7%BD%AE%2F</url>
      <content type="text"><![CDATA[找不到或无法加载主类这段时间一直纠结于cmd下Java无法编译运行的问题。主要问题描述如下： javac 命令可以正常运行，而java命令有时可以正常运行，有时却不可以，不可以的症状就是显示找不到或无法加载主类。 在网上找了各种资料，最终发现是因为代码里含有package语句，所以无法在cmd下运行java命令解释.class文件。而那些可以运行的文件就是因为没有使用package语句。 这种问题的解决方法就是使用几个特殊的命令。 常用的命令是1234567# 此处注释采用“#”，若要复制代码到cmd，请勿复制注释部分# 设.java文件名为 filename# 注意主类的名字和文件名完全相同，包括大小写。javac filename.javajava filename 而若代码里有package语句，则要使用1javac -d 指定的目录 filename.java # 如 javac -d F: filename.java 执行后就会在指定目录里生成一个文件夹，如果指定目录是.，则代表当前目录。文件夹名字就是package的名字（设为pkname），接下来使用1java pkname.filename 即可运行。 若程序中用到多个.java文件或多个.class文件也可使用这两条语句。 附启发性网址：cmd下的Java执行 其他常见问题：javac 和 java 的版本不同：在cmd下输入1java -version //显示java命令的版本号 和1javac -version //显示javac命令的版本号 如果java的版本号高于javac的版本号，java还是可以正常运行的。但如果java的版本号低于javac，则java无法正常运行。因为低版本的java无法运行高版本的javac所编译出的.class文件。 解决方法附网址： java与javac版本不一致问题 如果网址失效，则百度“java与javac版本” 环境变量设置问题：首先解释一下环境变量应该设置用户的还是系统的，附网址：环境变量中系统变量和用户的环境变量及在配置JAVA环境变量时两着有什么区别 总体来说就是设置系统的则所有用户都能使用，设置用户的则当前用户可以使用，换个用户就不好使了。但在Windows上大多数人不存在这个问题，所以两个都可以。如果不确定的话，就设置系统的吧。再不放心就两个都设置一下（比如我。。） 首先设置JAVA_HOME，我的是12345# JAVA_HOMED:\Java\jdk1.8.0_05 # 注意此处是D:\Java\jdk1.8.0_05还是D:\Java\jdk1.8.0_05\ ，两者差了一个“\” 然后是PATH123456789# PATH# 在原有的PATH值最前面加上.;%JAVA_HOME%\bin; # 注意此处以“.”开头，表示当前目录。# 而这里的%JAVA_HOME%也就相当于上面你为它赋值的那一串，# 所以如果你的%JAVA_HOME%是带“\”的，# 你的PATH添加的内容就该是 .;%JAVA_HOME%bin; 然后是CLASSPATH1234567# CLASSPATH.;%JAVA_HOME%\lib\tools.jar;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib; # 此处依然以“.”开头，表示当前目录，# 这样你才能cd进入一个目录并执行该目录下的.java文件。# 至于lib前面的“\”加不加，同PATH的处理方法。 附网址一个：实例详解classpath 2015-05-28 22:23:09]]></content>
    </entry>

    
  
  
</search>
